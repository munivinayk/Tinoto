{"ast":null,"code":"import maplibregl__default from 'maplibre-gl';\nexport * from 'maplibre-gl';\nimport { Base64 } from 'js-base64';\nimport EventEmitter from 'events';\nimport { config as config$1, MapStyle, mapStylePresetList, expandMapStyle, MapStyleVariant, ReferenceMapStyle, geolocation } from '@maptiler/client';\nexport { LanguageGeocoding, MapStyle, MapStyleVariant, ReferenceMapStyle, ServiceError, bufferToPixelDataBrowser, circumferenceAtLatitude, coordinates, data, elevation, expandMapStyle, geocoding, geolocation, getAutoLanguageGeocoding, getBufferToPixelDataParser, getTileCache, mapStylePresetList, math, misc, staticMaps, styleToStyle } from '@maptiler/client';\nimport { v4 } from 'uuid';\nconst Language = {\n  /**\n   * The visitor language mode concatenates the prefered language from the user settings and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR: \"visitor\",\n  /**\n   * The visitor language mode concatenates English and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR_ENGLISH: \"visitor_en\",\n  /**\n   * Language as the style is designed. Not that this is the default state and one\n   * the language has been changed to another than `STYLE`, then it cannot be set back to `STYLE`.\n   */\n  STYLE: \"style\",\n  /**\n   * AUTO mode uses the language of the browser\n   */\n  AUTO: \"auto\",\n  /**\n   * STYLE is a custom flag to keep the language of the map as defined into the style.\n   * If STYLE is set in the constructor, then further modification of the language\n   * with `.setLanguage()` is not possible.\n   */\n  STYLE_LOCK: \"style_lock\",\n  /**\n   * Default fallback languages that uses latin charaters\n   */\n  LATIN: \"name:latin\",\n  /**\n   * Default fallback languages that uses non-latin charaters\n   */\n  NON_LATIN: \"name:nonlatin\",\n  /**\n   * Labels are in their local language, when available\n   */\n  LOCAL: \"name\",\n  /**\n   * International name\n   */\n  INTERNATIONAL: \"name_int\",\n  ALBANIAN: \"name:sq\",\n  AMHARIC: \"name:am\",\n  ARABIC: \"name:ar\",\n  ARMENIAN: \"name:hy\",\n  AZERBAIJANI: \"name:az\",\n  BASQUE: \"name:eu\",\n  BELORUSSIAN: \"name:be\",\n  BENGALI: \"name:bn\",\n  BOSNIAN: \"name:bs\",\n  BRETON: \"name:br\",\n  BULGARIAN: \"name:bg\",\n  CATALAN: \"name:ca\",\n  CHINESE: \"name:zh\",\n  TRADITIONAL_CHINESE: \"name:zh-Hant\",\n  SIMPLIFIED_CHINESE: \"name:zh-Hans\",\n  CORSICAN: \"name:co\",\n  CROATIAN: \"name:hr\",\n  CZECH: \"name:cs\",\n  DANISH: \"name:da\",\n  DUTCH: \"name:nl\",\n  ENGLISH: \"name:en\",\n  ESPERANTO: \"name:eo\",\n  ESTONIAN: \"name:et\",\n  FINNISH: \"name:fi\",\n  FRENCH: \"name:fr\",\n  FRISIAN: \"name:fy\",\n  GEORGIAN: \"name:ka\",\n  GERMAN: \"name:de\",\n  GREEK: \"name:el\",\n  HEBREW: \"name:he\",\n  HINDI: \"name:hi\",\n  HUNGARIAN: \"name:hu\",\n  ICELANDIC: \"name:is\",\n  INDONESIAN: \"name:id\",\n  IRISH: \"name:ga\",\n  ITALIAN: \"name:it\",\n  JAPANESE: \"name:ja\",\n  JAPANESE_HIRAGANA: \"name:ja-Hira\",\n  JAPANESE_KANA: \"name:ja_kana\",\n  JAPANESE_LATIN: \"name:ja_rm\",\n  JAPANESE_2018: \"name:ja-Latn\",\n  KANNADA: \"name:kn\",\n  KAZAKH: \"name:kk\",\n  KOREAN: \"name:ko\",\n  KOREAN_LATIN: \"name:ko-Latn\",\n  KURDISH: \"name:ku\",\n  ROMAN_LATIN: \"name:la\",\n  LATVIAN: \"name:lv\",\n  LITHUANIAN: \"name:lt\",\n  LUXEMBOURGISH: \"name:lb\",\n  MACEDONIAN: \"name:mk\",\n  MALAYALAM: \"name:ml\",\n  MALTESE: \"name:mt\",\n  NORWEGIAN: \"name:no\",\n  OCCITAN: \"name:oc\",\n  PERSIAN: \"name:fa\",\n  POLISH: \"name:pl\",\n  PORTUGUESE: \"name:pt\",\n  PUNJABI: \"name:pa\",\n  WESTERN_PUNJABI: \"name:pnb\",\n  ROMANIAN: \"name:ro\",\n  ROMANSH: \"name:rm\",\n  RUSSIAN: \"name:ru\",\n  SCOTTISH_GAELIC: \"name:gd\",\n  SERBIAN_CYRILLIC: \"name:sr\",\n  SERBIAN_LATIN: \"name:sr-Latn\",\n  SLOVAK: \"name:sk\",\n  SLOVENE: \"name:sl\",\n  SPANISH: \"name:es\",\n  SWEDISH: \"name:sv\",\n  TAMIL: \"name:ta\",\n  TELUGU: \"name:te\",\n  THAI: \"name:th\",\n  TURKISH: \"name:tr\",\n  UKRAINIAN: \"name:uk\",\n  URDU: \"name:ur\",\n  VIETNAMIAN_LATIN: \"name:vi\",\n  WELSH: \"name:cy\"\n};\nconst languagesIsoSet = new Set(Object.values(Language));\nfunction isLanguageSupported(lang) {\n  return languagesIsoSet.has(lang);\n}\nconst languageCodeSet = new Set(Object.values(Language));\nfunction getBrowserLanguage() {\n  if (typeof navigator === \"undefined\") {\n    return `name:${Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0]}`;\n  }\n  const canditatelangs = Array.from(new Set(navigator.languages.map(l => `name:${l.split(\"-\")[0]}`))).filter(l => languageCodeSet.has(l));\n  return canditatelangs.length ? canditatelangs[0] : Language.LOCAL;\n}\nconst defaults = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: Language.STYLE,\n  secondaryLanguage: Language.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\"\n};\nObject.freeze(defaults);\nvar __defProp$b = Object.defineProperty;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$8 = (obj, key, value) => {\n  __defNormalProp$b(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst MAPTILER_SESSION_ID = v4();\nclass SdkConfig extends EventEmitter {\n  constructor() {\n    super();\n    /**\n     * The primary language. By default, the language of the web browser is used.\n     */\n    __publicField$8(this, \"primaryLanguage\", defaults.primaryLanguage);\n    /**\n     * The secondary language, to overwrite the default language defined in the map style.\n     * This settings is highly dependant on the style compatibility and may not work in most cases.\n     */\n    __publicField$8(this, \"secondaryLanguage\");\n    /**\n     * Setting on whether of not the SDK runs with a session logic.\n     * A \"session\" is started at the initialization of the SDK and finished when the browser\n     * page is being refreshed.\n     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n     * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n     */\n    __publicField$8(this, \"session\", true);\n    /**\n     * Unit to be used\n     */\n    __publicField$8(this, \"_unit\", \"metric\");\n    /**\n     * MapTiler Cloud API key\n     */\n    __publicField$8(this, \"_apiKey\", \"\");\n  }\n  /**\n   * Set the unit system\n   */\n  set unit(u) {\n    this._unit = u;\n    this.emit(\"unit\", u);\n  }\n  /**\n   * Get the unit system\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n    config$1.apiKey = k;\n    this.emit(\"apiKey\", k);\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    config$1.fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return config$1.fetch;\n  }\n}\nconst config = new SdkConfig();\nclass LogoControl extends maplibregl__default.LogoControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nvar __defProp$a = Object.defineProperty;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$7 = (obj, key, value) => {\n  __defNormalProp$a(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerLogoControl extends LogoControl {\n  constructor(options = {}) {\n    var _a, _b;\n    super(options);\n    __publicField$7(this, \"logoURL\", \"\");\n    __publicField$7(this, \"linkURL\", \"\");\n    this.logoURL = (_a = options.logoURL) != null ? _a : defaults.maptilerLogoURL;\n    this.linkURL = (_b = options.linkURL) != null ? _b : defaults.maptilerURL;\n  }\n  onAdd(map) {\n    var _a;\n    this._map = map;\n    this._compact = (_a = this.options.compact) != null ? _a : false;\n    this._container = window.document.createElement(\"div\");\n    this._container.className = \"maplibregl-ctrl\";\n    const anchor = window.document.createElement(\"a\");\n    anchor.style.backgroundRepeat = \"no-repeat\";\n    anchor.style.cursor = \"pointer\";\n    anchor.style.display = \"block\";\n    anchor.style.height = \"23px\";\n    anchor.style.margin = \"0 0 -4px -4px\";\n    anchor.style.overflow = \"hidden\";\n    anchor.style.width = \"88px\";\n    anchor.style.backgroundImage = `url(${this.logoURL})`;\n    anchor.style.backgroundSize = \"100px 30px\";\n    anchor.style.width = \"100px\";\n    anchor.style.height = \"30px\";\n    anchor.target = \"_blank\";\n    anchor.rel = \"noopener\";\n    anchor.href = this.linkURL;\n    anchor.setAttribute(\"aria-label\", \"MapTiler logo\");\n    anchor.setAttribute(\"rel\", \"noopener\");\n    this._container.appendChild(anchor);\n    this._container.style.display = \"block\";\n    this._map.on(\"resize\", this._updateCompact);\n    this._updateCompact();\n    return this._container;\n  }\n}\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$5.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5) for (var prop of __getOwnPropSymbols$5(b)) {\n    if (__propIsEnum$5.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);\n  }\n  return a;\n};\nfunction enableRTL() {\n  if (maplibregl__default.getRTLTextPluginStatus() === \"unavailable\") {\n    maplibregl__default.setRTLTextPlugin(defaults.rtlPluginURL, err => {\n      if (err) console.error(err);\n    }, true\n    // Lazy load the plugin\n    );\n  }\n}\nfunction bindAll(fns, context) {\n  fns.forEach(fn => {\n    if (typeof context[fn] !== \"function\") return;\n    context[fn] = context[fn].bind(context);\n  });\n}\nfunction DOMcreate(tagName, className, container) {\n  const el = window.document.createElement(tagName);\n  if (className !== void 0) el.className = className;\n  if (container) container.appendChild(el);\n  return el;\n}\nfunction DOMremove(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction maptilerCloudTransformRequest(url, _resourceType) {\n  let reqUrl = null;\n  try {\n    reqUrl = new URL(url);\n  } catch (e) {\n    return {\n      url\n    };\n  }\n  if (reqUrl.host === defaults.maptilerApiHost) {\n    if (!reqUrl.searchParams.has(\"key\")) {\n      reqUrl.searchParams.append(\"key\", config.apiKey);\n    }\n    if (config.session) {\n      reqUrl.searchParams.append(\"mtsid\", MAPTILER_SESSION_ID);\n    }\n  }\n  return {\n    url: reqUrl.href\n  };\n}\nfunction combineTransformRequest(userDefinedRTF) {\n  return function (url, resourceType) {\n    var _a;\n    if (userDefinedRTF !== void 0) {\n      const rp = userDefinedRTF(url, resourceType);\n      const rp2 = maptilerCloudTransformRequest((_a = rp == null ? void 0 : rp.url) != null ? _a : \"\");\n      return __spreadValues$5(__spreadValues$5({}, rp), rp2);\n    } else {\n      return maptilerCloudTransformRequest(url);\n    }\n  };\n}\nfunction generateRandomString() {\n  return Math.random().toString(36).substring(2);\n}\nfunction isUUID(s) {\n  const regexExp = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi;\n  return regexExp.test(s);\n}\nfunction jsonParseNoThrow(doc) {\n  try {\n    return JSON.parse(doc);\n  } catch (e) {}\n  return null;\n}\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    if (!style.startsWith(\"http\") && style.toLowerCase().includes(\".json\")) {\n      return style;\n    } else {\n      return expandMapStyle(style);\n    }\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getExpandedStyleURL();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getExpandedStyleURL();\n  }\n  return style;\n}\nvar __defProp$8 = Object.defineProperty;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$6 = (obj, key, value) => {\n  __defNormalProp$8(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerTerrainControl {\n  constructor() {\n    __publicField$6(this, \"_map\");\n    __publicField$6(this, \"_container\");\n    __publicField$6(this, \"_terrainButton\");\n    bindAll([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n  onAdd(map) {\n    this._map = map;\n    this._container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    this._terrainButton = DOMcreate(\"button\", \"maplibregl-ctrl-terrain\", this._container);\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\"aria-hidden\", \"true\");\n    this._terrainButton.type = \"button\";\n    this._terrainButton.addEventListener(\"click\", this._toggleTerrain);\n    this._updateTerrainIcon();\n    this._map.on(\"terrain\", this._updateTerrainIcon);\n    return this._container;\n  }\n  onRemove() {\n    DOMremove(this._container);\n    this._map.off(\"terrain\", this._updateTerrainIcon);\n    this._map = void 0;\n  }\n  _toggleTerrain() {\n    if (this._map.hasTerrain()) {\n      this._map.disableTerrain();\n    } else {\n      this._map.enableTerrain();\n    }\n    this._updateTerrainIcon();\n  }\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\");\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\");\n    if (this._map.hasTerrain()) {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\");\n      this._terrainButton.title = this._map._getUIString(\"TerrainControl.disableTerrain\");\n    } else {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\");\n      this._terrainButton.title = this._map._getUIString(\"TerrainControl.enableTerrain\");\n    }\n  }\n}\nclass NavigationControl extends maplibregl__default.NavigationControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nvar __defProp$7 = Object.defineProperty;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$5 = (obj, key, value) => {\n  __defNormalProp$7(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MaptilerNavigationControl extends NavigationControl {\n  constructor() {\n    super({\n      showCompass: true,\n      showZoom: true,\n      visualizePitch: true\n    });\n    /**\n     * Overloading: Limit how flat the compass icon can get\n     */\n    __publicField$5(this, \"_rotateCompassArrow\", () => {\n      const rotate = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5))}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n      this._compassIcon.style.transform = rotate;\n    });\n    this._compass.removeEventListener(\"click\", this._compass.clickFunction);\n    this._compass.addEventListener(\"click\", e => {\n      {\n        const currentPitch = this._map.getPitch();\n        if (currentPitch === 0) {\n          this._map.easeTo({\n            pitch: Math.min(this._map.getMaxPitch(), 80)\n          });\n        } else {\n          if (this.options.visualizePitch) {\n            this._map.resetNorthPitch({}, {\n              originalEvent: e\n            });\n          } else {\n            this._map.resetNorth({}, {\n              originalEvent: e\n            });\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(className, fn) {\n    const button = super._createButton(className, fn);\n    button.clickFunction = fn;\n    return button;\n  }\n}\nclass GeolocateControl extends maplibregl__default.GeolocateControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$4.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4) for (var prop of __getOwnPropSymbols$4(b)) {\n    if (__propIsEnum$4.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __publicField$4 = (obj, key, value) => {\n  __defNormalProp$6(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Marker$1 = maplibregl__default.Marker;\nconst LngLat$1 = maplibregl__default.LngLat;\nconst LngLatBounds$1 = maplibregl__default.LngLatBounds;\nclass MaptilerGeolocateControl extends GeolocateControl {\n  constructor() {\n    super(...arguments);\n    __publicField$4(this, \"lastUpdatedCenter\", new LngLat$1(0, 0));\n    /**\n     * Update the camera location to center on the current position\n     *\n     * @param {Position} position the Geolocation API Position\n     * @private\n     */\n    __publicField$4(this, \"_updateCamera\", position => {\n      var _a, _b, _c;\n      const center = new LngLat$1(position.coords.longitude, position.coords.latitude);\n      const radius = position.coords.accuracy;\n      const bearing = this._map.getBearing();\n      const options = __spreadProps$3(__spreadValues$4({\n        bearing\n      }, this.options.fitBoundsOptions), {\n        linear: true\n      });\n      const currentMapZoom = this._map.getZoom();\n      if (currentMapZoom > ((_c = (_b = (_a = this.options) == null ? void 0 : _a.fitBoundsOptions) == null ? void 0 : _b.maxZoom) != null ? _c : 30)) {\n        options.zoom = currentMapZoom;\n      }\n      this._map.fitBounds(LngLatBounds$1.fromLngLat(center, radius), options, {\n        geolocateSource: true\n        // tag this camera change so it won't cause the control to change to background state\n      });\n      let hasFittingBeenDisrupted = false;\n      const flagFittingDisruption = () => {\n        hasFittingBeenDisrupted = true;\n      };\n      this._map.once(\"click\", flagFittingDisruption);\n      this._map.once(\"dblclick\", flagFittingDisruption);\n      this._map.once(\"dragstart\", flagFittingDisruption);\n      this._map.once(\"mousedown\", flagFittingDisruption);\n      this._map.once(\"touchstart\", flagFittingDisruption);\n      this._map.once(\"wheel\", flagFittingDisruption);\n      this._map.once(\"moveend\", () => {\n        this._map.off(\"click\", flagFittingDisruption);\n        this._map.off(\"dblclick\", flagFittingDisruption);\n        this._map.off(\"dragstart\", flagFittingDisruption);\n        this._map.off(\"mousedown\", flagFittingDisruption);\n        this._map.off(\"touchstart\", flagFittingDisruption);\n        this._map.off(\"wheel\", flagFittingDisruption);\n        if (hasFittingBeenDisrupted) {\n          return;\n        }\n        this.lastUpdatedCenter = this._map.getCenter();\n      });\n    });\n    __publicField$4(this, \"_setupUI\", supported => {\n      this.lastUpdatedCenter = this._map.getCenter();\n      this._container.addEventListener(\"contextmenu\", e => e.preventDefault());\n      this._geolocateButton = DOMcreate(\"button\", \"maplibregl-ctrl-geolocate\", this._container);\n      DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\");\n      this._geolocateButton.type = \"button\";\n      if (supported === false) {\n        const title = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n        this._geolocateButton.disabled = true;\n        this._geolocateButton.title = title;\n        this._geolocateButton.setAttribute(\"aria-label\", title);\n      } else {\n        const title = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n        this._geolocateButton.title = title;\n        this._geolocateButton.setAttribute(\"aria-label\", title);\n      }\n      if (this.options.trackUserLocation) {\n        this._geolocateButton.setAttribute(\"aria-pressed\", \"false\");\n        this._watchState = \"OFF\";\n      }\n      if (this.options.showUserLocation) {\n        this._dotElement = DOMcreate(\"div\", \"maplibregl-user-location-dot\");\n        this._userLocationDotMarker = new Marker$1({\n          element: this._dotElement\n        });\n        this._circleElement = DOMcreate(\"div\", \"maplibregl-user-location-accuracy-circle\");\n        this._accuracyCircleMarker = new Marker$1({\n          element: this._circleElement,\n          pitchAlignment: \"map\"\n        });\n        if (this.options.trackUserLocation) this._watchState = \"OFF\";\n        this._map.on(\"move\", this._onZoom);\n      }\n      this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this));\n      this._setup = true;\n      if (this.options.trackUserLocation) {\n        this._map.on(\"moveend\", event => {\n          const fromResize = event.originalEvent && event.originalEvent.type === \"resize\";\n          const movingDistance = this.lastUpdatedCenter.distanceTo(this._map.getCenter());\n          if (!event.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !fromResize && movingDistance > 1) {\n            this._watchState = \"BACKGROUND\";\n            this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\");\n            this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\");\n            this.fire(new Event(\"trackuserlocationend\"));\n          }\n        });\n      }\n    });\n    __publicField$4(this, \"_onZoom\", () => {\n      if (this.options.showUserLocation && this.options.showAccuracyCircle) {\n        this._updateCircleRadius();\n      }\n    });\n  }\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\") {\n      return;\n    }\n    const lastKnownLocation = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude];\n    const projectedLocation = this._map.project(lastKnownLocation);\n    const a = this._map.unproject([projectedLocation.x, projectedLocation.y]);\n    const b = this._map.unproject([projectedLocation.x + 20, projectedLocation.y]);\n    const metersPerPixel = a.distanceTo(b) / 20;\n    const circleDiameter = Math.ceil(2 * this._accuracy / metersPerPixel);\n    this._circleElement.style.width = `${circleDiameter}px`;\n    this._circleElement.style.height = `${circleDiameter}px`;\n  }\n}\nclass AttributionControl extends maplibregl__default.AttributionControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nclass ScaleControl extends maplibregl__default.ScaleControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nclass FullscreenControl extends maplibregl__default.FullscreenControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$3.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3) for (var prop of __getOwnPropSymbols$3(b)) {\n    if (__propIsEnum$3.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __publicField$3 = (obj, key, value) => {\n  __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _options, _parentMap, _container, _canvasContainer, _parentRect, _differentStyle, _desync, _addParentRect, addParentRect_fn, _setParentBounds, setParentBounds_fn, _syncMaps, syncMaps_fn;\nclass Minimap {\n  constructor(options, mapOptions) {\n    __privateAdd(this, _addParentRect);\n    __privateAdd(this, _setParentBounds);\n    __privateAdd(this, _syncMaps);\n    __privateAdd(this, _options, void 0);\n    __publicField$3(this, \"map\");\n    __privateAdd(this, _parentMap, void 0);\n    __privateAdd(this, _container, void 0);\n    __privateAdd(this, _canvasContainer, void 0);\n    __privateAdd(this, _parentRect, void 0);\n    __privateAdd(this, _differentStyle, false);\n    __privateAdd(this, _desync, void 0);\n    var _a;\n    if (options.style !== void 0) __privateSet(this, _differentStyle, true);\n    __privateSet(this, _options, __spreadProps$2(__spreadValues$3(__spreadProps$2(__spreadValues$3({\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\"\n    }, mapOptions), {\n      // override any lingering control options\n      forceNoAttributionControl: true,\n      attributionControl: false,\n      navigationControl: false,\n      geolocateControl: false,\n      maptilerLogo: false,\n      minimap: false,\n      hash: false,\n      pitchAdjust: false\n    }), options), {\n      containerStyle: __spreadValues$3({\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\"\n      }, (_a = options.containerStyle) != null ? _a : {})\n    }));\n    if (options.lockZoom !== void 0) {\n      __privateGet(this, _options).minZoom = options.lockZoom;\n      __privateGet(this, _options).maxZoom = options.lockZoom;\n    }\n  }\n  setStyle(style, options) {\n    if (!__privateGet(this, _differentStyle)) this.map.setStyle(style, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n  }\n  addLayer(layer, beforeId) {\n    if (!__privateGet(this, _differentStyle)) this.map.addLayer(layer, beforeId);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this.map;\n  }\n  moveLayer(id, beforeId) {\n    if (!__privateGet(this, _differentStyle)) this.map.moveLayer(id, beforeId);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this.map;\n  }\n  removeLayer(id) {\n    if (!__privateGet(this, _differentStyle)) this.map.removeLayer(id);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setLayerZoomRange(layerId, minzoom, maxzoom) {\n    if (!__privateGet(this, _differentStyle)) this.map.setLayerZoomRange(layerId, minzoom, maxzoom);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setFilter(layerId, filter, options) {\n    if (!__privateGet(this, _differentStyle)) this.map.setFilter(layerId, filter, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setPaintProperty(layerId, name, value, options) {\n    if (!__privateGet(this, _differentStyle)) this.map.setPaintProperty(layerId, name, value, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setLayoutProperty(layerId, name, value, options) {\n    if (!__privateGet(this, _differentStyle)) this.map.setLayoutProperty(layerId, name, value, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  setGlyphs(glyphsUrl, options) {\n    if (!__privateGet(this, _differentStyle)) this.map.setGlyphs(glyphsUrl, options);\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    return this;\n  }\n  onAdd(parentMap) {\n    __privateSet(this, _parentMap, parentMap);\n    __privateSet(this, _container, DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"));\n    for (const [key, value] of Object.entries(__privateGet(this, _options).containerStyle)) {\n      __privateGet(this, _container).style.setProperty(key, value);\n    }\n    __privateGet(this, _options).container = __privateGet(this, _container);\n    __privateGet(this, _options).zoom = parentMap.getZoom() + __privateGet(this, _options).zoomAdjust;\n    this.map = new Map(__privateGet(this, _options));\n    this.map.once(\"style.load\", () => {\n      this.map.resize();\n    });\n    this.map.once(\"load\", () => {\n      __privateMethod(this, _addParentRect, addParentRect_fn).call(this, __privateGet(this, _options).parentRect);\n      __privateSet(this, _desync, __privateMethod(this, _syncMaps, syncMaps_fn).call(this));\n    });\n    return __privateGet(this, _container);\n  }\n  onRemove() {\n    var _a;\n    (_a = __privateGet(this, _desync)) == null ? void 0 : _a.call(this);\n    DOMremove(__privateGet(this, _container));\n  }\n}\n_options = new WeakMap();\n_parentMap = new WeakMap();\n_container = new WeakMap();\n_canvasContainer = new WeakMap();\n_parentRect = new WeakMap();\n_differentStyle = new WeakMap();\n_desync = new WeakMap();\n_addParentRect = new WeakSet();\naddParentRect_fn = function (rect) {\n  if (rect === void 0 || rect.linePaint === void 0 && rect.fillPaint === void 0) {\n    return;\n  }\n  __privateSet(this, _parentRect, {\n    type: \"Feature\",\n    properties: {\n      name: \"parentRect\"\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [[[], [], [], [], []]]\n    }\n  });\n  this.map.addSource(\"parentRect\", {\n    type: \"geojson\",\n    data: __privateGet(this, _parentRect)\n  });\n  if (rect.lineLayout !== void 0 || rect.linePaint !== void 0) {\n    this.map.addLayer({\n      id: \"parentRectOutline\",\n      type: \"line\",\n      source: \"parentRect\",\n      layout: __spreadValues$3({}, rect.lineLayout),\n      paint: __spreadValues$3({\n        \"line-color\": \"#FFF\",\n        \"line-width\": 1,\n        \"line-opacity\": 0.85\n      }, rect.linePaint)\n    });\n  }\n  if (rect.fillPaint !== void 0) {\n    this.map.addLayer({\n      id: \"parentRectFill\",\n      type: \"fill\",\n      source: \"parentRect\",\n      layout: {},\n      paint: __spreadValues$3({\n        \"fill-color\": \"#08F\",\n        \"fill-opacity\": 0.135\n      }, rect.fillPaint)\n    });\n  }\n  __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n};\n_setParentBounds = new WeakSet();\nsetParentBounds_fn = function () {\n  if (__privateGet(this, _parentRect) === void 0) return;\n  const {\n    devicePixelRatio\n  } = window;\n  const canvas = __privateGet(this, _parentMap).getCanvas();\n  const width = canvas.width / devicePixelRatio;\n  const height = canvas.height / devicePixelRatio;\n  const unproject = __privateGet(this, _parentMap).unproject.bind(__privateGet(this, _parentMap));\n  const northWest = unproject([0, 0]);\n  const northEast = unproject([width, 0]);\n  const southWest = unproject([0, height]);\n  const southEast = unproject([width, height]);\n  __privateGet(this, _parentRect).geometry.coordinates = [[southWest.toArray(), southEast.toArray(), northEast.toArray(), northWest.toArray(), southWest.toArray()]];\n  const source = this.map.getSource(\"parentRect\");\n  source.setData(__privateGet(this, _parentRect));\n};\n_syncMaps = new WeakSet();\nsyncMaps_fn = function () {\n  const {\n    pitchAdjust\n  } = __privateGet(this, _options);\n  const parentCallback = () => {\n    sync(\"parent\");\n  };\n  const minimapCallback = () => {\n    sync(\"minimap\");\n  };\n  const on = () => {\n    __privateGet(this, _parentMap).on(\"move\", parentCallback);\n    this.map.on(\"move\", minimapCallback);\n  };\n  const off = () => {\n    __privateGet(this, _parentMap).off(\"move\", parentCallback);\n    this.map.off(\"move\", minimapCallback);\n  };\n  const sync = which => {\n    var _a;\n    off();\n    const from = which === \"parent\" ? __privateGet(this, _parentMap) : this.map;\n    const to = which === \"parent\" ? this.map : __privateGet(this, _parentMap);\n    const center = from.getCenter();\n    const zoom = from.getZoom() + ((_a = __privateGet(this, _options).zoomAdjust) != null ? _a : -4) * (which === \"parent\" ? 1 : -1);\n    const bearing = from.getBearing();\n    const pitch = from.getPitch();\n    to.jumpTo({\n      center,\n      zoom,\n      bearing,\n      pitch: pitchAdjust ? pitch : 0\n    });\n    __privateMethod(this, _setParentBounds, setParentBounds_fn).call(this);\n    on();\n  };\n  on();\n  return () => {\n    off();\n  };\n};\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) {\n    if (__propIsEnum$2.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async$1 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst GeolocationType = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\"\n};\nclass Map extends maplibregl__default.Map {\n  constructor(options) {\n    var _a, _b, _c;\n    if (options.apiKey) {\n      config.apiKey = options.apiKey;\n    }\n    const style = styleToStyle(options.style);\n    const hashPreConstructor = location.hash;\n    if (!config.apiKey) {\n      console.warn(\"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\");\n    }\n    super(__spreadProps$1(__spreadValues$2({}, options), {\n      style,\n      maplibreLogo: false,\n      transformRequest: combineTransformRequest(options.transformRequest)\n    }));\n    __publicField$2(this, \"isTerrainEnabled\", false);\n    __publicField$2(this, \"terrainExaggeration\", 1);\n    __publicField$2(this, \"primaryLanguage\");\n    __publicField$2(this, \"terrainGrowing\", false);\n    __publicField$2(this, \"terrainFlattening\", false);\n    __publicField$2(this, \"minimap\");\n    __publicField$2(this, \"forceLanguageUpdate\");\n    __publicField$2(this, \"languageAlwaysBeenStyle\");\n    __publicField$2(this, \"isReady\", false);\n    this.primaryLanguage = (_a = options.language) != null ? _a : config.primaryLanguage;\n    this.forceLanguageUpdate = this.primaryLanguage === Language.STYLE || this.primaryLanguage === Language.STYLE_LOCK ? false : true;\n    this.languageAlwaysBeenStyle = this.primaryLanguage === Language.STYLE;\n    this.terrainExaggeration = (_b = options.terrainExaggeration) != null ? _b : this.terrainExaggeration;\n    this.once(\"styledata\", () => __async$1(this, null, function* () {\n      if (!options.geolocate) {\n        return;\n      }\n      if (options.center) {\n        return;\n      }\n      if (options.hash && !!hashPreConstructor) {\n        return;\n      }\n      try {\n        if (options.geolocate === GeolocationType.COUNTRY) {\n          yield this.fitToIpBounds();\n          return;\n        }\n      } catch (e) {\n        console.warn(e.message);\n      }\n      let ipLocatedCameraHash;\n      try {\n        yield this.centerOnIpPoint(options.zoom);\n        ipLocatedCameraHash = this.getCameraHash();\n      } catch (e) {\n        console.warn(e.message);\n      }\n      const locationResult = yield navigator.permissions.query({\n        name: \"geolocation\"\n      });\n      if (locationResult.state === \"granted\") {\n        navigator.geolocation.getCurrentPosition(\n        // success callback\n        data => {\n          if (ipLocatedCameraHash !== this.getCameraHash()) {\n            return;\n          }\n          if (this.terrain) {\n            this.easeTo({\n              center: [data.coords.longitude, data.coords.latitude],\n              zoom: options.zoom || 12,\n              duration: 2e3\n            });\n          } else {\n            this.once(\"terrain\", () => {\n              this.easeTo({\n                center: [data.coords.longitude, data.coords.latitude],\n                zoom: options.zoom || 12,\n                duration: 2e3\n              });\n            });\n          }\n        },\n        // error callback\n        null,\n        // options\n        {\n          maximumAge: 24 * 3600 * 1e3,\n          // a day in millisec\n          timeout: 5e3,\n          // milliseconds\n          enableHighAccuracy: false\n        });\n      }\n    }));\n    this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    });\n    this.on(\"styledata\", () => {\n      if (this.getTerrain() === null && this.isTerrainEnabled) {\n        this.enableTerrain(this.terrainExaggeration);\n      }\n    });\n    this.once(\"load\", () => __async$1(this, null, function* () {\n      enableRTL();\n    }));\n    this.once(\"load\", () => __async$1(this, null, function* () {\n      let tileJsonContent = {\n        logo: null\n      };\n      try {\n        const possibleSources = Object.keys(this.style.sourceCaches).map(sourceName => this.getSource(sourceName)).filter(s => s && \"url\" in s && typeof s.url === \"string\" && (s == null ? void 0 : s.url.includes(\"tiles.json\")));\n        const styleUrl = new URL(possibleSources[0].url);\n        if (!styleUrl.searchParams.has(\"key\")) {\n          styleUrl.searchParams.append(\"key\", config.apiKey);\n        }\n        const tileJsonRes = yield fetch(styleUrl.href);\n        tileJsonContent = yield tileJsonRes.json();\n      } catch (e) {}\n      if (options.forceNoAttributionControl !== true) {\n        if (\"logo\" in tileJsonContent && tileJsonContent.logo) {\n          const logoURL = tileJsonContent.logo;\n          this.addControl(new MaptilerLogoControl({\n            logoURL\n          }), options.logoPosition);\n          if (options.attributionControl === false) {\n            this.addControl(new AttributionControl({\n              customAttribution: options.customAttribution\n            }));\n          }\n        } else if (options.maptilerLogo) {\n          this.addControl(new MaptilerLogoControl(), options.logoPosition);\n        }\n      }\n      if (options.scaleControl) {\n        const position = options.scaleControl === true || options.scaleControl === void 0 ? \"bottom-right\" : options.scaleControl;\n        const scaleControl = new ScaleControl({\n          unit: config.unit\n        });\n        this.addControl(scaleControl, position);\n        config.on(\"unit\", unit => {\n          scaleControl.setUnit(unit);\n        });\n      }\n      if (options.navigationControl !== false) {\n        const position = options.navigationControl === true || options.navigationControl === void 0 ? \"top-right\" : options.navigationControl;\n        this.addControl(new MaptilerNavigationControl(), position);\n      }\n      if (options.geolocateControl !== false) {\n        const position = options.geolocateControl === true || options.geolocateControl === void 0 ? \"top-right\" : options.geolocateControl;\n        this.addControl(\n        // new maplibregl.GeolocateControl({\n        new MaptilerGeolocateControl({\n          positionOptions: {\n            enableHighAccuracy: true,\n            maximumAge: 0,\n            timeout: 6e3\n          },\n          fitBoundsOptions: {\n            maxZoom: 15\n          },\n          trackUserLocation: true,\n          showAccuracyCircle: true,\n          showUserLocation: true\n        }), position);\n      }\n      if (options.terrainControl) {\n        const position = options.terrainControl === true || options.terrainControl === void 0 ? \"top-right\" : options.terrainControl;\n        this.addControl(new MaptilerTerrainControl(), position);\n      }\n      if (options.fullscreenControl) {\n        const position = options.fullscreenControl === true || options.fullscreenControl === void 0 ? \"top-right\" : options.fullscreenControl;\n        this.addControl(new FullscreenControl({}), position);\n      }\n      this.isReady = true;\n      this.fire(\"ready\", {\n        target: this\n      });\n    }));\n    let loadEventTriggered = false;\n    let terrainEventTriggered = false;\n    let terrainEventData;\n    this.once(\"ready\", () => {\n      loadEventTriggered = true;\n      if (terrainEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    });\n    this.once(\"style.load\", () => {\n      var _a2;\n      const {\n        minimap\n      } = options;\n      if (typeof minimap === \"object\") {\n        const {\n          zoom,\n          center,\n          style: style2,\n          language,\n          apiKey,\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle\n        } = options;\n        this.minimap = new Minimap(minimap, {\n          zoom,\n          center,\n          style: style2,\n          language,\n          apiKey,\n          container: \"null\",\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle\n        });\n        this.addControl(this.minimap, (_a2 = minimap.position) != null ? _a2 : \"bottom-left\");\n      } else if (minimap === true) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, \"bottom-left\");\n      } else if (minimap !== void 0 && minimap !== false) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, minimap);\n      }\n    });\n    const terrainCallback = evt => {\n      if (!evt.terrain) return;\n      terrainEventTriggered = true;\n      terrainEventData = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: evt.terrain\n      };\n      this.off(\"terrain\", terrainCallback);\n      if (loadEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    };\n    this.on(\"terrain\", terrainCallback);\n    if (options.terrain) {\n      this.enableTerrain((_c = options.terrainExaggeration) != null ? _c : this.terrainExaggeration);\n    }\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  onLoadAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise(resolve => {\n        if (this.loaded()) {\n          return resolve(this);\n        }\n        this.once(\"load\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  onReadyAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise(resolve => {\n        if (this.isReady) {\n          return resolve(this);\n        }\n        this.once(\"ready\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  onLoadWithTerrainAsync() {\n    return __async$1(this, null, function* () {\n      return new Promise(resolve => {\n        if (this.isReady && this.terrain) {\n          return resolve(this);\n        }\n        this.once(\"loadWithTerrain\", () => {\n          resolve(this);\n        });\n      });\n    });\n  }\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  setStyle(style, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setStyle(style);\n    this.forceLanguageUpdate = true;\n    this.once(\"idle\", () => {\n      this.forceLanguageUpdate = false;\n    });\n    return super.setStyle(styleToStyle(style), options);\n  }\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(layer, beforeId) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.addLayer(layer, beforeId);\n    return super.addLayer(layer, beforeId);\n  }\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(id, beforeId) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.moveLayer(id, beforeId);\n    return super.moveLayer(id, beforeId);\n  }\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(id) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.removeLayer(id);\n    return super.removeLayer(id);\n  }\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(layerId, minzoom, maxzoom) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setLayerZoomRange(layerId, minzoom, maxzoom);\n    return super.setLayerZoomRange(layerId, minzoom, maxzoom);\n  }\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(layerId, filter, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setFilter(layerId, filter, options);\n    return super.setFilter(layerId, filter, options);\n  }\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(layerId, name, value, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setPaintProperty(layerId, name, value, options);\n    return super.setPaintProperty(layerId, name, value, options);\n  }\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(layerId, name, value, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setLayoutProperty(layerId, name, value, options);\n    return super.setLayoutProperty(layerId, name, value, options);\n  }\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(glyphsUrl, options) {\n    var _a;\n    (_a = this.minimap) == null ? void 0 : _a.setGlyphs(glyphsUrl, options);\n    return super.setGlyphs(glyphsUrl, options);\n  }\n  getStyleLanguage() {\n    if (!this.style.stylesheet.metadata) return null;\n    if (typeof this.style.stylesheet.metadata !== \"object\") return null;\n    if (\"maptiler:language\" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata[\"maptiler:language\"] === \"string\") {\n      return this.style.stylesheet.metadata[\"maptiler:language\"];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(language) {\n    var _a, _b;\n    (_b = (_a = this.minimap) == null ? void 0 : _a.map) == null ? void 0 : _b.setLanguage(language);\n    this.onStyleReady(() => {\n      this.setPrimaryLanguage(language);\n    });\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setPrimaryLanguage(language) {\n    const styleLanguage = this.getStyleLanguage();\n    if (!(language === Language.STYLE && (styleLanguage === Language.AUTO || styleLanguage === Language.VISITOR))) {\n      if (language !== Language.STYLE) {\n        this.languageAlwaysBeenStyle = false;\n      }\n      if (this.languageAlwaysBeenStyle) {\n        return;\n      }\n      if (this.primaryLanguage === language && !this.forceLanguageUpdate) {\n        return;\n      }\n    }\n    if (!isLanguageSupported(language)) {\n      console.warn(`The language \"${language}\" is not supported.`);\n      return;\n    }\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\");\n      return;\n    }\n    this.primaryLanguage = language;\n    let languageNonStyle = language;\n    if (language === Language.STYLE) {\n      if (!styleLanguage) {\n        console.warn(\"The style has no default languages.\");\n        return;\n      }\n      if (!isLanguageSupported(styleLanguage)) {\n        console.warn(\"The language defined in the style is not valid.\");\n        return;\n      }\n      languageNonStyle = styleLanguage;\n    }\n    let langStr = Language.LOCAL;\n    let replacer = `{${langStr}}`;\n    if (languageNonStyle == Language.VISITOR) {\n      langStr = getBrowserLanguage();\n      replacer = [\"case\", [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]], [\"case\", [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]], [\"get\", Language.LOCAL], [\"format\", [\"get\", langStr], {\n        \"font-scale\": 0.8\n      }, \"\\n\", [\"get\", Language.LOCAL], {\n        \"font-scale\": 1.1\n      }]], [\"get\", Language.LOCAL]];\n    } else if (languageNonStyle == Language.VISITOR_ENGLISH) {\n      langStr = Language.ENGLISH;\n      replacer = [\"case\", [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]], [\"case\", [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]], [\"get\", Language.LOCAL], [\"format\", [\"get\", langStr], {\n        \"font-scale\": 0.8\n      }, \"\\n\", [\"get\", Language.LOCAL], {\n        \"font-scale\": 1.1\n      }]], [\"get\", Language.LOCAL]];\n    } else if (languageNonStyle === Language.AUTO) {\n      langStr = getBrowserLanguage();\n      replacer = [\"case\", [\"has\", langStr], [\"get\", langStr], [\"get\", Language.LOCAL]];\n    } else if (languageNonStyle === Language.LOCAL) {\n      langStr = Language.LOCAL;\n      replacer = `{${langStr}}`;\n    } else {\n      langStr = languageNonStyle;\n      replacer = [\"case\", [\"has\", langStr], [\"get\", langStr], [\"get\", Language.LOCAL]];\n    }\n    const {\n      layers\n    } = this.getStyle();\n    for (const {\n      id,\n      layout\n    } of layers) {\n      if (!layout) {\n        continue;\n      }\n      if (!(\"text-field\" in layout)) {\n        continue;\n      }\n      const textFieldLayoutProp = this.getLayoutProperty(id, \"text-field\");\n      if (typeof textFieldLayoutProp === \"string\" && (textFieldLayoutProp.toLowerCase().includes(\"ref\") || textFieldLayoutProp.toLowerCase().includes(\"housenumber\"))) {\n        continue;\n      }\n      this.setLayoutProperty(id, \"text-field\", replacer);\n    }\n  }\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage() {\n    return this.primaryLanguage;\n  }\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration() {\n    return this.terrainExaggeration;\n  }\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain() {\n    return this.isTerrainEnabled;\n  }\n  growTerrain(exaggeration, durationMs = 1e3) {\n    if (!this.terrain) {\n      return;\n    }\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const deltaExaggeration = exaggeration - currentExaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainFlattening) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / durationMs;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = 1 - Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration + exaggerationFactor * deltaExaggeration;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.terrain.exaggeration = exaggeration;\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = true;\n    this.terrainFlattening = false;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(exaggeration = this.terrainExaggeration) {\n    if (exaggeration < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n    const dataEventTerrainGrow = evt => __async$1(this, null, function* () {\n      if (!this.terrain) {\n        return;\n      }\n      if (evt.type !== \"data\" || evt.dataType !== \"source\" || !(\"source\" in evt)) {\n        return;\n      }\n      if (evt.sourceId !== \"maptiler-terrain\") {\n        return;\n      }\n      const source = evt.source;\n      if (source.type !== \"raster-dem\") {\n        return;\n      }\n      if (!evt.isSourceLoaded) {\n        return;\n      }\n      this.off(\"data\", dataEventTerrainGrow);\n      this.growTerrain(exaggeration);\n    });\n    const addTerrain = () => {\n      this.isTerrainEnabled = true;\n      this.terrainExaggeration = exaggeration;\n      this.on(\"data\", dataEventTerrainGrow);\n      this.addSource(defaults.terrainSourceId, {\n        type: \"raster-dem\",\n        url: defaults.terrainSourceURL\n      });\n      this.setTerrain({\n        source: defaults.terrainSourceId,\n        exaggeration: 0\n      });\n    };\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = true;\n      this.growTerrain(exaggeration);\n      return;\n    }\n    if (this.loaded() || this.isTerrainEnabled) {\n      addTerrain();\n    } else {\n      this.once(\"load\", () => {\n        if (this.getTerrain() && this.getSource(defaults.terrainSourceId)) {\n          return;\n        }\n        addTerrain();\n      });\n    }\n  }\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    if (!this.terrain) {\n      return;\n    }\n    this.isTerrainEnabled = false;\n    const animationLoopDuration = 1 * 1e3;\n    const startTime = performance.now();\n    const currentExaggeration = this.terrain.exaggeration;\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n      if (this.terrainGrowing) {\n        return;\n      }\n      const positionInLoop = (performance.now() - startTime) / animationLoopDuration;\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration * exaggerationFactor;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrain.exaggeration = 0;\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.setTerrain();\n        if (this.getSource(defaults.terrainSourceId)) {\n          this.removeSource(defaults.terrainSourceId);\n        }\n      }\n      this.triggerRepaint();\n    };\n    this.terrainGrowing = false;\n    this.terrainFlattening = true;\n    requestAnimationFrame(updateExaggeration);\n  }\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(exaggeration, animate = true) {\n    if (!animate && this.terrain) {\n      this.terrainExaggeration = exaggeration;\n      this.terrain.exaggeration = exaggeration;\n      this.triggerRepaint();\n    } else {\n      this.enableTerrain(exaggeration);\n    }\n  }\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  onStyleReady(cb) {\n    if (this.isStyleLoaded()) {\n      cb();\n    } else {\n      this.once(\"styledata\", () => {\n        cb();\n      });\n    }\n  }\n  fitToIpBounds() {\n    return __async$1(this, null, function* () {\n      const ipGeolocateResult = yield geolocation.info();\n      this.fitBounds(ipGeolocateResult.country_bounds, {\n        duration: 0,\n        padding: 100\n      });\n    });\n  }\n  centerOnIpPoint(zoom) {\n    return __async$1(this, null, function* () {\n      var _a, _b;\n      const ipGeolocateResult = yield geolocation.info();\n      this.jumpTo({\n        center: [(_a = ipGeolocateResult == null ? void 0 : ipGeolocateResult.longitude) != null ? _a : 0, (_b = ipGeolocateResult == null ? void 0 : ipGeolocateResult.latitude) != null ? _b : 0],\n        zoom: zoom || 11\n      });\n    });\n  }\n  getCameraHash() {\n    const hashBin = new Float32Array(5);\n    const center = this.getCenter();\n    hashBin[0] = center.lng;\n    hashBin[1] = center.lat;\n    hashBin[2] = this.getZoom();\n    hashBin[3] = this.getPitch();\n    hashBin[4] = this.getBearing();\n    return Base64.fromUint8Array(new Uint8Array(hashBin.buffer));\n  }\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig() {\n    return config;\n  }\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId() {\n    return MAPTILER_SESSION_ID;\n  }\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(transformRequest) {\n    super.setTransformRequest(combineTransformRequest(transformRequest));\n    return this;\n  }\n  /**\n   * Loads an image. This is an async equivalent of `Map.loadImage`\n   */\n  loadImageAsync(url) {\n    return __async$1(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        this.loadImage(url, (error, image) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(image);\n        });\n      });\n    });\n  }\n}\nclass Marker extends maplibregl__default.Marker {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\nclass Popup extends maplibregl__default.Popup {\n  addTo(map) {\n    return super.addTo(map);\n  }\n}\nclass Style extends maplibregl__default.Style {\n  constructor(map, options = {}) {\n    super(map, options);\n  }\n}\nclass CanvasSource extends maplibregl__default.CanvasSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass GeoJSONSource extends maplibregl__default.GeoJSONSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass ImageSource extends maplibregl__default.ImageSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass RasterTileSource extends maplibregl__default.RasterTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass RasterDEMTileSource extends maplibregl__default.RasterDEMTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass VectorTileSource extends maplibregl__default.VectorTileSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass VideoSource extends maplibregl__default.VideoSource {\n  onAdd(map) {\n    super.onAdd(map);\n  }\n}\nclass TerrainControl extends maplibregl__default.TerrainControl {\n  onAdd(map) {\n    return super.onAdd(map);\n  }\n}\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Point {\n  constructor(x, y) {\n    __publicField$1(this, \"x\");\n    __publicField$1(this, \"y\");\n    this.x = x;\n    this.y = y;\n  }\n  _matMult(m) {\n    const x = m[0] * this.x + m[1] * this.y;\n    const y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _add(p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  _sub(p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  }\n  _mult(k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n  _div(k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  }\n  _multByPoint(p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  }\n  _divByPoint(p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  }\n  _unit() {\n    this._div(this.mag());\n    return this;\n  }\n  _perp() {\n    const y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  }\n  _rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * this.x - sin * this.y;\n    const y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _rotateAround(angle, p) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y);\n    const y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  _round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add(p) {\n    return this.clone()._add(p);\n  }\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub(p) {\n    return this.clone()._sub(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint(p) {\n    return this.clone()._multByPoint(p);\n  }\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint(p) {\n    return this.clone()._divByPoint(p);\n  }\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Number} k factor\n   * @return {Point} output point\n   */\n  mult(k) {\n    return this.clone()._mult(k);\n  }\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div(k) {\n    return this.clone()._div(k);\n  }\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate(a) {\n    return this.clone()._rotate(a);\n  }\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround(a, p) {\n    return this.clone()._rotateAround(a, p);\n  }\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult(m) {\n    return this.clone()._matMult(m);\n  }\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit() {\n    return this.clone()._unit();\n  }\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp() {\n    return this.clone()._perp();\n  }\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round() {\n    return this.clone()._round();\n  }\n  /**\n   * Return the magnitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist(p) {\n    return Math.sqrt(this.distSqr(p));\n  }\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr(p) {\n    const dx = p.x - this.x;\n    const dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  }\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle() {\n    return Math.atan2(this.y, this.x);\n  }\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo(b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  }\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith(b) {\n    return this.angleWithSep(b.x, b.y);\n  }\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin() for .\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep(x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  }\n  /**\n   * Construct a point from an array if necessary, otherwise if the input\n   * is already a Point, or an unknown type, return it unchanged\n   * @param {Array<number> | Point} a any kind of input value\n   * @return {Point} constructed point, or passed-through value.\n   * @example\n   * // this\n   * var point = Point.convert([0, 1]);\n   * // is equivalent to\n   * var point = new Point(0, 1);\n   */\n  static convert(a) {\n    if (a instanceof Point) {\n      return a;\n    }\n    if (Array.isArray(a)) {\n      return new Point(a[0], a[1]);\n    }\n    return a;\n  }\n}\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {\n    if (__propIsEnum$1.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  }\n  return a;\n};\nfunction str2xml(str) {\n  if (typeof DOMParser !== \"undefined\") {\n    const doc = new DOMParser().parseFromString(str, \"application/xml\");\n    if (doc.querySelector(\"parsererror\")) {\n      throw new Error(\"The provided string is not valid XML\");\n    }\n    return doc;\n  } else {\n    throw new Error(\"No XML parser found\");\n  }\n}\nfunction hasChildNodeWithName(doc, nodeName) {\n  if (!doc.hasChildNodes()) {\n    return false;\n  }\n  for (const childNode of Array.from(doc.childNodes)) {\n    const currentNodeName = childNode.nodeName;\n    if (typeof currentNodeName === \"string\" && currentNodeName.trim().toLowerCase() === nodeName.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction xml2str(node) {\n  if (typeof XMLSerializer !== \"undefined\") {\n    return new XMLSerializer().serializeToString(node);\n  }\n  throw new Error(\"No XML serializer found\");\n}\nfunction gpx(doc) {\n  if (typeof doc === \"string\") doc = str2xml(doc);\n  if (!hasChildNodeWithName(doc, \"gpx\")) {\n    throw new Error(\"The XML document is not valid GPX\");\n  }\n  const tracks = get(doc, \"trk\");\n  const routes = get(doc, \"rte\");\n  const waypoints = get(doc, \"wpt\");\n  const gj = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  for (const track of Array.from(tracks)) {\n    const feature = getTrack(track);\n    if (feature) gj.features.push(feature);\n  }\n  for (const route of Array.from(routes)) {\n    const feature = getRoute(route);\n    if (feature) gj.features.push(feature);\n  }\n  for (const waypoint of Array.from(waypoints)) {\n    gj.features.push(getPoint(waypoint));\n  }\n  return gj;\n}\nfunction kml(doc, xml2string) {\n  var _a;\n  if (typeof doc === \"string\") doc = str2xml(doc);\n  if (!hasChildNodeWithName(doc, \"kml\")) {\n    throw new Error(\"The XML document is not valid KML\");\n  }\n  const gj = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  const styleIndex = {};\n  const styleByHash = {};\n  const styleMapIndex = {};\n  const placemarks = get(doc, \"Placemark\");\n  const styles = get(doc, \"Style\");\n  const styleMaps = get(doc, \"StyleMap\");\n  for (const style of Array.from(styles)) {\n    const hash = okhash(xml2string !== void 0 ? xml2string(style) : xml2str(style)).toString(16);\n    styleIndex[\"#\" + attr(style, \"id\")] = hash;\n    styleByHash[hash] = style;\n  }\n  for (const styleMap of Array.from(styleMaps)) {\n    styleIndex[\"#\" + attr(styleMap, \"id\")] = okhash(xml2string !== void 0 ? xml2string(styleMap) : xml2str(styleMap)).toString(16);\n    const pairs = get(styleMap, \"Pair\");\n    const pairsMap = {};\n    for (const pair of Array.from(pairs)) {\n      pairsMap[(_a = nodeVal(get1(pair, \"key\"))) != null ? _a : \"\"] = nodeVal(get1(pair, \"styleUrl\"));\n    }\n    styleMapIndex[\"#\" + attr(styleMap, \"id\")] = pairsMap;\n  }\n  for (const placemark of Array.from(placemarks)) {\n    gj.features = gj.features.concat(getPlacemark(placemark, styleIndex, styleByHash, styleMapIndex));\n  }\n  return gj;\n}\nfunction kmlColor(v) {\n  if (v === null) return [\"#000000\", 1];\n  let color = \"\";\n  let opacity = 1;\n  if (v.substring(0, 1) === \"#\") v = v.substring(1);\n  if (v.length === 6 || v.length === 3) color = v;\n  if (v.length === 8) {\n    opacity = parseInt(v.substring(0, 2), 16) / 255;\n    color = \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return [color != null ? color : \"#000000\", opacity != null ? opacity : 1];\n}\nfunction gxCoord(v) {\n  return numarray(v.split(\" \"));\n}\nfunction gxCoords(root) {\n  var _a;\n  let elems = get(root, \"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0) elems = get(root, \"gx:coord\");\n  for (const elem of Array.from(elems)) {\n    coords.push(gxCoord((_a = nodeVal(elem)) != null ? _a : \"\"));\n  }\n  const timeElems = get(root, \"when\");\n  for (const timeElem of Array.from(timeElems)) times.push(nodeVal(timeElem));\n  return {\n    coords,\n    times\n  };\n}\nfunction getGeometry(root) {\n  var _a, _b, _c;\n  const geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  let geomNode, geomNodes, i, j, k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\") !== null) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = get(root, geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1((_a = nodeVal(get1(geomNode, \"coordinates\"))) != null ? _a : \"\")\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord((_b = nodeVal(get1(geomNode, \"coordinates\"))) != null ? _b : \"\")\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = get(geomNode, \"LinearRing\");\n          const coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord((_c = nodeVal(get1(rings[k], \"coordinates\"))) != null ? _c : \"\"));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return {\n    geoms,\n    coordTimes\n  };\n}\nfunction getPlacemark(root, styleIndex, styleByHash, styleMapIndex) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  const geomsAndTimes = getGeometry(root);\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  const visibility = get1(root, \"visibility\");\n  let i;\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  if (!geomsAndTimes.geoms.length) return [];\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") styleUrl = \"#\" + styleUrl;\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[(_a = styleMapIndex[styleUrl].normal) != null ? _a : \"\"];\n    }\n    const style = styleByHash[(_b = properties.styleHash) != null ? _b : \"\"];\n    if (style) {\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n      const iconStyle = get1(style, \"IconStyle\");\n      if (iconStyle) {\n        const icon = get1(iconStyle, \"Icon\");\n        if (icon) {\n          const href = nodeVal(get1(icon, \"href\"));\n          if (href) properties.icon = href;\n        }\n      }\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    if (begin && end) properties.timespan = {\n      begin,\n      end\n    };\n  }\n  if (timeStamp !== null) {\n    properties.timestamp = (_c = nodeVal(get1(timeStamp, \"when\"))) != null ? _c : ( /* @__PURE__ */new Date()).toISOString();\n  }\n  if (lineStyle !== null) {\n    const linestyles = kmlColor(nodeVal(get1(lineStyle, \"color\")));\n    const color = linestyles[0];\n    const opacity = linestyles[1];\n    const width = parseFloat((_d = nodeVal(get1(lineStyle, \"width\"))) != null ? _d : \"\");\n    if (color) properties.stroke = color;\n    if (!isNaN(opacity)) properties[\"stroke-opacity\"] = opacity;\n    if (!isNaN(width)) properties[\"stroke-width\"] = width;\n  }\n  if (polyStyle) {\n    const polystyles = kmlColor(nodeVal(get1(polyStyle, \"color\")));\n    const pcolor = polystyles[0];\n    const popacity = polystyles[1];\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (pcolor) properties.fill = pcolor;\n    if (!isNaN(popacity)) properties[\"fill-opacity\"] = popacity;\n    if (fill) properties[\"fill-opacity\"] = fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline) properties[\"stroke-opacity\"] = outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = get(extendedData, \"Data\"),\n      simpleDatas = get(extendedData, \"SimpleData\");\n    for (i = 0; i < datas.length; i++) {\n      properties[(_e = datas[i].getAttribute(\"name\")) != null ? _e : \"\"] = (_f = nodeVal(get1(datas[i], \"value\"))) != null ? _f : \"\";\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[(_g = simpleDatas[i].getAttribute(\"name\")) != null ? _g : \"\"] = (_h = nodeVal(simpleDatas[i])) != null ? _h : \"\";\n    }\n  }\n  if (visibility !== null) {\n    properties.visibility = (_i = nodeVal(visibility)) != null ? _i : \"\";\n  }\n  if (geomsAndTimes.coordTimes.length !== 0) {\n    properties.coordTimes = geomsAndTimes.coordTimes.length === 1 ? geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry: geomsAndTimes.geoms.length === 1 ? geomsAndTimes.geoms[0] : {\n      type: \"GeometryCollection\",\n      geometries: geomsAndTimes.geoms\n    },\n    properties\n  };\n  if (attr(root, \"id\")) feature.id = (_j = attr(root, \"id\")) != null ? _j : void 0;\n  return [feature];\n}\nfunction getPoints(node, pointname) {\n  const pts = get(node, pointname);\n  const line = [];\n  const times = [];\n  let heartRates = [];\n  const ptsLength = pts.length;\n  if (ptsLength < 2) return;\n  for (let i = 0; i < ptsLength; i++) {\n    const cPair = coordPair(pts[i]);\n    line.push(cPair.coordinates);\n    if (cPair.time) times.push(cPair.time);\n    if (cPair.heartRate || heartRates.length) {\n      if (heartRates.length === 0) heartRates = new Array(i).fill(null);\n      heartRates.push(cPair.heartRate);\n    }\n  }\n  return {\n    line,\n    times,\n    heartRates\n  };\n}\nfunction getTrack(node) {\n  const segments = get(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  let line;\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"trkpt\");\n    if (line !== void 0) {\n      if (line.line) track.push(line.line);\n      if (line.times && line.times.length) times.push(line.times);\n      if (heartRates.length || line.heartRates && line.heartRates.length) {\n        if (!heartRates.length) {\n          for (let s = 0; s < i; s++) {\n            heartRates.push(new Array(track[s].length).fill(null));\n          }\n        }\n        if (line.heartRates && line.heartRates.length) {\n          heartRates.push(line.heartRates);\n        } else {\n          heartRates.push(new Array(line.line.length).fill(null));\n        }\n      }\n    }\n  }\n  if (track.length === 0) return;\n  const properties = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getLineStyle(get1(node, \"extensions\")));\n  if (times.length !== 0) properties.coordTimes = track.length === 1 ? times[0] : times;\n  if (heartRates.length !== 0) {\n    properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n  }\n  if (track.length === 1) {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"LineString\",\n        coordinates: track[0]\n      }\n    };\n  } else {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"MultiLineString\",\n        coordinates: track\n      }\n    };\n  }\n}\nfunction getRoute(node) {\n  const line = getPoints(node, \"rtept\");\n  if (line === void 0) return;\n  const prop = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getLineStyle(get1(node, \"extensions\")));\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line\n    }\n  };\n}\nfunction getPoint(node) {\n  const prop = __spreadValues$1(__spreadValues$1({}, getProperties(node)), getMulti(node, [\"sym\"]));\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates\n    }\n  };\n}\nfunction getLineStyle(extensions) {\n  var _a, _b;\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\"));\n      const opacity = parseFloat((_a = nodeVal(get1(lineStyle, \"opacity\"))) != null ? _a : \"0\");\n      const width = parseFloat((_b = nodeVal(get1(lineStyle, \"width\"))) != null ? _b : \"0\");\n      if (color) style.stroke = color;\n      if (!isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      if (!isNaN(width)) style[\"stroke-width\"] = width * 96 / 25.4;\n    }\n  }\n  return style;\n}\nfunction getProperties(node) {\n  const prop = getMulti(node, [\"name\", \"cmt\", \"desc\", \"type\", \"time\", \"keywords\"]);\n  const links = get(node, \"link\");\n  if (links.length !== 0) {\n    prop.links = [];\n    for (const l of Array.from(links)) {\n      const link = __spreadValues$1({\n        href: attr(l, \"href\")\n      }, getMulti(l, [\"text\", \"type\"]));\n      prop.links.push(link);\n    }\n  }\n  return prop;\n}\nfunction okhash(x) {\n  let h = 0;\n  if (!x || !x.length) return h;\n  for (let i = 0; i < x.length; i++) {\n    h = (h << 5) - h + x.charCodeAt(i) | 0;\n  }\n  return h;\n}\nfunction get(x, y) {\n  return x.getElementsByTagName(y);\n}\nfunction attr(x, y) {\n  return x.getAttribute(y);\n}\nfunction attrf(x, y) {\n  var _a;\n  return parseFloat((_a = attr(x, y)) != null ? _a : \"0\");\n}\nfunction get1(x, y) {\n  const n = get(x, y);\n  return n.length ? n[0] : null;\n}\nfunction norm(el) {\n  if (el.normalize) el.normalize();\n  return el;\n}\nfunction numarray(x) {\n  return x.map(parseFloat).map(n => isNaN(n) ? null : n);\n}\nfunction nodeVal(x) {\n  if (x) norm(x);\n  return x && x.textContent;\n}\nfunction getMulti(x, ys) {\n  var _a;\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = (_a = nodeVal(n)) != null ? _a : \"\";\n  }\n  return o;\n}\nfunction coord1(v) {\n  return numarray(v.replace(/\\s*/g, \"\").split(\",\"));\n}\nfunction coord(v) {\n  const coords = v.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/);\n  const out = [];\n  for (const coord2 of coords) out.push(coord1(coord2));\n  return out;\n}\nfunction coordPair(x) {\n  var _a, _b;\n  const ll = [attrf(x, \"lon\"), attrf(x, \"lat\")];\n  const ele = get1(x, \"ele\");\n  const heartRate = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e;\n  if (ele) {\n    e = parseFloat((_a = nodeVal(ele)) != null ? _a : \"0\");\n    if (!isNaN(e)) ll.push(e);\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate !== null ? parseFloat((_b = nodeVal(heartRate)) != null ? _b : \"0\") : null\n  };\n}\nfunction gpxOrKml(doc) {\n  try {\n    if (typeof doc === \"string\") doc = str2xml(doc);\n  } catch (e) {\n    return null;\n  }\n  try {\n    const result = gpx(doc);\n    return result;\n  } catch (e) {}\n  try {\n    const result = kml(doc);\n    return result;\n  } catch (e) {}\n  return null;\n}\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction componentToHex(c) {\n  const hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\nfunction rgbToHex(rgb) {\n  return \"#\" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]) + (rgb.length === 4 ? componentToHex(rgb[3]) : \"\");\n}\nclass ColorRamp extends Array {\n  constructor(options = {}) {\n    super();\n    __publicField(this, \"min\", 0);\n    __publicField(this, \"max\", 1);\n    if (\"min\" in options) {\n      this.min = options.min;\n    }\n    if (\"max\" in options) {\n      this.max = options.max;\n    }\n    if (\"stops\" in options) {\n      this.setStops(options.stops, {\n        clone: false\n      });\n    }\n  }\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(cr) {\n    return new ColorRamp({\n      stops: cr.map(cs => ({\n        value: cs[0],\n        color: cs[1]\n      }))\n    });\n  }\n  setStops(stops, options = {\n    clone: true\n  }) {\n    const colorRamp = options.clone ? this.clone() : this;\n    colorRamp.length = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < stops.length; i += 1) {\n      min = Math.min(min, stops[i].value);\n      max = Math.max(max, stops[i].value);\n      colorRamp.push({\n        value: stops[i].value,\n        color: stops[i].color.slice()\n        // we want to make sure we do a deep copy and not a reference\n      });\n    }\n    colorRamp.sort((a, b) => a.value < b.value ? -1 : 1);\n    this.min = min;\n    this.max = max;\n    return colorRamp;\n  }\n  scale(min, max, options = {\n    clone: true\n  }) {\n    const clone = options.clone;\n    const currentMin = this[0].value;\n    const currentMax = this.at(-1).value;\n    const currentSpan = currentMax - currentMin;\n    const newSpan = max - min;\n    const stops = [];\n    for (let i = 0; i < this.length; i += 1) {\n      const currentValue = this[i].value;\n      const normalizedValue = (currentValue - currentMin) / currentSpan;\n      const newValue = normalizedValue * newSpan + min;\n      if (clone) {\n        stops.push({\n          value: newValue,\n          color: this[i].color.slice()\n        });\n      } else {\n        this[i].value = newValue;\n      }\n    }\n    return clone ? new ColorRamp({\n      stops\n    }) : this;\n  }\n  // for some reason, I had to reimplement this\n  at(pos) {\n    if (pos < 0) {\n      return this[this.length + pos];\n    } else {\n      return this[pos];\n    }\n  }\n  clone() {\n    return new ColorRamp({\n      stops: this.getRawColorStops()\n    });\n  }\n  getRawColorStops() {\n    const stops = [];\n    for (let i = 0; i < this.length; i += 1) {\n      stops.push({\n        value: this[i].value,\n        color: this[i].color\n      });\n    }\n    return stops;\n  }\n  reverse(options = {\n    clone: true\n  }) {\n    const colorRamp = options.clone ? this.clone() : this;\n    for (let i = 0; i < ~~(colorRamp.length / 2); i += 1) {\n      const c = colorRamp[i].color;\n      colorRamp[i].color = colorRamp.at(-(i + 1)).color;\n      colorRamp.at(-(i + 1)).color = c;\n    }\n    return colorRamp;\n  }\n  getBounds() {\n    return {\n      min: this.min,\n      max: this.max\n    };\n  }\n  getColor(value, options = {\n    smooth: true\n  }) {\n    if (value <= this[0].value) {\n      return this[0].color;\n    }\n    if (value >= this.at(-1).value) {\n      return this.at(-1).color;\n    }\n    for (let i = 0; i < this.length - 1; i += 1) {\n      if (value > this[i + 1].value) {\n        continue;\n      }\n      const colorBefore = this[i].color;\n      if (!options.smooth) {\n        return colorBefore.slice();\n      }\n      const valueBefore = this[i].value;\n      const valueAfter = this[i + 1].value;\n      const colorAfter = this[i + 1].color;\n      const beforeRatio = (valueAfter - value) / (valueAfter - valueBefore);\n      return colorBefore.map((chan, i2) => Math.round(chan * beforeRatio + colorAfter[i2] * (1 - beforeRatio)));\n    }\n    return [0, 0, 0];\n  }\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(value, options = {\n    smooth: true,\n    withAlpha: false\n  }) {\n    return rgbToHex(this.getColor(value, options));\n  }\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(value, options = {\n    smooth: true\n  }) {\n    const bounds = this.getBounds();\n    return this.getColor(bounds.min + value * (bounds.max - bounds.min), options);\n  }\n  getCanvasStrip(options = {\n    horizontal: true,\n    size: 512,\n    smooth: true\n  }) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = options.horizontal ? options.size : 1;\n    canvas.height = options.horizontal ? 1 : options.size;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) throw new Error(\"Canvs context is missing\");\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const imageDataArray = imageData.data;\n    const size = options.size;\n    const startValue = this[0].value;\n    const endValue = this.at(-1).value;\n    const valueSpan = endValue - startValue;\n    const valueStep = valueSpan / size;\n    for (let i = 0; i < size; i += 1) {\n      const color = this.getColor(startValue + i * valueStep, {\n        smooth: options.smooth\n      });\n      imageDataArray[i * 4] = color[0];\n      imageDataArray[i * 4 + 1] = color[1];\n      imageDataArray[i * 4 + 2] = color[2];\n      imageDataArray[i * 4 + 3] = color.length > 3 ? color[3] : 255;\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(method, samples = 15) {\n    const inputBounds = this.getBounds();\n    const inputNormalized = this.scale(0, 1);\n    const step = 1 / (samples - 1);\n    let stops;\n    if (method === \"ease-in-square\") {\n      stops = Array.from({\n        length: samples\n      }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 2);\n        const color = inputNormalized.getColor(y);\n        return {\n          value: x,\n          color\n        };\n      });\n    } else if (method === \"ease-out-square\") {\n      stops = Array.from({\n        length: samples\n      }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 2);\n        const color = inputNormalized.getColor(y);\n        return {\n          value: x,\n          color\n        };\n      });\n    } else if (method === \"ease-out-sqrt\") {\n      stops = Array.from({\n        length: samples\n      }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return {\n          value: x,\n          color\n        };\n      });\n    } else if (method === \"ease-in-sqrt\") {\n      stops = Array.from({\n        length: samples\n      }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return {\n          value: x,\n          color\n        };\n      });\n    } else if (method === \"ease-out-exp\") {\n      stops = Array.from({\n        length: samples\n      }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(2, -10 * x);\n        const color = inputNormalized.getColor(y);\n        return {\n          value: x,\n          color\n        };\n      });\n    } else if (method === \"ease-in-exp\") {\n      stops = Array.from({\n        length: samples\n      }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(2, 10 * x - 10);\n        const color = inputNormalized.getColor(y);\n        return {\n          value: x,\n          color\n        };\n      });\n    } else {\n      throw new Error(\"Invalid ressampling method.\");\n    }\n    const outputNormalized = new ColorRamp({\n      stops\n    });\n    const output = outputNormalized.scale(inputBounds.min, inputBounds.max);\n    return output;\n  }\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart() {\n    const stops = this.getRawColorStops();\n    stops.unshift({\n      value: stops[0].value,\n      color: stops[0].color.slice()\n    });\n    stops[1].value += 1e-3;\n    stops.forEach(s => {\n      if (s.color.length === 3) {\n        s.color.push(255);\n      }\n    });\n    stops[0].color[3] = 0;\n    return new ColorRamp({\n      stops\n    });\n  }\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart() {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\nconst ColorRampCollection = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0, 0]\n    }, {\n      value: 1,\n      color: [0, 0, 0, 0]\n    }]\n  }),\n  GRAY: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 131]\n    }, {\n      value: 0.125,\n      color: [0, 60, 170]\n    }, {\n      value: 0.375,\n      color: [5, 255, 255]\n    }, {\n      value: 0.625,\n      color: [255, 255, 0]\n    }, {\n      value: 0.875,\n      color: [250, 0, 0]\n    }, {\n      value: 1,\n      color: [128, 0, 0]\n    }]\n  }),\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [255, 0, 0]\n    }, {\n      value: 0.169,\n      color: [253, 255, 2]\n    }, {\n      value: 0.173,\n      color: [247, 255, 2]\n    }, {\n      value: 0.337,\n      color: [0, 252, 4]\n    }, {\n      value: 0.341,\n      color: [0, 252, 10]\n    }, {\n      value: 0.506,\n      color: [1, 249, 255]\n    }, {\n      value: 0.671,\n      color: [2, 0, 253]\n    }, {\n      value: 0.675,\n      color: [8, 0, 253]\n    }, {\n      value: 0.839,\n      color: [255, 0, 251]\n    }, {\n      value: 0.843,\n      color: [255, 0, 245]\n    }, {\n      value: 1,\n      color: [255, 0, 6]\n    }]\n  }),\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.3,\n      color: [230, 0, 0]\n    }, {\n      value: 0.6,\n      color: [255, 210, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [255, 0, 255]\n    }, {\n      value: 1,\n      color: [255, 255, 0]\n    }]\n  }),\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 128, 102]\n    }, {\n      value: 1,\n      color: [255, 255, 102]\n    }]\n  }),\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [255, 0, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 0]\n    }]\n  }),\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 255]\n    }, {\n      value: 1,\n      color: [0, 255, 128]\n    }]\n  }),\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.376,\n      color: [84, 84, 116]\n    }, {\n      value: 0.753,\n      color: [169, 200, 200]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.804,\n      color: [255, 160, 102]\n    }, {\n      value: 1,\n      color: [255, 199, 127]\n    }]\n  }),\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [8, 29, 88]\n    }, {\n      value: 0.125,\n      color: [37, 52, 148]\n    }, {\n      value: 0.25,\n      color: [34, 94, 168]\n    }, {\n      value: 0.375,\n      color: [29, 145, 192]\n    }, {\n      value: 0.5,\n      color: [65, 182, 196]\n    }, {\n      value: 0.625,\n      color: [127, 205, 187]\n    }, {\n      value: 0.75,\n      color: [199, 233, 180]\n    }, {\n      value: 0.875,\n      color: [237, 248, 217]\n    }, {\n      value: 1,\n      color: [255, 255, 217]\n    }]\n  }),\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 68, 27]\n    }, {\n      value: 0.125,\n      color: [0, 109, 44]\n    }, {\n      value: 0.25,\n      color: [35, 139, 69]\n    }, {\n      value: 0.375,\n      color: [65, 171, 93]\n    }, {\n      value: 0.5,\n      color: [116, 196, 118]\n    }, {\n      value: 0.625,\n      color: [161, 217, 155]\n    }, {\n      value: 0.75,\n      color: [199, 233, 192]\n    }, {\n      value: 0.875,\n      color: [229, 245, 224]\n    }, {\n      value: 1,\n      color: [247, 252, 245]\n    }]\n  }),\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [128, 0, 38]\n    }, {\n      value: 0.125,\n      color: [189, 0, 38]\n    }, {\n      value: 0.25,\n      color: [227, 26, 28]\n    }, {\n      value: 0.375,\n      color: [252, 78, 42]\n    }, {\n      value: 0.5,\n      color: [253, 141, 60]\n    }, {\n      value: 0.625,\n      color: [254, 178, 76]\n    }, {\n      value: 0.75,\n      color: [254, 217, 118]\n    }, {\n      value: 0.875,\n      color: [255, 237, 160]\n    }, {\n      value: 1,\n      color: [255, 255, 204]\n    }]\n  }),\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 255]\n    }, {\n      value: 1,\n      color: [255, 0, 0]\n    }]\n  }),\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [5, 10, 172]\n    }, {\n      value: 0.35,\n      color: [106, 137, 247]\n    }, {\n      value: 0.5,\n      color: [190, 190, 190]\n    }, {\n      value: 0.6,\n      color: [220, 170, 132]\n    }, {\n      value: 0.7,\n      color: [230, 145, 90]\n    }, {\n      value: 1,\n      color: [178, 10, 28]\n    }]\n  }),\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 255]\n    }, {\n      value: 0.1,\n      color: [51, 153, 255]\n    }, {\n      value: 0.2,\n      color: [102, 204, 255]\n    }, {\n      value: 0.3,\n      color: [153, 204, 255]\n    }, {\n      value: 0.4,\n      color: [204, 204, 255]\n    }, {\n      value: 0.5,\n      color: [255, 255, 255]\n    }, {\n      value: 0.6,\n      color: [255, 204, 255]\n    }, {\n      value: 0.7,\n      color: [255, 153, 255]\n    }, {\n      value: 0.8,\n      color: [255, 102, 204]\n    }, {\n      value: 0.9,\n      color: [255, 102, 102]\n    }, {\n      value: 1,\n      color: [255, 0, 0]\n    }]\n  }),\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [150, 0, 90]\n    }, {\n      value: 0.125,\n      color: [0, 0, 200]\n    }, {\n      value: 0.25,\n      color: [0, 25, 255]\n    }, {\n      value: 0.375,\n      color: [0, 152, 255]\n    }, {\n      value: 0.5,\n      color: [44, 255, 150]\n    }, {\n      value: 0.625,\n      color: [151, 255, 0]\n    }, {\n      value: 0.75,\n      color: [255, 234, 0]\n    }, {\n      value: 0.875,\n      color: [255, 111, 0]\n    }, {\n      value: 1,\n      color: [255, 0, 0]\n    }]\n  }),\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [12, 51, 131]\n    }, {\n      value: 0.25,\n      color: [10, 136, 186]\n    }, {\n      value: 0.5,\n      color: [242, 211, 56]\n    }, {\n      value: 0.75,\n      color: [242, 143, 56]\n    }, {\n      value: 1,\n      color: [217, 30, 30]\n    }]\n  }),\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.2,\n      color: [230, 0, 0]\n    }, {\n      value: 0.4,\n      color: [230, 210, 0]\n    }, {\n      value: 0.7,\n      color: [255, 255, 255]\n    }, {\n      value: 1,\n      color: [160, 200, 255]\n    }]\n  }),\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 130]\n    }, {\n      value: 0.1,\n      color: [0, 180, 180]\n    }, {\n      value: 0.2,\n      color: [40, 210, 40]\n    }, {\n      value: 0.4,\n      color: [230, 230, 50]\n    }, {\n      value: 0.6,\n      color: [120, 70, 20]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.15,\n      color: [30, 0, 100]\n    }, {\n      value: 0.4,\n      color: [120, 0, 100]\n    }, {\n      value: 0.6,\n      color: [160, 90, 0]\n    }, {\n      value: 0.8,\n      color: [230, 200, 0]\n    }, {\n      value: 1,\n      color: [255, 250, 220]\n    }]\n  }),\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [68, 1, 84]\n    }, {\n      value: 0.13,\n      color: [71, 44, 122]\n    }, {\n      value: 0.25,\n      color: [59, 81, 139]\n    }, {\n      value: 0.38,\n      color: [44, 113, 142]\n    }, {\n      value: 0.5,\n      color: [33, 144, 141]\n    }, {\n      value: 0.63,\n      color: [39, 173, 129]\n    }, {\n      value: 0.75,\n      color: [92, 200, 99]\n    }, {\n      value: 0.88,\n      color: [170, 220, 50]\n    }, {\n      value: 1,\n      color: [253, 231, 37]\n    }]\n  }),\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 4]\n    }, {\n      value: 0.13,\n      color: [31, 12, 72]\n    }, {\n      value: 0.25,\n      color: [85, 15, 109]\n    }, {\n      value: 0.38,\n      color: [136, 34, 106]\n    }, {\n      value: 0.5,\n      color: [186, 54, 85]\n    }, {\n      value: 0.63,\n      color: [227, 89, 51]\n    }, {\n      value: 0.75,\n      color: [249, 140, 10]\n    }, {\n      value: 0.88,\n      color: [249, 201, 50]\n    }, {\n      value: 1,\n      color: [252, 255, 164]\n    }]\n  }),\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 4]\n    }, {\n      value: 0.13,\n      color: [28, 16, 68]\n    }, {\n      value: 0.25,\n      color: [79, 18, 123]\n    }, {\n      value: 0.38,\n      color: [129, 37, 129]\n    }, {\n      value: 0.5,\n      color: [181, 54, 122]\n    }, {\n      value: 0.63,\n      color: [229, 80, 100]\n    }, {\n      value: 0.75,\n      color: [251, 135, 97]\n    }, {\n      value: 0.88,\n      color: [254, 194, 135]\n    }, {\n      value: 1,\n      color: [252, 253, 191]\n    }]\n  }),\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [13, 8, 135]\n    }, {\n      value: 0.13,\n      color: [75, 3, 161]\n    }, {\n      value: 0.25,\n      color: [125, 3, 168]\n    }, {\n      value: 0.38,\n      color: [168, 34, 150]\n    }, {\n      value: 0.5,\n      color: [203, 70, 121]\n    }, {\n      value: 0.63,\n      color: [229, 107, 93]\n    }, {\n      value: 0.75,\n      color: [248, 148, 65]\n    }, {\n      value: 0.88,\n      color: [253, 195, 40]\n    }, {\n      value: 1,\n      color: [240, 249, 33]\n    }]\n  }),\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [125, 0, 179]\n    }, {\n      value: 0.13,\n      color: [172, 0, 187]\n    }, {\n      value: 0.25,\n      color: [219, 0, 170]\n    }, {\n      value: 0.38,\n      color: [255, 0, 130]\n    }, {\n      value: 0.5,\n      color: [255, 63, 74]\n    }, {\n      value: 0.63,\n      color: [255, 123, 0]\n    }, {\n      value: 0.75,\n      color: [234, 176, 0]\n    }, {\n      value: 0.88,\n      color: [190, 228, 0]\n    }, {\n      value: 1,\n      color: [147, 255, 0]\n    }]\n  }),\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [125, 0, 179]\n    }, {\n      value: 0.13,\n      color: [116, 0, 218]\n    }, {\n      value: 0.25,\n      color: [98, 74, 237]\n    }, {\n      value: 0.38,\n      color: [68, 146, 231]\n    }, {\n      value: 0.5,\n      color: [0, 204, 197]\n    }, {\n      value: 0.63,\n      color: [0, 247, 146]\n    }, {\n      value: 0.75,\n      color: [0, 255, 88]\n    }, {\n      value: 0.88,\n      color: [40, 255, 8]\n    }, {\n      value: 1,\n      color: [147, 255, 0]\n    }]\n  }),\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [125, 0, 179]\n    }, {\n      value: 0.1,\n      color: [199, 0, 180]\n    }, {\n      value: 0.2,\n      color: [255, 0, 121]\n    }, {\n      value: 0.3,\n      color: [255, 108, 0]\n    }, {\n      value: 0.4,\n      color: [222, 194, 0]\n    }, {\n      value: 0.5,\n      color: [150, 255, 0]\n    }, {\n      value: 0.6,\n      color: [0, 255, 55]\n    }, {\n      value: 0.7,\n      color: [0, 246, 150]\n    }, {\n      value: 0.8,\n      color: [50, 167, 222]\n    }, {\n      value: 0.9,\n      color: [103, 51, 235]\n    }, {\n      value: 1,\n      color: [124, 0, 186]\n    }]\n  }),\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [40, 26, 44]\n    }, {\n      value: 0.13,\n      color: [59, 49, 90]\n    }, {\n      value: 0.25,\n      color: [64, 76, 139]\n    }, {\n      value: 0.38,\n      color: [63, 110, 151]\n    }, {\n      value: 0.5,\n      color: [72, 142, 158]\n    }, {\n      value: 0.63,\n      color: [85, 174, 163]\n    }, {\n      value: 0.75,\n      color: [120, 206, 163]\n    }, {\n      value: 0.88,\n      color: [187, 230, 172]\n    }, {\n      value: 1,\n      color: [253, 254, 204]\n    }]\n  }),\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [47, 15, 62]\n    }, {\n      value: 0.13,\n      color: [87, 23, 86]\n    }, {\n      value: 0.25,\n      color: [130, 28, 99]\n    }, {\n      value: 0.38,\n      color: [171, 41, 96]\n    }, {\n      value: 0.5,\n      color: [206, 67, 86]\n    }, {\n      value: 0.63,\n      color: [230, 106, 84]\n    }, {\n      value: 0.75,\n      color: [242, 149, 103]\n    }, {\n      value: 0.88,\n      color: [249, 193, 135]\n    }, {\n      value: 1,\n      color: [254, 237, 176]\n    }]\n  }),\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [18, 36, 20]\n    }, {\n      value: 0.13,\n      color: [25, 63, 41]\n    }, {\n      value: 0.25,\n      color: [24, 91, 59]\n    }, {\n      value: 0.38,\n      color: [13, 119, 72]\n    }, {\n      value: 0.5,\n      color: [18, 148, 80]\n    }, {\n      value: 0.63,\n      color: [80, 173, 89]\n    }, {\n      value: 0.75,\n      color: [132, 196, 122]\n    }, {\n      value: 0.88,\n      color: [175, 221, 162]\n    }, {\n      value: 1,\n      color: [215, 249, 208]\n    }]\n  }),\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [54, 14, 36]\n    }, {\n      value: 0.13,\n      color: [89, 23, 80]\n    }, {\n      value: 0.25,\n      color: [110, 45, 132]\n    }, {\n      value: 0.38,\n      color: [120, 77, 178]\n    }, {\n      value: 0.5,\n      color: [120, 113, 213]\n    }, {\n      value: 0.63,\n      color: [115, 151, 228]\n    }, {\n      value: 0.75,\n      color: [134, 185, 227]\n    }, {\n      value: 0.88,\n      color: [177, 214, 227]\n    }, {\n      value: 1,\n      color: [230, 241, 241]\n    }]\n  }),\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [30, 4, 110]\n    }, {\n      value: 0.13,\n      color: [47, 14, 176]\n    }, {\n      value: 0.25,\n      color: [41, 45, 236]\n    }, {\n      value: 0.38,\n      color: [25, 99, 212]\n    }, {\n      value: 0.5,\n      color: [68, 131, 200]\n    }, {\n      value: 0.63,\n      color: [114, 156, 197]\n    }, {\n      value: 0.75,\n      color: [157, 181, 203]\n    }, {\n      value: 0.88,\n      color: [200, 208, 216]\n    }, {\n      value: 1,\n      color: [241, 237, 236]\n    }]\n  }),\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [60, 9, 18]\n    }, {\n      value: 0.13,\n      color: [100, 17, 27]\n    }, {\n      value: 0.25,\n      color: [142, 20, 29]\n    }, {\n      value: 0.38,\n      color: [177, 43, 27]\n    }, {\n      value: 0.5,\n      color: [192, 87, 63]\n    }, {\n      value: 0.63,\n      color: [205, 125, 105]\n    }, {\n      value: 0.75,\n      color: [216, 162, 148]\n    }, {\n      value: 0.88,\n      color: [227, 199, 193]\n    }, {\n      value: 1,\n      color: [241, 237, 236]\n    }]\n  }),\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [64, 5, 5]\n    }, {\n      value: 0.13,\n      color: [106, 6, 15]\n    }, {\n      value: 0.25,\n      color: [144, 26, 7]\n    }, {\n      value: 0.38,\n      color: [168, 64, 3]\n    }, {\n      value: 0.5,\n      color: [188, 100, 4]\n    }, {\n      value: 0.63,\n      color: [206, 136, 11]\n    }, {\n      value: 0.75,\n      color: [220, 174, 25]\n    }, {\n      value: 0.88,\n      color: [231, 215, 44]\n    }, {\n      value: 1,\n      color: [248, 254, 105]\n    }]\n  }),\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [51, 20, 24]\n    }, {\n      value: 0.13,\n      color: [90, 32, 35]\n    }, {\n      value: 0.25,\n      color: [129, 44, 34]\n    }, {\n      value: 0.38,\n      color: [159, 68, 25]\n    }, {\n      value: 0.5,\n      color: [182, 99, 19]\n    }, {\n      value: 0.63,\n      color: [199, 134, 22]\n    }, {\n      value: 0.75,\n      color: [212, 171, 35]\n    }, {\n      value: 0.88,\n      color: [221, 210, 54]\n    }, {\n      value: 1,\n      color: [225, 253, 75]\n    }]\n  }),\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [145, 105, 18]\n    }, {\n      value: 0.13,\n      color: [184, 71, 38]\n    }, {\n      value: 0.25,\n      color: [186, 58, 115]\n    }, {\n      value: 0.38,\n      color: [160, 71, 185]\n    }, {\n      value: 0.5,\n      color: [110, 97, 218]\n    }, {\n      value: 0.63,\n      color: [50, 123, 164]\n    }, {\n      value: 0.75,\n      color: [31, 131, 110]\n    }, {\n      value: 0.88,\n      color: [77, 129, 34]\n    }, {\n      value: 1,\n      color: [145, 105, 18]\n    }]\n  }),\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [42, 24, 108]\n    }, {\n      value: 0.13,\n      color: [33, 50, 162]\n    }, {\n      value: 0.25,\n      color: [15, 90, 145]\n    }, {\n      value: 0.38,\n      color: [40, 118, 137]\n    }, {\n      value: 0.5,\n      color: [59, 146, 135]\n    }, {\n      value: 0.63,\n      color: [79, 175, 126]\n    }, {\n      value: 0.75,\n      color: [120, 203, 104]\n    }, {\n      value: 0.88,\n      color: [193, 221, 100]\n    }, {\n      value: 1,\n      color: [253, 239, 154]\n    }]\n  }),\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [4, 35, 51]\n    }, {\n      value: 0.13,\n      color: [23, 51, 122]\n    }, {\n      value: 0.25,\n      color: [85, 59, 157]\n    }, {\n      value: 0.38,\n      color: [129, 79, 143]\n    }, {\n      value: 0.5,\n      color: [175, 95, 130]\n    }, {\n      value: 0.63,\n      color: [222, 112, 101]\n    }, {\n      value: 0.75,\n      color: [249, 146, 66]\n    }, {\n      value: 0.88,\n      color: [249, 196, 65]\n    }, {\n      value: 1,\n      color: [232, 250, 91]\n    }]\n  }),\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [34, 31, 27]\n    }, {\n      value: 0.13,\n      color: [65, 50, 41]\n    }, {\n      value: 0.25,\n      color: [98, 69, 52]\n    }, {\n      value: 0.38,\n      color: [131, 89, 57]\n    }, {\n      value: 0.5,\n      color: [161, 112, 59]\n    }, {\n      value: 0.63,\n      color: [185, 140, 66]\n    }, {\n      value: 0.75,\n      color: [202, 174, 88]\n    }, {\n      value: 0.88,\n      color: [216, 209, 126]\n    }, {\n      value: 1,\n      color: [233, 246, 171]\n    }]\n  }),\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [17, 32, 64]\n    }, {\n      value: 0.13,\n      color: [35, 52, 116]\n    }, {\n      value: 0.25,\n      color: [29, 81, 156]\n    }, {\n      value: 0.38,\n      color: [31, 113, 162]\n    }, {\n      value: 0.5,\n      color: [50, 144, 169]\n    }, {\n      value: 0.63,\n      color: [87, 173, 176]\n    }, {\n      value: 0.75,\n      color: [149, 196, 189]\n    }, {\n      value: 0.88,\n      color: [203, 221, 211]\n    }, {\n      value: 1,\n      color: [254, 251, 230]\n    }]\n  }),\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [23, 35, 19]\n    }, {\n      value: 0.13,\n      color: [24, 64, 38]\n    }, {\n      value: 0.25,\n      color: [11, 95, 45]\n    }, {\n      value: 0.38,\n      color: [39, 123, 35]\n    }, {\n      value: 0.5,\n      color: [95, 146, 12]\n    }, {\n      value: 0.63,\n      color: [152, 165, 18]\n    }, {\n      value: 0.75,\n      color: [201, 186, 69]\n    }, {\n      value: 0.88,\n      color: [233, 216, 137]\n    }, {\n      value: 1,\n      color: [255, 253, 205]\n    }]\n  }),\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.07,\n      color: [22, 5, 59]\n    }, {\n      value: 0.13,\n      color: [60, 4, 105]\n    }, {\n      value: 0.2,\n      color: [109, 1, 135]\n    }, {\n      value: 0.27,\n      color: [161, 0, 147]\n    }, {\n      value: 0.33,\n      color: [210, 2, 142]\n    }, {\n      value: 0.4,\n      color: [251, 11, 123]\n    }, {\n      value: 0.47,\n      color: [255, 29, 97]\n    }, {\n      value: 0.53,\n      color: [255, 54, 69]\n    }, {\n      value: 0.6,\n      color: [255, 85, 46]\n    }, {\n      value: 0.67,\n      color: [255, 120, 34]\n    }, {\n      value: 0.73,\n      color: [255, 157, 37]\n    }, {\n      value: 0.8,\n      color: [241, 191, 57]\n    }, {\n      value: 0.87,\n      color: [224, 220, 93]\n    }, {\n      value: 0.93,\n      color: [218, 241, 142]\n    }, {\n      value: 1,\n      color: [227, 253, 198]\n    }]\n  }),\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [0, 32, 77, 255]\n    }, {\n      value: 0.125,\n      color: [5, 54, 110, 255]\n    }, {\n      value: 0.25,\n      color: [65, 77, 108, 255]\n    }, {\n      value: 0.375,\n      color: [97, 100, 111, 255]\n    }, {\n      value: 0.5,\n      color: [125, 124, 121, 255]\n    }, {\n      value: 0.625,\n      color: [156, 149, 120, 255]\n    }, {\n      value: 0.75,\n      color: [190, 175, 111, 255]\n    }, {\n      value: 0.875,\n      color: [225, 204, 94, 255]\n    }, {\n      value: 1,\n      color: [255, 235, 70, 255]\n    }]\n  }),\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [48, 18, 59, 255]\n    }, {\n      value: 0.125,\n      color: [70, 107, 227, 255]\n    }, {\n      value: 0.25,\n      color: [40, 187, 236, 255]\n    }, {\n      value: 0.375,\n      color: [49, 242, 153, 255]\n    }, {\n      value: 0.5,\n      color: [162, 252, 60, 255]\n    }, {\n      value: 0.625,\n      color: [237, 208, 58, 255]\n    }, {\n      value: 0.75,\n      color: [251, 128, 34, 255]\n    }, {\n      value: 0.875,\n      color: [210, 49, 5, 255]\n    }, {\n      value: 1,\n      color: [122, 4, 3, 255]\n    }]\n  }),\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [250, 235, 221, 0]\n    }, {\n      value: 0.133,\n      color: [250, 235, 221, 255]\n    }, {\n      value: 0.266,\n      color: [246, 170, 130, 255]\n    }, {\n      value: 0.4,\n      color: [240, 96, 67, 255]\n    }, {\n      value: 0.533,\n      color: [203, 27, 79, 255]\n    }, {\n      value: 0.666,\n      color: [132, 30, 90, 255]\n    }, {\n      value: 0.8,\n      color: [63, 27, 68, 255]\n    }, {\n      value: 1,\n      color: [3, 5, 26, 255]\n    }]\n  }),\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new ColorRamp({\n    stops: [{\n      value: 0,\n      color: [11, 4, 5, 255]\n    }, {\n      value: 0.125,\n      color: [43, 28, 53, 255]\n    }, {\n      value: 0.25,\n      color: [62, 53, 107, 255]\n    }, {\n      value: 0.375,\n      color: [59, 86, 152, 255]\n    }, {\n      value: 0.5,\n      color: [53, 123, 162, 255]\n    }, {\n      value: 0.625,\n      color: [53, 158, 170, 255]\n    }, {\n      value: 0.75,\n      color: [73, 193, 173, 255]\n    }, {\n      value: 0.875,\n      color: [150, 221, 181, 255]\n    }, {\n      value: 1,\n      color: [222, 245, 229, 255]\n    }]\n  })\n};\nconst colorPalettes = [\n// https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n[\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n// https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n[\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n// https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n[\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n// https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n[\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n//https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n[\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n// https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n[\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n// https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n[\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n// https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n[\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n// https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n[\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"]];\nfunction getRandomColor() {\n  return colorPalettes[~~(Math.random() * colorPalettes.length)][~~(Math.random() * 4)];\n}\nfunction generateRandomSourceName() {\n  return `maptiler_source_${generateRandomString()}`;\n}\nfunction generateRandomLayerName() {\n  return `maptiler_layer_${generateRandomString()}`;\n}\nfunction lerpZoomNumberValues(znv, z) {\n  if (z <= znv[0].zoom) {\n    return znv[0].value;\n  }\n  if (z >= znv[znv.length - 1].zoom) {\n    return znv[znv.length - 1].value;\n  }\n  for (let i = 0; i < znv.length - 1; i += 1) {\n    if (z >= znv[i].zoom && z < znv[i + 1].zoom) {\n      const zoomRange = znv[i + 1].zoom - znv[i].zoom;\n      const normalizedDistanceFromLowerBound = (z - znv[i].zoom) / zoomRange;\n      return normalizedDistanceFromLowerBound * znv[i + 1].value + (1 - normalizedDistanceFromLowerBound) * znv[i].value;\n    }\n  }\n  return 0;\n}\nfunction paintColorOptionsToPaintSpec(color) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...color.map(el => [el.zoom, el.value]).flat()];\n}\nfunction rampedOptionsToLayerPaintSpec(ramp) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...ramp.map(el => [el.zoom, el.value]).flat()];\n}\nfunction computeRampedOutlineWidth(lineWidth, outlineWidth) {\n  if (typeof outlineWidth === \"number\" && typeof lineWidth === \"number\") {\n    return 2 * outlineWidth + lineWidth;\n  } else if (typeof outlineWidth === \"number\" && Array.isArray(lineWidth)) {\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...lineWidth.map(el => [el.zoom, 2 * outlineWidth + el.value]).flat()];\n  } else if (typeof lineWidth === \"number\" && Array.isArray(outlineWidth)) {\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...outlineWidth.map(el => [el.zoom, 2 * el.value + lineWidth]).flat()];\n  }\n  if (Array.isArray(lineWidth) && Array.isArray(outlineWidth)) {\n    const allStops = Array.from( /* @__PURE__ */new Set([...lineWidth.map(el => el.zoom), ...outlineWidth.map(el => el.zoom)])).sort((a, b) => a < b ? -1 : 1);\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...allStops.map(z => [z, 2 * lerpZoomNumberValues(outlineWidth, z) + lerpZoomNumberValues(lineWidth, z)]).flat()];\n  }\n  return 0;\n}\nfunction rampedPropertyValueWeight(ramp, property) {\n  return [\"interpolate\", [\"linear\"], [\"get\", property], ...ramp.map(el => [el.propertyValue, el.value]).flat()];\n}\nfunction dashArrayMaker(pattern) {\n  const startTrimmedPattern = pattern.trimStart();\n  const fixedPattern = `${startTrimmedPattern}${\" \".repeat(pattern.length - startTrimmedPattern.length)}`;\n  const patternArr = Array.from(fixedPattern);\n  const isOnlyDashesAndSpaces = patternArr.every(c => c === \" \" || c === \"_\");\n  if (!isOnlyDashesAndSpaces) {\n    throw new Error(\"A dash pattern must be composed only of whitespace and underscore characters.\");\n  }\n  const hasBothDashesAndWhitespaces = patternArr.some(c => c === \"_\") && patternArr.some(c => c === \" \");\n  if (!hasBothDashesAndWhitespaces) {\n    throw new Error(\"A dash pattern must contain at least one underscore and one whitespace character\");\n  }\n  const dashArray = [1];\n  for (let i = 1; i < patternArr.length; i += 1) {\n    const previous = patternArr[i - 1];\n    const current = patternArr[i];\n    if (previous === current) {\n      dashArray[dashArray.length - 1] += 1;\n    } else {\n      dashArray.push(1);\n    }\n  }\n  return dashArray;\n}\nfunction colorDrivenByProperty(style, property) {\n  return [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.value, el.color]).flat()];\n}\nfunction radiusDrivenByProperty(style, property, zoomCompensation = true) {\n  if (!zoomCompensation) {\n    return [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.value, el.pointRadius]).flat()];\n  }\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], 0, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.value, el.pointRadius * 0.025]).flat()], 2, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.value, el.pointRadius * 0.05]).flat()], 4, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.value, el.pointRadius * 0.1]).flat()], 8, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.value, el.pointRadius * 0.25]).flat()], 16, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.value, el.pointRadius]).flat()]];\n}\nfunction radiusDrivenByPropertyHeatmap(style, property, zoomCompensation = true) {\n  if (!zoomCompensation) {\n    return [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.propertyValue, el.value]).flat()];\n  }\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], 0, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.propertyValue, el.value * 0.025]).flat()], 2, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.propertyValue, el.value * 0.05]).flat()], 4, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.propertyValue, el.value * 0.1]).flat()], 8, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.propertyValue, el.value * 0.25]).flat()], 16, [\"interpolate\", [\"linear\"], [\"get\", property], ...style.map(el => [el.propertyValue, el.value]).flat()]];\n}\nfunction opacityDrivenByProperty(colorramp, property) {\n  if (colorramp.every(el => el.color[3] === colorramp[0].color[3])) {\n    return colorramp[0].color[3] ? colorramp[0].color[3] / 255 : 1;\n  }\n  return [\"interpolate\", [\"linear\"], [\"get\", property], ...colorramp.getRawColorStops().map(el => {\n    const value = el.value;\n    const color = el.color;\n    return [value, color.length === 4 ? color[3] / 255 : 1];\n  }).flat()];\n}\nfunction heatmapIntensityFromColorRamp(colorRamp, steps = 10) {\n  return [\"interpolate\", [\"linear\"], [\"heatmap-density\"], ...Array.from({\n    length: steps + 1\n  }, (_, i) => {\n    const unitStep = i / steps;\n    return [unitStep, colorRamp.getColorHex(unitStep)];\n  }).flat()];\n}\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction addPolyline(_0, _1) {\n  return __async(this, arguments, function* (map, options, fetchOptions = {}) {\n    var _a, _b, _c;\n    if (!options.sourceId && !options.data) {\n      throw new Error(\"Creating a polyline layer requires an existing .sourceId or a valid .data property\");\n    }\n    let data = options.data;\n    if (typeof data === \"string\") {\n      if (isUUID(data)) {\n        data = `https://api.maptiler.com/data/${options.data}/features.json?key=${config.apiKey}`;\n      } else if (((_a = data.split(\".\").pop()) == null ? void 0 : _a.toLowerCase().trim()) === \"gpx\") {\n        const res = yield fetch(data, fetchOptions);\n        const gpxStr = yield res.text();\n        data = gpx(gpxStr);\n      } else if (((_b = data.split(\".\").pop()) == null ? void 0 : _b.toLowerCase().trim()) === \"kml\") {\n        const res = yield fetch(data, fetchOptions);\n        const kmlStr = yield res.text();\n        data = kml(kmlStr);\n      } else {\n        const tmpData = (_c = jsonParseNoThrow(data)) != null ? _c : gpxOrKml(data);\n        if (tmpData) data = tmpData;\n      }\n      if (!data) {\n        throw new Error(\"Polyline data was provided as string but is incompatible with valid formats.\");\n      }\n    }\n    return addGeoJSONPolyline(map, __spreadProps(__spreadValues({}, options), {\n      data\n    }));\n  });\n}\nfunction addGeoJSONPolyline(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const returnedInfo = {\n    polylineLayerId: layerId,\n    polylineOutlineLayerId: \"\",\n    polylineSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: options.data\n    });\n  }\n  const lineWidth = (_c = options.lineWidth) != null ? _c : 3;\n  const lineColor = (_d = options.lineColor) != null ? _d : getRandomColor();\n  const lineOpacity = (_e = options.lineOpacity) != null ? _e : 1;\n  const lineBlur = (_f = options.lineBlur) != null ? _f : 0;\n  const lineGapWidth = (_g = options.lineGapWidth) != null ? _g : 0;\n  let lineDashArray = (_h = options.lineDashArray) != null ? _h : null;\n  const outlineWidth = (_i = options.outlineWidth) != null ? _i : 1;\n  const outlineColor = (_j = options.outlineColor) != null ? _j : \"#FFFFFF\";\n  const outlineOpacity = (_k = options.outlineOpacity) != null ? _k : 1;\n  const outlineBlur = (_l = options.outlineBlur) != null ? _l : 0;\n  if (typeof lineDashArray === \"string\") {\n    lineDashArray = dashArrayMaker(lineDashArray);\n  }\n  if (options.outline === true) {\n    const outlineLayerId = `${layerId}_outline`;\n    returnedInfo.polylineOutlineLayerId = outlineLayerId;\n    map.addLayer({\n      id: outlineLayerId,\n      type: \"line\",\n      source: sourceId,\n      layout: {\n        \"line-join\": (_m = options.lineJoin) != null ? _m : \"round\",\n        \"line-cap\": (_n = options.lineCap) != null ? _n : \"round\"\n      },\n      minzoom: (_o = options.minzoom) != null ? _o : 0,\n      maxzoom: (_p = options.maxzoom) != null ? _p : 23,\n      paint: {\n        \"line-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n        \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n        \"line-width\": computeRampedOutlineWidth(lineWidth, outlineWidth),\n        \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur)\n      }\n    }, options.beforeId);\n  }\n  map.addLayer({\n    id: layerId,\n    type: \"line\",\n    source: sourceId,\n    layout: {\n      \"line-join\": (_q = options.lineJoin) != null ? _q : \"round\",\n      \"line-cap\": (_r = options.lineCap) != null ? _r : \"round\"\n    },\n    minzoom: (_s = options.minzoom) != null ? _s : 0,\n    maxzoom: (_t = options.maxzoom) != null ? _t : 23,\n    paint: __spreadValues({\n      \"line-opacity\": typeof lineOpacity === \"number\" ? lineOpacity : rampedOptionsToLayerPaintSpec(lineOpacity),\n      \"line-color\": typeof lineColor === \"string\" ? lineColor : paintColorOptionsToPaintSpec(lineColor),\n      \"line-width\": typeof lineWidth === \"number\" ? lineWidth : rampedOptionsToLayerPaintSpec(lineWidth),\n      \"line-blur\": typeof lineBlur === \"number\" ? lineBlur : rampedOptionsToLayerPaintSpec(lineBlur),\n      \"line-gap-width\": typeof lineGapWidth === \"number\" ? lineGapWidth : rampedOptionsToLayerPaintSpec(lineGapWidth)\n    }, lineDashArray && {\n      \"line-dasharray\": lineDashArray\n    })\n  }, options.beforeId);\n  return returnedInfo;\n}\nfunction addPolygon(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const returnedInfo = {\n    polygonLayerId: layerId,\n    polygonOutlineLayerId: options.outline ? `${layerId}_outline` : \"\",\n    polygonSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data\n    });\n  }\n  let outlineDashArray = (_c = options.outlineDashArray) != null ? _c : null;\n  const outlineWidth = (_d = options.outlineWidth) != null ? _d : 1;\n  const outlineColor = (_e = options.outlineColor) != null ? _e : \"#FFFFFF\";\n  const outlineOpacity = (_f = options.outlineOpacity) != null ? _f : 1;\n  const outlineBlur = (_g = options.outlineBlur) != null ? _g : 0;\n  const fillColor = (_h = options.fillColor) != null ? _h : getRandomColor();\n  const fillOpacity = (_i = options.fillOpacity) != null ? _i : 1;\n  const outlinePosition = (_j = options.outlinePosition) != null ? _j : \"center\";\n  const pattern = (_k = options.pattern) != null ? _k : null;\n  if (typeof outlineDashArray === \"string\") {\n    outlineDashArray = dashArrayMaker(outlineDashArray);\n  }\n  const addLayers = (patternImageId = null) => {\n    var _a2, _b2, _c2, _d2, _e2, _f2;\n    map.addLayer({\n      id: layerId,\n      type: \"fill\",\n      source: sourceId,\n      minzoom: (_a2 = options.minzoom) != null ? _a2 : 0,\n      maxzoom: (_b2 = options.maxzoom) != null ? _b2 : 23,\n      paint: __spreadValues({\n        \"fill-color\": typeof fillColor === \"string\" ? fillColor : paintColorOptionsToPaintSpec(fillColor),\n        \"fill-opacity\": typeof fillOpacity === \"number\" ? fillOpacity : rampedOptionsToLayerPaintSpec(fillOpacity)\n      }, patternImageId && {\n        \"fill-pattern\": patternImageId\n      })\n    }, options.beforeId);\n    if (options.outline === true) {\n      let computedOutlineOffset;\n      if (outlinePosition === \"inside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = 0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(outlineWidth.map(({\n            zoom,\n            value\n          }) => ({\n            zoom,\n            value: 0.5 * value\n          })));\n        }\n      } else if (outlinePosition === \"outside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = -0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(outlineWidth.map(el => ({\n            zoom: el.zoom,\n            value: -0.5 * el.value\n          })));\n        }\n      } else {\n        computedOutlineOffset = 0;\n      }\n      map.addLayer({\n        id: returnedInfo.polygonOutlineLayerId,\n        type: \"line\",\n        source: sourceId,\n        layout: {\n          \"line-join\": (_c2 = options.outlineJoin) != null ? _c2 : \"round\",\n          \"line-cap\": (_d2 = options.outlineCap) != null ? _d2 : \"butt\"\n        },\n        minzoom: (_e2 = options.minzoom) != null ? _e2 : 0,\n        maxzoom: (_f2 = options.maxzoom) != null ? _f2 : 23,\n        paint: __spreadValues({\n          \"line-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n          \"line-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n          \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur),\n          \"line-offset\": computedOutlineOffset\n        }, outlineDashArray && {\n          \"line-dasharray\": outlineDashArray\n        })\n      }, options.beforeId);\n    }\n  };\n  if (pattern) {\n    if (map.hasImage(pattern)) {\n      addLayers(pattern);\n    } else {\n      map.loadImage(pattern,\n      // (error?: Error | null, image?: HTMLImageElement | ImageBitmap | null, expiry?: ExpiryData | null)\n      (error, image) => {\n        if (error) {\n          console.error(\"Could not load the pattern image.\", error.message);\n          return addLayers();\n        }\n        if (!image) {\n          console.error(`An image cannot be created from the pattern URL ${pattern}.`);\n          return addLayers();\n        }\n        map.addImage(pattern, image);\n        addLayers(pattern);\n      });\n    }\n  } else {\n    addLayers();\n  }\n  return returnedInfo;\n}\nfunction addPoint(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n  const minPointRadius = (_a = options.minPointRadius) != null ? _a : 10;\n  const maxPointRadius = (_b = options.maxPointRadius) != null ? _b : 50;\n  const cluster = (_c = options.cluster) != null ? _c : false;\n  const nbDefaultDataDrivenStyleSteps = 20;\n  const colorramp = Array.isArray(options.pointColor) ? options.pointColor : ColorRampCollection.TURBO.scale(10, options.cluster ? 1e4 : 1e3).resample(\"ease-out-square\");\n  const colorRampBounds = colorramp.getBounds();\n  const sourceId = (_d = options.sourceId) != null ? _d : generateRandomSourceName();\n  const layerId = (_e = options.layerId) != null ? _e : generateRandomLayerName();\n  const showLabel = (_f = options.showLabel) != null ? _f : cluster;\n  const alignOnViewport = (_g = options.alignOnViewport) != null ? _g : true;\n  const outline = (_h = options.outline) != null ? _h : false;\n  const outlineOpacity = (_i = options.outlineOpacity) != null ? _i : 1;\n  const outlineWidth = (_j = options.outlineWidth) != null ? _j : 1;\n  const outlineColor = (_k = options.outlineColor) != null ? _k : \"#FFFFFF\";\n  let pointOpacity;\n  const zoomCompensation = (_l = options.zoomCompensation) != null ? _l : true;\n  const minzoom = (_m = options.minzoom) != null ? _m : 0;\n  const maxzoom = (_n = options.maxzoom) != null ? _n : 23;\n  if (typeof options.pointOpacity === \"number\") {\n    pointOpacity = options.pointOpacity;\n  } else if (Array.isArray(options.pointOpacity)) {\n    pointOpacity = rampedOptionsToLayerPaintSpec(options.pointOpacity);\n  } else if (options.cluster) {\n    pointOpacity = opacityDrivenByProperty(colorramp, \"point_count\");\n  } else if (options.property) {\n    pointOpacity = opacityDrivenByProperty(colorramp, options.property);\n  } else {\n    pointOpacity = rampedOptionsToLayerPaintSpec([{\n      zoom: minzoom,\n      value: 0\n    }, {\n      zoom: minzoom + 0.25,\n      value: 1\n    }, {\n      zoom: maxzoom - 0.25,\n      value: 1\n    }, {\n      zoom: maxzoom,\n      value: 0\n    }]);\n  }\n  const returnedInfo = {\n    pointLayerId: layerId,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data,\n      cluster\n    });\n  }\n  if (cluster) {\n    returnedInfo.clusterLayerId = `${layerId}_cluster`;\n    const clusterStyle = Array.from({\n      length: nbDefaultDataDrivenStyleSteps\n    }, (_, i) => {\n      const value = colorRampBounds.min + i * (colorRampBounds.max - colorRampBounds.min) / (nbDefaultDataDrivenStyleSteps - 1);\n      return {\n        value,\n        pointRadius: minPointRadius + (maxPointRadius - minPointRadius) * Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n        color: colorramp.getColorHex(value)\n      };\n    });\n    map.addLayer({\n      id: returnedInfo.clusterLayerId,\n      type: \"circle\",\n      source: sourceId,\n      filter: [\"has\", \"point_count\"],\n      paint: __spreadValues({\n        // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n        \"circle-color\": typeof options.pointColor === \"string\" ? options.pointColor : colorDrivenByProperty(clusterStyle, \"point_count\"),\n        \"circle-radius\": typeof options.pointRadius === \"number\" ? options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : radiusDrivenByProperty(clusterStyle, \"point_count\", false),\n        \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n        \"circle-pitch-scale\": \"map\",\n        // scale with camera distance regardless of viewport/biewport alignement\n        \"circle-opacity\": pointOpacity\n      }, outline && {\n        \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n        \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n        \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n      }),\n      minzoom,\n      maxzoom\n    }, options.beforeId);\n    map.addLayer({\n      id: returnedInfo.pointLayerId,\n      type: \"circle\",\n      source: sourceId,\n      filter: [\"!\", [\"has\", \"point_count\"]],\n      paint: __spreadValues({\n        \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n        \"circle-pitch-scale\": \"map\",\n        // scale with camera distance regardless of viewport/biewport alignement\n        // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n        \"circle-color\": typeof options.pointColor === \"string\" ? options.pointColor : colorramp.getColorHex(colorramp.getBounds().min),\n        \"circle-radius\": typeof options.pointRadius === \"number\" ? options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : clusterStyle[0].pointRadius * 0.75,\n        \"circle-opacity\": pointOpacity\n      }, outline && {\n        \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n        \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n        \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n      }),\n      minzoom,\n      maxzoom\n    }, options.beforeId);\n  } else {\n    let pointColor = typeof options.pointColor === \"string\" ? options.pointColor : Array.isArray(options.pointColor) ? options.pointColor.getColorHex(options.pointColor.getBounds().min) : getRandomColor();\n    let pointRadius = typeof options.pointRadius === \"number\" ? zoomCompensation ? rampedOptionsToLayerPaintSpec([{\n      zoom: 0,\n      value: options.pointRadius * 0.025\n    }, {\n      zoom: 2,\n      value: options.pointRadius * 0.05\n    }, {\n      zoom: 4,\n      value: options.pointRadius * 0.1\n    }, {\n      zoom: 8,\n      value: options.pointRadius * 0.25\n    }, {\n      zoom: 16,\n      value: options.pointRadius * 1\n    }]) : options.pointRadius : Array.isArray(options.pointRadius) ? rampedOptionsToLayerPaintSpec(options.pointRadius) : zoomCompensation ? rampedOptionsToLayerPaintSpec([{\n      zoom: 0,\n      value: minPointRadius * 0.05\n    }, {\n      zoom: 2,\n      value: minPointRadius * 0.1\n    }, {\n      zoom: 4,\n      value: minPointRadius * 0.2\n    }, {\n      zoom: 8,\n      value: minPointRadius * 0.5\n    }, {\n      zoom: 16,\n      value: minPointRadius * 1\n    }]) : minPointRadius;\n    if (options.property && Array.isArray(options.pointColor)) {\n      const dataDrivenStyle = Array.from({\n        length: nbDefaultDataDrivenStyleSteps\n      }, (_, i) => {\n        const value = colorRampBounds.min + i * (colorRampBounds.max - colorRampBounds.min) / (nbDefaultDataDrivenStyleSteps - 1);\n        return {\n          value,\n          pointRadius: typeof options.pointRadius === \"number\" ? options.pointRadius : minPointRadius + (maxPointRadius - minPointRadius) * Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n          color: typeof options.pointColor === \"string\" ? options.pointColor : colorramp.getColorHex(value)\n        };\n      });\n      pointColor = colorDrivenByProperty(dataDrivenStyle, options.property);\n      pointRadius = radiusDrivenByProperty(dataDrivenStyle, options.property, zoomCompensation);\n    }\n    map.addLayer({\n      id: returnedInfo.pointLayerId,\n      type: \"circle\",\n      source: sourceId,\n      layout: {\n        // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n        \"circle-sort-key\": options.property ? [\"/\", 1, [\"get\", options.property]] : 0\n      },\n      paint: __spreadValues({\n        \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n        \"circle-pitch-scale\": \"map\",\n        // scale with camera distance regardless of viewport/biewport alignement\n        \"circle-color\": pointColor,\n        \"circle-opacity\": pointOpacity,\n        \"circle-radius\": pointRadius\n      }, outline && {\n        \"circle-stroke-opacity\": typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n        \"circle-stroke-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n        \"circle-stroke-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor)\n      }),\n      minzoom,\n      maxzoom\n    }, options.beforeId);\n  }\n  if (showLabel !== false && (options.cluster || options.property)) {\n    returnedInfo.labelLayerId = `${layerId}_label`;\n    const labelColor = (_o = options.labelColor) != null ? _o : \"#fff\";\n    const labelSize = (_p = options.labelSize) != null ? _p : 12;\n    map.addLayer({\n      id: returnedInfo.labelLayerId,\n      type: \"symbol\",\n      source: sourceId,\n      filter: [\"has\", options.cluster ? \"point_count\" : options.property],\n      layout: {\n        \"text-field\": options.cluster ? \"{point_count_abbreviated}\" : `{${options.property}}`,\n        \"text-font\": [\"Noto Sans Regular\"],\n        \"text-size\": labelSize,\n        \"text-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n        \"symbol-sort-key\": [\"/\", 1, [\"get\", options.cluster ? \"point_count\" : options.property]]\n        // so that the largest value goes on top\n      },\n      paint: {\n        \"text-color\": labelColor,\n        \"text-opacity\": pointOpacity\n      },\n      minzoom,\n      maxzoom\n    }, options.beforeId);\n  }\n  return returnedInfo;\n}\nfunction addHeatmap(map, options) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n  const sourceId = (_a = options.sourceId) != null ? _a : generateRandomSourceName();\n  const layerId = (_b = options.layerId) != null ? _b : generateRandomLayerName();\n  const minzoom = (_c = options.minzoom) != null ? _c : 0;\n  const maxzoom = (_d = options.maxzoom) != null ? _d : 23;\n  const zoomCompensation = (_e = options.zoomCompensation) != null ? _e : true;\n  const opacity = (_f = options.opacity) != null ? _f : [{\n    zoom: minzoom,\n    value: 0\n  }, {\n    zoom: minzoom + 0.25,\n    value: 1\n  }, {\n    zoom: maxzoom - 0.25,\n    value: 1\n  }, {\n    zoom: maxzoom,\n    value: 0\n  }];\n  let colorRamp = Array.isArray(options.colorRamp) ? options.colorRamp : ColorRampCollection.TURBO.transparentStart();\n  const crBounds = colorRamp.getBounds();\n  if (crBounds.min !== 0 || crBounds.max !== 1) {\n    colorRamp = colorRamp.scale(0, 1);\n  }\n  if (!colorRamp.hasTransparentStart()) {\n    colorRamp = colorRamp.transparentStart();\n  }\n  const intensity = (_g = options.intensity) != null ? _g : [{\n    zoom: 0,\n    value: 0.01\n  }, {\n    zoom: 4,\n    value: 0.2\n  }, {\n    zoom: 16,\n    value: 1\n  }];\n  const property = (_h = options.property) != null ? _h : null;\n  const propertyValueWeight = (_i = options.weight) != null ? _i : 1;\n  let heatmapWeight = 1;\n  if (property) {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n      if (typeof options.weight === \"number\") {\n        console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\");\n      }\n    } else if (Array.isArray(propertyValueWeight)) {\n      heatmapWeight = rampedPropertyValueWeight(propertyValueWeight, property);\n    } else {\n      console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\");\n    }\n  } else {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n    } else if (Array.isArray(propertyValueWeight)) {\n      console.warn(\"The options `.propertyValueWeights` can only be used when `.property` is provided.\");\n    }\n  }\n  const defaultRadiusZoomRamping = [{\n    zoom: 0,\n    value: 50 * 0.025\n  }, {\n    zoom: 2,\n    value: 50 * 0.05\n  }, {\n    zoom: 4,\n    value: 50 * 0.1\n  }, {\n    zoom: 8,\n    value: 50 * 0.25\n  }, {\n    zoom: 16,\n    value: 50\n  }];\n  const radius = (_j = options.radius) != null ? _j : zoomCompensation ? defaultRadiusZoomRamping : 10;\n  let radiusHeatmap = 1;\n  if (typeof radius === \"number\") {\n    radiusHeatmap = radius;\n  } else if (Array.isArray(radius) && \"zoom\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(radius);\n  } else if (property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = radiusDrivenByPropertyHeatmap(radius, property, zoomCompensation);\n  } else if (!property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(defaultRadiusZoomRamping);\n    console.warn(\"The option `.radius` can only be property-driven if the option `.property` is provided.\");\n  } else {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(defaultRadiusZoomRamping);\n  }\n  const returnedInfo = {\n    heatmapLayerId: layerId,\n    heatmapSourceId: sourceId\n  };\n  if (options.data && !map.getSource(sourceId)) {\n    let data = options.data;\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data\n    });\n  }\n  map.addLayer({\n    id: layerId,\n    type: \"heatmap\",\n    source: sourceId,\n    minzoom,\n    maxzoom,\n    paint: {\n      \"heatmap-weight\": heatmapWeight,\n      \"heatmap-intensity\": typeof intensity === \"number\" ? intensity : rampedOptionsToLayerPaintSpec(intensity),\n      \"heatmap-color\": heatmapIntensityFromColorRamp(colorRamp),\n      \"heatmap-radius\": radiusHeatmap,\n      \"heatmap-opacity\": typeof opacity === \"number\" ? opacity : rampedOptionsToLayerPaintSpec(opacity)\n    }\n  });\n  return returnedInfo;\n}\nconst helpers = {\n  addPolyline,\n  addPolygon,\n  addPoint,\n  addHeatmap\n};\nconst {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol\n} = maplibregl__default;\nconst MapMLGL = maplibregl__default.Map;\nconst MarkerMLGL = maplibregl__default.Marker;\nconst PopupMLGL = maplibregl__default.Popup;\nconst StyleMLGL = maplibregl__default.Style;\nconst CanvasSourceMLGL = maplibregl__default.CanvasSource;\nconst GeoJSONSourceMLGL = maplibregl__default.GeoJSONSource;\nconst ImageSourceMLGL = maplibregl__default.ImageSource;\nconst RasterTileSourceMLGL = maplibregl__default.RasterTileSource;\nconst RasterDEMTileSourceMLGL = maplibregl__default.RasterDEMTileSource;\nconst VectorTileSourceMLGL = maplibregl__default.VectorTileSource;\nconst VideoSourceMLGL = maplibregl__default.VideoSource;\nmaplibregl__default.NavigationControl;\nmaplibregl__default.GeolocateControl;\nmaplibregl__default.AttributionControl;\nmaplibregl__default.LogoControl;\nmaplibregl__default.ScaleControl;\nmaplibregl__default.FullscreenControl;\nmaplibregl__default.TerrainControl;\nexport { AJAXError, AttributionControl, CanvasSource, CanvasSourceMLGL, ColorRamp, ColorRampCollection, Evented, FullscreenControl, GeoJSONSource, GeoJSONSourceMLGL, GeolocateControl, GeolocationType, ImageSource, ImageSourceMLGL, Language, LngLat, LngLatBounds, LogoControl, Map, MapMLGL, MaptilerGeolocateControl, MaptilerLogoControl, MaptilerNavigationControl, MaptilerTerrainControl, Marker, MarkerMLGL, MercatorCoordinate, NavigationControl, Point, Popup, PopupMLGL, RasterDEMTileSource, RasterDEMTileSourceMLGL, RasterTileSource, RasterTileSourceMLGL, ScaleControl, SdkConfig, Style, StyleMLGL, TerrainControl, VectorTileSource, VectorTileSourceMLGL, VideoSource, VideoSourceMLGL, addProtocol, clearPrewarmedResources, config, getBrowserLanguage, getRTLTextPluginStatus, gpx, gpxOrKml, hasChildNodeWithName, helpers, isLanguageSupported, kml, maxParallelImageRequests, prewarm, removeProtocol, setRTLTextPlugin, str2xml, version, workerCount, workerUrl, xml2str };","map":{"version":3,"names":["Language","VISITOR","VISITOR_ENGLISH","STYLE","AUTO","STYLE_LOCK","LATIN","NON_LATIN","LOCAL","INTERNATIONAL","ALBANIAN","AMHARIC","ARABIC","ARMENIAN","AZERBAIJANI","BASQUE","BELORUSSIAN","BENGALI","BOSNIAN","BRETON","BULGARIAN","CATALAN","CHINESE","TRADITIONAL_CHINESE","SIMPLIFIED_CHINESE","CORSICAN","CROATIAN","CZECH","DANISH","DUTCH","ENGLISH","ESPERANTO","ESTONIAN","FINNISH","FRENCH","FRISIAN","GEORGIAN","GERMAN","GREEK","HEBREW","HINDI","HUNGARIAN","ICELANDIC","INDONESIAN","IRISH","ITALIAN","JAPANESE","JAPANESE_HIRAGANA","JAPANESE_KANA","JAPANESE_LATIN","JAPANESE_2018","KANNADA","KAZAKH","KOREAN","KOREAN_LATIN","KURDISH","ROMAN_LATIN","LATVIAN","LITHUANIAN","LUXEMBOURGISH","MACEDONIAN","MALAYALAM","MALTESE","NORWEGIAN","OCCITAN","PERSIAN","POLISH","PORTUGUESE","PUNJABI","WESTERN_PUNJABI","ROMANIAN","ROMANSH","RUSSIAN","SCOTTISH_GAELIC","SERBIAN_CYRILLIC","SERBIAN_LATIN","SLOVAK","SLOVENE","SPANISH","SWEDISH","TAMIL","TELUGU","THAI","TURKISH","UKRAINIAN","URDU","VIETNAMIAN_LATIN","WELSH","languagesIsoSet","Set","Object","values","isLanguageSupported","lang","has","languageCodeSet","getBrowserLanguage","navigator","Intl","DateTimeFormat","resolvedOptions","locale","split","canditatelangs","Array","from","languages","map","l","filter","length","defaults","maptilerLogoURL","maptilerURL","maptilerApiHost","rtlPluginURL","primaryLanguage","secondaryLanguage","terrainSourceURL","terrainSourceId","freeze","MAPTILER_SESSION_ID","v4","SdkConfig","EventEmitter","constructor","__publicField$8","unit","u","_unit","emit","apiKey","k","_apiKey","config$1","fetch","f","config","LogoControl","maplibregl__default","onAdd","MaptilerLogoControl","options","_a","_b","__publicField$7","logoURL","linkURL","_map","_compact","compact","_container","window","document","createElement","className","anchor","style","backgroundRepeat","cursor","display","height","margin","overflow","width","backgroundImage","backgroundSize","target","rel","href","setAttribute","appendChild","on","_updateCompact","enableRTL","getRTLTextPluginStatus","setRTLTextPlugin","err","console","error","bindAll","fns","context","forEach","fn","bind","DOMcreate","tagName","container","el","DOMremove","node","parentNode","removeChild","maptilerCloudTransformRequest","url","_resourceType","reqUrl","URL","e","host","searchParams","append","session","combineTransformRequest","userDefinedRTF","resourceType","rp","rp2","__spreadValues$5","generateRandomString","Math","random","toString","substring","isUUID","s","regexExp","test","jsonParseNoThrow","doc","JSON","parse","styleToStyle","MapStyle","mapStylePresetList","referenceStyleID","getDefaultVariant","getExpandedStyleURL","String","startsWith","toLowerCase","includes","expandMapStyle","MapStyleVariant","ReferenceMapStyle","MaptilerTerrainControl","__publicField$6","_terrainButton","type","addEventListener","_toggleTerrain","_updateTerrainIcon","onRemove","off","hasTerrain","disableTerrain","enableTerrain","classList","remove","add","title","_getUIString","NavigationControl","MaptilerNavigationControl","showCompass","showZoom","visualizePitch","__publicField$5","rotate","min","pow","cos","transform","pitch","PI","angle","_compassIcon","_compass","removeEventListener","clickFunction","currentPitch","getPitch","easeTo","getMaxPitch","resetNorthPitch","originalEvent","resetNorth","_createButton","button","GeolocateControl","Marker$1","Marker","LngLat$1","LngLat","LngLatBounds$1","LngLatBounds","MaptilerGeolocateControl","arguments","__publicField$4","position","_c","center","coords","longitude","latitude","radius","accuracy","bearing","getBearing","__spreadProps$3","__spreadValues$4","fitBoundsOptions","linear","currentMapZoom","getZoom","maxZoom","zoom","fitBounds","fromLngLat","geolocateSource","hasFittingBeenDisrupted","flagFittingDisruption","once","lastUpdatedCenter","getCenter","supported","preventDefault","_geolocateButton","disabled","trackUserLocation","_watchState","showUserLocation","_dotElement","_userLocationDotMarker","element","_circleElement","_accuracyCircleMarker","pitchAlignment","_onZoom","trigger","_setup","event","fromResize","movingDistance","distanceTo","fire","Event","showAccuracyCircle","_updateCircleRadius","lastKnownLocation","_lastKnownPosition","projectedLocation","project","a","unproject","x","y","b","metersPerPixel","circleDiameter","ceil","_accuracy","AttributionControl","ScaleControl","FullscreenControl","_options","_parentMap","_canvasContainer","_parentRect","_differentStyle","_desync","_addParentRect","addParentRect_fn","_setParentBounds","setParentBounds_fn","_syncMaps","syncMaps_fn","Minimap","mapOptions","__privateAdd","__publicField$3","__privateSet","__spreadProps$2","__spreadValues$3","zoomAdjust","forceNoAttributionControl","attributionControl","navigationControl","geolocateControl","maptilerLogo","minimap","hash","pitchAdjust","containerStyle","border","lockZoom","__privateGet","minZoom","setStyle","__privateMethod","call","addLayer","layer","beforeId","moveLayer","id","removeLayer","setLayerZoomRange","layerId","minzoom","maxzoom","setFilter","setPaintProperty","name","value","setLayoutProperty","setGlyphs","glyphsUrl","parentMap","key","entries","setProperty","Map","resize","parentRect","WeakMap","WeakSet","rect","linePaint","fillPaint","properties","geometry","coordinates","addSource","data","lineLayout","source","layout","paint","devicePixelRatio","canvas","getCanvas","northWest","northEast","southWest","southEast","toArray","getSource","setData","parentCallback","sync","minimapCallback","which","to","jumpTo","GeolocationType","POINT","COUNTRY","hashPreConstructor","location","warn","__spreadProps$1","__spreadValues$2","maplibreLogo","transformRequest","__publicField$2","language","forceLanguageUpdate","languageAlwaysBeenStyle","terrainExaggeration","__async$1","geolocate","fitToIpBounds","message","ipLocatedCameraHash","centerOnIpPoint","getCameraHash","locationResult","permissions","query","state","geolocation","getCurrentPosition","terrain","duration","maximumAge","timeout","enableHighAccuracy","setPrimaryLanguage","getTerrain","isTerrainEnabled","tileJsonContent","logo","possibleSources","keys","sourceCaches","sourceName","styleUrl","tileJsonRes","json","addControl","logoPosition","customAttribution","scaleControl","setUnit","positionOptions","terrainControl","fullscreenControl","isReady","loadEventTriggered","terrainEventTriggered","terrainEventData","_a2","style2","antialias","refreshExpiredTiles","maxBounds","scrollZoom","boxZoom","fadeDuration","crossSourceCollisions","clickTolerance","bounds","pixelRatio","validateStyle","terrainCallback","evt","onLoadAsync","Promise","resolve","loaded","onReadyAsync","onLoadWithTerrainAsync","getStyleLanguage","stylesheet","metadata","setLanguage","onStyleReady","styleLanguage","languageNonStyle","langStr","replacer","layers","getStyle","textFieldLayoutProp","getLayoutProperty","getPrimaryLanguage","getTerrainExaggeration","growTerrain","exaggeration","durationMs","startTime","performance","now","currentExaggeration","deltaExaggeration","updateExaggeration","terrainFlattening","positionInLoop","exaggerationFactor","newExaggeration","requestAnimationFrame","terrainGrowing","triggerRepaint","dataEventTerrainGrow","dataType","sourceId","isSourceLoaded","addTerrain","setTerrain","animationLoopDuration","removeSource","setTerrainExaggeration","animate","cb","isStyleLoaded","ipGeolocateResult","info","country_bounds","padding","hashBin","Float32Array","lng","lat","Base64","fromUint8Array","Uint8Array","buffer","getSdkConfig","getMaptilerSessionId","setTransformRequest","loadImageAsync","reject","loadImage","image","addTo","Popup","Style","CanvasSource","GeoJSONSource","ImageSource","RasterTileSource","RasterDEMTileSource","VectorTileSource","VideoSource","TerrainControl","Point","__publicField$1","_matMult","m","_add","p","_sub","_mult","_div","_multByPoint","_divByPoint","mag","_perp","_rotate","sin","_rotateAround","_round","round","clone","sub","multByPoint","divByPoint","mult","div","rotateAround","matMult","perp","sqrt","equals","other","dist","distSqr","dx","dy","atan2","angleTo","angleWith","angleWithSep","convert","isArray","str2xml","str","DOMParser","parseFromString","querySelector","Error","hasChildNodeWithName","nodeName","hasChildNodes","childNode","childNodes","currentNodeName","trim","xml2str","XMLSerializer","serializeToString","gpx","tracks","get","routes","waypoints","gj","features","track","feature","getTrack","push","route","getRoute","waypoint","getPoint","kml","xml2string","styleIndex","styleByHash","styleMapIndex","placemarks","styles","styleMaps","okhash","attr","styleMap","pairs","pairsMap","pair","nodeVal","get1","placemark","concat","getPlacemark","kmlColor","v","color","opacity","parseInt","gxCoord","numarray","gxCoords","root","elems","times","elem","timeElems","timeElem","getGeometry","geotypes","geomNode","geomNodes","i","j","geoms","coordTimes","coord1","coord","rings","_d","_e","_f","_g","_h","_i","_j","geomsAndTimes","address","description","timeSpan","timeStamp","extendedData","visibility","lineStyle","polyStyle","styleHash","styleMapHash","normal","iconStyle","icon","begin","end","timespan","timestamp","Date","toISOString","linestyles","parseFloat","stroke","isNaN","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","getAttribute","geometries","getPoints","pointname","pts","line","heartRates","ptsLength","cPair","coordPair","time","heartRate","segments","__spreadValues$1","getProperties","getLineStyle","prop","getMulti","extensions","links","link","h","charCodeAt","getElementsByTagName","attrf","n","norm","normalize","textContent","ys","o","replace","out","coord2","ll","ele","gpxOrKml","result","componentToHex","c","hex","rgbToHex","rgb","ColorRamp","__publicField","max","setStops","stops","fromArrayDefinition","cr","cs","colorRamp","Infinity","slice","sort","scale","currentMin","currentMax","at","currentSpan","newSpan","currentValue","normalizedValue","newValue","pos","getRawColorStops","reverse","getBounds","getColor","smooth","colorBefore","valueBefore","valueAfter","colorAfter","beforeRatio","chan","i2","getColorHex","withAlpha","getColorRelative","getCanvasStrip","horizontal","size","ctx","getContext","imageData","getImageData","imageDataArray","startValue","endValue","valueSpan","valueStep","putImageData","resample","method","samples","inputBounds","inputNormalized","step","_","outputNormalized","output","transparentStart","unshift","hasTransparentStart","ColorRampCollection","NULL","GRAY","JET","HSV","HOT","SPRING","SUMMER","AUTOMN","WINTER","BONE","COPPER","GREYS","YIGNBU","GREENS","YIORRD","BLUERED","RDBU","PICNIC","RAINBOW","PORTLAND","BLACKBODY","EARTH","ELECTRIC","VIRIDIS","INFERNO","MAGMA","PLASMA","WARM","COOL","RAINBOW_SOFT","BATHYMETRY","CDOM","CHLOROPHYLL","DENSITY","FREESURFACE_BLUE","FREESURFACE_RED","OXYGEN","PAR","PHASE","SALINITY","TEMPERATURE","TURBIDITY","VELOCITY_BLUE","VELOCITY_GREEN","CUBEHELIX","CIVIDIS","TURBO","ROCKET","MAKO","colorPalettes","getRandomColor","generateRandomSourceName","generateRandomLayerName","lerpZoomNumberValues","znv","z","zoomRange","normalizedDistanceFromLowerBound","paintColorOptionsToPaintSpec","flat","rampedOptionsToLayerPaintSpec","ramp","computeRampedOutlineWidth","lineWidth","outlineWidth","allStops","rampedPropertyValueWeight","property","propertyValue","dashArrayMaker","pattern","startTrimmedPattern","trimStart","fixedPattern","repeat","patternArr","isOnlyDashesAndSpaces","every","hasBothDashesAndWhitespaces","some","dashArray","previous","current","colorDrivenByProperty","radiusDrivenByProperty","zoomCompensation","pointRadius","radiusDrivenByPropertyHeatmap","opacityDrivenByProperty","colorramp","heatmapIntensityFromColorRamp","steps","unitStep","addPolyline","_0","_1","__async","fetchOptions","pop","res","gpxStr","text","kmlStr","tmpData","addGeoJSONPolyline","__spreadProps","__spreadValues","_k","_l","_m","_n","_o","_p","_q","_r","_s","_t","getLayer","returnedInfo","polylineLayerId","polylineOutlineLayerId","polylineSourceId","lineColor","lineOpacity","lineBlur","lineGapWidth","lineDashArray","outlineColor","outlineOpacity","outlineBlur","outlineLayerId","lineJoin","lineCap","addPolygon","polygonLayerId","polygonOutlineLayerId","polygonSourceId","outlineDashArray","fillColor","fillOpacity","outlinePosition","addLayers","patternImageId","_b2","_c2","_d2","_e2","_f2","computedOutlineOffset","outlineJoin","outlineCap","hasImage","addImage","addPoint","minPointRadius","maxPointRadius","cluster","nbDefaultDataDrivenStyleSteps","pointColor","colorRampBounds","showLabel","alignOnViewport","pointOpacity","pointLayerId","clusterLayerId","labelLayerId","pointSourceId","clusterStyle","dataDrivenStyle","labelColor","labelSize","addHeatmap","crBounds","intensity","propertyValueWeight","weight","heatmapWeight","defaultRadiusZoomRamping","radiusHeatmap","heatmapLayerId","heatmapSourceId","helpers","MercatorCoordinate","Evented","AJAXError","prewarm","clearPrewarmedResources","version","workerCount","maxParallelImageRequests","workerUrl","addProtocol","removeProtocol","MapMLGL","MarkerMLGL","PopupMLGL","StyleMLGL","CanvasSourceMLGL","GeoJSONSourceMLGL","ImageSourceMLGL","RasterTileSourceMLGL","RasterDEMTileSourceMLGL","VectorTileSourceMLGL","VideoSourceMLGL"],"sources":["/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/language.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/defaults.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/config.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/LogoControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/MaptilerLogoControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/tools.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/mapstyle.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/MaptilerTerrainControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/NavigationControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/MaptilerNavigationControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/GeolocateControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/MaptilerGeolocateControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/AttributionControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/ScaleControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/FullscreenControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/Minimap.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/Map.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/Marker.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/Popup.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/Style.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/CanvasSource.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/GeoJSONSource.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/ImageSource.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/RasterTileSource.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/RasterDEMTileSource.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/VectorTileSource.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/VideoSource.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/TerrainControl.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/Point.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/converters/xml.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/colorramp.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/helpers/stylehelper.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/helpers/vectorlayerhelpers.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/helpers/index.ts","/Users/vinaykamisettymuni/Documents/GitHub/Tinoto/client/node_modules/@maptiler/sdk/src/index.ts"],"sourcesContent":["/**\n * Languages. Note that not all the languages of this list are available but the compatibility list may be expanded in the future.\n */\nconst Language = {\n  /**\n   * The visitor language mode concatenates the prefered language from the user settings and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR: \"visitor\",\n\n  /**\n   * The visitor language mode concatenates English and the \"default name\".\n   * Note: The \"default name\" is equivalent to OSM's `{name}`, which can be the most recognized names a global\n   * scale or the local name.\n   * This mode is helpful in the context where a user needs to access both the local names and the names in their\n   * own language, for instance when traveling abroad, where signs likely to be only available in the local language.\n   */\n  VISITOR_ENGLISH: \"visitor_en\",\n\n  /**\n   * Language as the style is designed. Not that this is the default state and one\n   * the language has been changed to another than `STYLE`, then it cannot be set back to `STYLE`.\n   */\n  STYLE: \"style\",\n\n  /**\n   * AUTO mode uses the language of the browser\n   */\n  AUTO: \"auto\",\n\n  /**\n   * STYLE is a custom flag to keep the language of the map as defined into the style.\n   * If STYLE is set in the constructor, then further modification of the language\n   * with `.setLanguage()` is not possible.\n   */\n  STYLE_LOCK: \"style_lock\",\n\n  /**\n   * Default fallback languages that uses latin charaters\n   */\n  LATIN: \"name:latin\",\n\n  /**\n   * Default fallback languages that uses non-latin charaters\n   */\n  NON_LATIN: \"name:nonlatin\",\n\n  /**\n   * Labels are in their local language, when available\n   */\n  LOCAL: \"name\",\n\n  /**\n   * International name\n   */\n  INTERNATIONAL: \"name_int\",\n\n  ALBANIAN: \"name:sq\",\n  AMHARIC: \"name:am\",\n  ARABIC: \"name:ar\",\n  ARMENIAN: \"name:hy\",\n  AZERBAIJANI: \"name:az\",\n  BASQUE: \"name:eu\",\n  BELORUSSIAN: \"name:be\",\n  BENGALI: \"name:bn\",\n  BOSNIAN: \"name:bs\",\n  BRETON: \"name:br\",\n  BULGARIAN: \"name:bg\",\n  CATALAN: \"name:ca\",\n  CHINESE: \"name:zh\",\n  TRADITIONAL_CHINESE: \"name:zh-Hant\",\n  SIMPLIFIED_CHINESE: \"name:zh-Hans\",\n  CORSICAN: \"name:co\",\n  CROATIAN: \"name:hr\",\n  CZECH: \"name:cs\",\n  DANISH: \"name:da\",\n  DUTCH: \"name:nl\",\n  ENGLISH: \"name:en\",\n  ESPERANTO: \"name:eo\",\n  ESTONIAN: \"name:et\",\n  FINNISH: \"name:fi\",\n  FRENCH: \"name:fr\",\n  FRISIAN: \"name:fy\",\n  GEORGIAN: \"name:ka\",\n  GERMAN: \"name:de\",\n  GREEK: \"name:el\",\n  HEBREW: \"name:he\",\n  HINDI: \"name:hi\",\n  HUNGARIAN: \"name:hu\",\n  ICELANDIC: \"name:is\",\n  INDONESIAN: \"name:id\",\n  IRISH: \"name:ga\",\n  ITALIAN: \"name:it\",\n  JAPANESE: \"name:ja\",\n  JAPANESE_HIRAGANA: \"name:ja-Hira\",\n  JAPANESE_KANA: \"name:ja_kana\",\n  JAPANESE_LATIN: \"name:ja_rm\",\n  JAPANESE_2018: \"name:ja-Latn\",\n  KANNADA: \"name:kn\",\n  KAZAKH: \"name:kk\",\n  KOREAN: \"name:ko\",\n  KOREAN_LATIN: \"name:ko-Latn\",\n  KURDISH: \"name:ku\",\n  ROMAN_LATIN: \"name:la\",\n  LATVIAN: \"name:lv\",\n  LITHUANIAN: \"name:lt\",\n  LUXEMBOURGISH: \"name:lb\",\n  MACEDONIAN: \"name:mk\",\n  MALAYALAM: \"name:ml\",\n  MALTESE: \"name:mt\",\n  NORWEGIAN: \"name:no\",\n  OCCITAN: \"name:oc\",\n  PERSIAN: \"name:fa\",\n  POLISH: \"name:pl\",\n  PORTUGUESE: \"name:pt\",\n  PUNJABI: \"name:pa\",\n  WESTERN_PUNJABI: \"name:pnb\",\n  ROMANIAN: \"name:ro\",\n  ROMANSH: \"name:rm\",\n  RUSSIAN: \"name:ru\",\n  SCOTTISH_GAELIC: \"name:gd\",\n  SERBIAN_CYRILLIC: \"name:sr\",\n  SERBIAN_LATIN: \"name:sr-Latn\",\n  SLOVAK: \"name:sk\",\n  SLOVENE: \"name:sl\",\n  SPANISH: \"name:es\",\n  SWEDISH: \"name:sv\",\n  TAMIL: \"name:ta\",\n  TELUGU: \"name:te\",\n  THAI: \"name:th\",\n  TURKISH: \"name:tr\",\n  UKRAINIAN: \"name:uk\",\n  URDU: \"name:ur\",\n  VIETNAMIAN_LATIN: \"name:vi\",\n  WELSH: \"name:cy\",\n} as const;\n\nconst languagesIsoSet = new Set(Object.values(Language) as Array<string>);\n\nfunction isLanguageSupported(lang: string): boolean {\n  return languagesIsoSet.has(lang);\n}\n\nconst languageCodeSet = new Set(Object.values(Language));\n\n/**\n * Type representing the key of the Language object\n */\ntype LanguageKey = keyof typeof Language;\n\ntype Values<T> = T[keyof T];\n\n/**\n * Built-in languages values as strings\n */\ntype LanguageString = Values<typeof Language>;\n\nfunction getBrowserLanguage(): LanguageString {\n  if (typeof navigator === \"undefined\") {\n    return `name:${\n      Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0]\n    }` as LanguageString;\n  }\n\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => `name:${l.split(\"-\")[0]}`)),\n  ).filter((l) => languageCodeSet.has(l as LanguageString));\n\n  return canditatelangs.length\n    ? (canditatelangs[0] as LanguageString)\n    : Language.LOCAL;\n}\n\nexport {\n  Language,\n  LanguageString,\n  LanguageKey,\n  getBrowserLanguage,\n  isLanguageSupported,\n};\n","import { Language } from \"./language\";\n\n/**\n * Some default settings for the SDK\n */\nconst defaults = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  rtlPluginURL:\n    \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: Language.STYLE,\n  secondaryLanguage: Language.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\",\n};\n\nObject.freeze(defaults);\n\nexport { defaults };\n","import EventEmitter from \"events\";\nimport { LanguageString } from \"./language\";\nimport { config as clientConfig, FetchFunction } from \"@maptiler/client\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Unit } from \"./unit\";\nimport { defaults } from \"./defaults\";\n\nexport const MAPTILER_SESSION_ID = uuidv4();\n\n/**\n * Configuration class for the SDK\n */\nclass SdkConfig extends EventEmitter {\n  /**\n   * The primary language. By default, the language of the web browser is used.\n   */\n  primaryLanguage: LanguageString = defaults.primaryLanguage;\n\n  /**\n   * The secondary language, to overwrite the default language defined in the map style.\n   * This settings is highly dependant on the style compatibility and may not work in most cases.\n   */\n  secondaryLanguage?: LanguageString;\n\n  /**\n   * Setting on whether of not the SDK runs with a session logic.\n   * A \"session\" is started at the initialization of the SDK and finished when the browser\n   * page is being refreshed.\n   * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n   * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n   */\n  session = true;\n\n  /**\n   * Unit to be used\n   */\n  private _unit: Unit = \"metric\";\n\n  /**\n   * MapTiler Cloud API key\n   */\n  private _apiKey = \"\";\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Set the unit system\n   */\n  set unit(u: Unit) {\n    this._unit = u;\n    this.emit(\"unit\", u);\n  }\n\n  /**\n   * Get the unit system\n   */\n  get unit(): Unit {\n    return this._unit;\n  }\n\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k: string) {\n    this._apiKey = k;\n    clientConfig.apiKey = k;\n    this.emit(\"apiKey\", k);\n  }\n\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey(): string {\n    return this._apiKey;\n  }\n\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f: FetchFunction) {\n    clientConfig.fetch = f;\n  }\n\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch(): FetchFunction | null {\n    return clientConfig.fetch;\n  }\n}\n\nconst config = new SdkConfig();\n\nexport { config, SdkConfig };\n","/**\n * This is an extension of MapLibre LogoControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class LogoControl extends maplibregl.LogoControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","import type { LogoOptions as LogoOptionsML } from \"maplibre-gl\";\nimport { defaults } from \"./defaults\";\nimport { LogoControl } from \"./LogoControl\";\nimport type { Map } from \"./Map\";\n\ntype LogoOptions = LogoOptionsML & {\n  logoURL?: string;\n  linkURL?: string;\n};\n\n/**\n * This LogoControl extends the MapLibre LogoControl but instead can use any image URL and\n * any link URL. By default this is using MapTiler logo and URL.\n */\nexport class MaptilerLogoControl extends LogoControl {\n  declare _compact: boolean;\n  private logoURL = \"\";\n  private linkURL = \"\";\n\n  constructor(options: LogoOptions = {}) {\n    super(options);\n\n    this.logoURL = options.logoURL ?? defaults.maptilerLogoURL;\n    this.linkURL = options.linkURL ?? defaults.maptilerURL;\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this._map = map;\n    this._compact = this.options.compact ?? false;\n    this._container = window.document.createElement(\"div\");\n    this._container.className = \"maplibregl-ctrl\";\n    const anchor = window.document.createElement(\"a\");\n    anchor.style.backgroundRepeat = \"no-repeat\";\n    anchor.style.cursor = \"pointer\";\n    anchor.style.display = \"block\";\n    anchor.style.height = \"23px\";\n    anchor.style.margin = \"0 0 -4px -4px\";\n    anchor.style.overflow = \"hidden\";\n    anchor.style.width = \"88px\";\n    anchor.style.backgroundImage = `url(${this.logoURL})`;\n    anchor.style.backgroundSize = \"100px 30px\";\n    anchor.style.width = \"100px\";\n    anchor.style.height = \"30px\";\n\n    anchor.target = \"_blank\";\n    anchor.rel = \"noopener\";\n    anchor.href = this.linkURL;\n    anchor.setAttribute(\"aria-label\", \"MapTiler logo\");\n    anchor.setAttribute(\"rel\", \"noopener\");\n    this._container.appendChild(anchor);\n    this._container.style.display = \"block\";\n\n    this._map.on(\"resize\", this._updateCompact);\n    this._updateCompact();\n\n    return this._container;\n  }\n}\n","import maplibregl from \"maplibre-gl\";\nimport type {\n  RequestParameters,\n  ResourceType,\n  RequestTransformFunction,\n} from \"maplibre-gl\";\nimport { defaults } from \"./defaults\";\nimport { config } from \"./config\";\nimport { MAPTILER_SESSION_ID } from \"./config\";\n\nexport function enableRTL() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if (maplibregl.getRTLTextPluginStatus() === \"unavailable\") {\n    maplibregl.setRTLTextPlugin(\n      defaults.rtlPluginURL,\n      (err?: Error | undefined) => {\n        if (err) console.error(err);\n      },\n      true, // Lazy load the plugin\n    );\n  }\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/util.ts#L223\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function bindAll(fns: Array<string>, context: any): void {\n  fns.forEach((fn) => {\n    if (typeof context[fn] !== \"function\") return;\n    context[fn] = context[fn].bind(context);\n  });\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/dom.ts#L22\nexport function DOMcreate<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  className?: string,\n  container?: HTMLElement,\n): HTMLElementTagNameMap[K] {\n  const el = window.document.createElement(tagName);\n  if (className !== undefined) el.className = className;\n  if (container) container.appendChild(el);\n  return el;\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/dom.ts#L111\nexport function DOMremove(node: HTMLElement) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * This function is meant to be used as transformRequest by any Map instance created.\n * It adds the session ID as well as the MapTiler Cloud key from the config to all the requests\n * performed on MapTiler Cloud servers.\n */\nexport function maptilerCloudTransformRequest(\n  url: string,\n  // keep incase we need it in the future\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _resourceType?: ResourceType,\n): RequestParameters {\n  let reqUrl = null;\n\n  try {\n    // The URL is expected to be absolute.\n    // Yet, if it's local we just return it without assuming a 'base' url (in the URL constructor)\n    // and we let the URL be locally resolved with a potential base path.\n    reqUrl = new URL(url);\n  } catch (e) {\n    return {\n      url,\n    };\n  }\n\n  if (reqUrl.host === defaults.maptilerApiHost) {\n    if (!reqUrl.searchParams.has(\"key\")) {\n      reqUrl.searchParams.append(\"key\", config.apiKey);\n    }\n\n    if (config.session) {\n      reqUrl.searchParams.append(\"mtsid\", MAPTILER_SESSION_ID);\n    }\n  }\n\n  return {\n    url: reqUrl.href,\n  };\n}\n\n/**\n * This combines a user-defined tranformRequest function (optionnal)\n * with the MapTiler Cloud-specific one: maptilerCloudTransformRequest\n */\nexport function combineTransformRequest(\n  userDefinedRTF?: RequestTransformFunction,\n): RequestTransformFunction {\n  return function (\n    url: string,\n    resourceType?: ResourceType,\n  ): RequestParameters {\n    if (userDefinedRTF !== undefined) {\n      const rp = userDefinedRTF(url, resourceType);\n      const rp2 = maptilerCloudTransformRequest(rp?.url ?? \"\");\n\n      return {\n        ...rp,\n        ...rp2,\n      };\n    } else {\n      return maptilerCloudTransformRequest(url);\n    }\n  };\n}\n\n/**\n * Generate a random string. Handy to create random IDs\n */\nexport function generateRandomString(): string {\n  return Math.random().toString(36).substring(2);\n}\n\n/**\n * Check if a given string is in a uuid format\n */\nexport function isUUID(s: string): boolean {\n  // Regular expression to check if string is a valid UUID\n  const regexExp =\n    /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi;\n  return regexExp.test(s);\n}\n\n/**\n * Attempt a JSON parse of a string but does not throw if the string is not valid JSON, returns `null` instead.\n */\nexport function jsonParseNoThrow<T>(doc: string): T | null {\n  try {\n    return JSON.parse(doc);\n  } catch (e) {\n    // pass\n  }\n\n  return null;\n}\n\n/**\n * Simple function to check if an object is a GeoJSON\n */\nexport function isValidGeoJSON<T>(obj: T & { type: string }): boolean {\n  if (typeof obj !== \"object\" || Array.isArray(obj) || obj === null)\n    return false;\n  if (!(\"type\" in obj)) return false;\n\n  const validTypes = [\n    \"Feature\",\n    \"FeatureCollection\",\n    \"Point\",\n    \"MultiPoint\",\n    \"LineString\",\n    \"MultiLineString\",\n    \"Polygon\",\n    \"MultiPolygon\",\n    \"GeometryCollection\",\n  ];\n\n  if (validTypes.includes(obj.type)) return true;\n  return false;\n}\n","import {\n  MapStyle,\n  ReferenceMapStyle,\n  MapStyleVariant,\n  mapStylePresetList,\n  expandMapStyle,\n} from \"@maptiler/client\";\n\nexport function styleToStyle(\n  style:\n    | string\n    | ReferenceMapStyle\n    | MapStyleVariant\n    | maplibregl.StyleSpecification\n    | null\n    | undefined,\n): string | maplibregl.StyleSpecification {\n  if (!style) {\n    return MapStyle[\n      mapStylePresetList[0].referenceStyleID as keyof typeof MapStyle\n    ]\n      .getDefaultVariant()\n      .getExpandedStyleURL();\n  }\n\n  // If the provided style is a shorthand (eg. \"streets-v2\") or a full style URL\n  if (typeof style === \"string\" || style instanceof String) {\n    if (!style.startsWith(\"http\") && style.toLowerCase().includes(\".json\")) {\n      // If a style does not start by http but still contains the extension \".json\"\n      // we assume it's a relative path to a style json file\n      return style as string;\n    } else {\n      return expandMapStyle(style);\n    }\n  }\n\n  if (style instanceof MapStyleVariant) {\n    return style.getExpandedStyleURL();\n  }\n\n  if (style instanceof ReferenceMapStyle) {\n    return (style.getDefaultVariant() as MapStyleVariant).getExpandedStyleURL();\n  }\n\n  return style as maplibregl.StyleSpecification;\n}\n","import { bindAll, DOMcreate, DOMremove } from \"./tools\";\n\nimport type { Map } from \"./Map\";\nimport type { IControl } from \"maplibre-gl\";\n\n/**\n * A `MaptilerTerrainControl` control adds a button to turn terrain on and off\n * by triggering the terrain logic that is already deployed in the Map object.\n */\nexport class MaptilerTerrainControl implements IControl {\n  _map!: Map;\n  _container!: HTMLElement;\n  _terrainButton!: HTMLButtonElement;\n\n  constructor() {\n    bindAll([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n\n  onAdd(map: Map): HTMLElement {\n    this._map = map;\n    this._container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    this._terrainButton = DOMcreate(\n      \"button\",\n      \"maplibregl-ctrl-terrain\",\n      this._container,\n    );\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\n      \"aria-hidden\",\n      \"true\",\n    );\n    this._terrainButton.type = \"button\";\n    this._terrainButton.addEventListener(\"click\", this._toggleTerrain);\n\n    this._updateTerrainIcon();\n    this._map.on(\"terrain\", this._updateTerrainIcon);\n    return this._container;\n  }\n\n  onRemove(): void {\n    DOMremove(this._container);\n    this._map.off(\"terrain\", this._updateTerrainIcon);\n    // @ts-expect-error: map will only be undefined on remove\n    this._map = undefined;\n  }\n\n  _toggleTerrain(): void {\n    if (this._map.hasTerrain()) {\n      this._map.disableTerrain();\n    } else {\n      this._map.enableTerrain();\n    }\n\n    this._updateTerrainIcon();\n  }\n\n  _updateTerrainIcon(): void {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\");\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\");\n    // if (this._map.terrain) {\n    if (this._map.hasTerrain()) {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.disableTerrain\",\n      );\n    } else {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\");\n      this._terrainButton.title = this._map._getUIString(\n        \"TerrainControl.enableTerrain\",\n      );\n    }\n  }\n}\n","/**\n * This is an extension of MapLibre NavigationControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class NavigationControl extends maplibregl.NavigationControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","import { NavigationControl } from \"./NavigationControl\";\n\ntype HTMLButtonElementPlus = HTMLButtonElement & {\n  clickFunction: (e?: Event) => unknown;\n};\n\nexport class MaptilerNavigationControl extends NavigationControl {\n  constructor() {\n    super({\n      showCompass: true,\n      showZoom: true,\n      visualizePitch: true,\n    });\n\n    // Removing the default click event\n    this._compass.removeEventListener(\n      \"click\",\n      (this._compass as HTMLButtonElementPlus).clickFunction,\n    );\n\n    // Adding custom click event\n    this._compass.addEventListener(\"click\", (e) => {\n      {\n        const currentPitch = this._map.getPitch();\n        if (currentPitch === 0) {\n          this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) });\n        } else {\n          if (this.options.visualizePitch) {\n            this._map.resetNorthPitch({}, { originalEvent: e });\n          } else {\n            this._map.resetNorth({}, { originalEvent: e });\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(\n    className: string,\n    fn: (e?: Event) => unknown,\n  ): HTMLButtonElementPlus {\n    const button = super._createButton(className, fn) as HTMLButtonElementPlus;\n    button.clickFunction = fn;\n    return button;\n  }\n\n  /**\n   * Overloading: Limit how flat the compass icon can get\n   */\n  _rotateCompassArrow = () => {\n    const rotate = this.options.visualizePitch\n      ? `scale(${Math.min(\n          1.5,\n          1 /\n            Math.pow(\n              Math.cos(this._map.transform.pitch * (Math.PI / 180)),\n              0.5,\n            ),\n        )}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${\n          this._map.transform.angle * (180 / Math.PI)\n        }deg)`\n      : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n\n    this._compassIcon.style.transform = rotate;\n  };\n}\n","/**\n * This is an extension of MapLibre GeolocateControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class GeolocateControl extends maplibregl.GeolocateControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","import type { LngLatLike, MapLibreEvent } from \"maplibre-gl\";\nimport maplibregl from \"maplibre-gl\";\nimport { GeolocateControl } from \"./GeolocateControl\";\nimport { DOMcreate } from \"./tools\";\n\nconst Marker = maplibregl.Marker;\nconst LngLat = maplibregl.LngLat;\nconst LngLatBounds = maplibregl.LngLatBounds;\n\ntype MoveEndEvent = MapLibreEvent<\n  MouseEvent | TouchEvent | WheelEvent | undefined\n> & { geolocateSource?: boolean };\n\n/**\n * The MaptilerGeolocateControl is an extension of the original GeolocateControl\n * with a few changes. In this version, the active mode persists as long as the\n * location is still centered. This means it's robust to rotation, pitch and zoom.\n *\n */\nexport class MaptilerGeolocateControl extends GeolocateControl {\n  private lastUpdatedCenter = new LngLat(0, 0);\n\n  /**\n   * Update the camera location to center on the current position\n   *\n   * @param {Position} position the Geolocation API Position\n   * @private\n   */\n  _updateCamera = (position: GeolocationPosition) => {\n    const center = new LngLat(\n      position.coords.longitude,\n      position.coords.latitude,\n    );\n    const radius = position.coords.accuracy;\n    const bearing = this._map.getBearing();\n    const options = {\n      bearing,\n      ...this.options.fitBoundsOptions,\n      linear: true,\n    };\n\n    const currentMapZoom = this._map.getZoom();\n\n    if (currentMapZoom > (this.options?.fitBoundsOptions?.maxZoom ?? 30)) {\n      options.zoom = currentMapZoom;\n    }\n\n    this._map.fitBounds(LngLatBounds.fromLngLat(center, radius), options, {\n      geolocateSource: true, // tag this camera change so it won't cause the control to change to background state\n    });\n\n    let hasFittingBeenDisrupted = false;\n\n    const flagFittingDisruption = () => {\n      hasFittingBeenDisrupted = true;\n    };\n\n    this._map.once(\"click\", flagFittingDisruption);\n    this._map.once(\"dblclick\", flagFittingDisruption);\n    this._map.once(\"dragstart\", flagFittingDisruption);\n    this._map.once(\"mousedown\", flagFittingDisruption);\n    this._map.once(\"touchstart\", flagFittingDisruption);\n    this._map.once(\"wheel\", flagFittingDisruption);\n\n    this._map.once(\"moveend\", () => {\n      // Removing the events if not used\n      this._map.off(\"click\", flagFittingDisruption);\n      this._map.off(\"dblclick\", flagFittingDisruption);\n      this._map.off(\"dragstart\", flagFittingDisruption);\n      this._map.off(\"mousedown\", flagFittingDisruption);\n      this._map.off(\"touchstart\", flagFittingDisruption);\n      this._map.off(\"wheel\", flagFittingDisruption);\n\n      if (hasFittingBeenDisrupted) {\n        return;\n      }\n\n      this.lastUpdatedCenter = this._map.getCenter();\n    });\n  };\n\n  _setupUI = (supported: boolean) => {\n    this.lastUpdatedCenter = this._map.getCenter();\n\n    this._container.addEventListener(\"contextmenu\", (e: MouseEvent) =>\n      e.preventDefault(),\n    );\n    this._geolocateButton = DOMcreate(\n      \"button\",\n      \"maplibregl-ctrl-geolocate\",\n      this._container,\n    );\n    DOMcreate(\n      \"span\",\n      \"maplibregl-ctrl-icon\",\n      this._geolocateButton,\n    ).setAttribute(\"aria-hidden\", \"true\");\n    this._geolocateButton.type = \"button\";\n\n    if (supported === false) {\n      // warnOnce('Geolocation support is not available so the GeolocateControl will be disabled.');\n      const title = this._map._getUIString(\n        \"GeolocateControl.LocationNotAvailable\",\n      );\n      this._geolocateButton.disabled = true;\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    } else {\n      const title = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    }\n\n    if (this.options.trackUserLocation) {\n      this._geolocateButton.setAttribute(\"aria-pressed\", \"false\");\n      this._watchState = \"OFF\";\n    }\n\n    // when showUserLocation is enabled, keep the Geolocate button disabled until the device location marker is setup on the map\n    if (this.options.showUserLocation) {\n      this._dotElement = DOMcreate(\"div\", \"maplibregl-user-location-dot\");\n      this._userLocationDotMarker = new Marker({ element: this._dotElement });\n\n      this._circleElement = DOMcreate(\n        \"div\",\n        \"maplibregl-user-location-accuracy-circle\",\n      );\n      this._accuracyCircleMarker = new Marker({\n        element: this._circleElement,\n        pitchAlignment: \"map\",\n      });\n\n      if (this.options.trackUserLocation) this._watchState = \"OFF\";\n\n      this._map.on(\"move\", this._onZoom);\n    }\n\n    this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this));\n\n    this._setup = true;\n\n    // when the camera is changed (and it's not as a result of the Geolocation Control) change\n    // the watch mode to background watch, so that the marker is updated but not the camera.\n    // Addition: Yet the status change does not occur if the ditance it has moved to is less than\n    // one meter from the last auto-updated position. This is to guarrantee that if the move\n    // is a zoom, rotation or pitch (where the center stays the same) then we can keep the ACTIVE_LOCK\n    // mode ON.\n    if (this.options.trackUserLocation) {\n      this._map.on(\"moveend\", (event: MoveEndEvent) => {\n        const fromResize =\n          event.originalEvent && event.originalEvent.type === \"resize\";\n        const movingDistance = this.lastUpdatedCenter.distanceTo(\n          this._map.getCenter(),\n        );\n\n        if (\n          !event.geolocateSource &&\n          this._watchState === \"ACTIVE_LOCK\" &&\n          !fromResize &&\n          movingDistance > 1\n        ) {\n          this._watchState = \"BACKGROUND\";\n          this._geolocateButton.classList.add(\n            \"maplibregl-ctrl-geolocate-background\",\n          );\n          this._geolocateButton.classList.remove(\n            \"maplibregl-ctrl-geolocate-active\",\n          );\n\n          this.fire(new Event(\"trackuserlocationend\"));\n        }\n      });\n    }\n  };\n\n  _updateCircleRadius() {\n    if (\n      this._watchState !== \"BACKGROUND\" &&\n      this._watchState !== \"ACTIVE_LOCK\"\n    ) {\n      return;\n    }\n\n    const lastKnownLocation: LngLatLike = [\n      this._lastKnownPosition.coords.longitude,\n      this._lastKnownPosition.coords.latitude,\n    ];\n\n    const projectedLocation = this._map.project(lastKnownLocation);\n    const a = this._map.unproject([projectedLocation.x, projectedLocation.y]);\n    const b = this._map.unproject([\n      projectedLocation.x + 20,\n      projectedLocation.y,\n    ]);\n    const metersPerPixel = a.distanceTo(b) / 20;\n\n    const circleDiameter = Math.ceil((2.0 * this._accuracy) / metersPerPixel);\n    this._circleElement.style.width = `${circleDiameter}px`;\n    this._circleElement.style.height = `${circleDiameter}px`;\n  }\n\n  _onZoom = () => {\n    if (this.options.showUserLocation && this.options.showAccuracyCircle) {\n      this._updateCircleRadius();\n    }\n  };\n}\n","/**\n * This is an extension of MapLibre AttributionControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class AttributionControl extends maplibregl.AttributionControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre ScaleControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class ScaleControl extends maplibregl.ScaleControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre FullscreenControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class FullscreenControl extends maplibregl.FullscreenControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension adds support for adding a minimap to one of the map's control containers.\n */\n\nimport { Map } from \"./Map\";\nimport { DOMcreate, DOMremove } from \"./tools\";\n\nimport type {\n  ControlPosition,\n  CustomLayerInterface,\n  FillLayerSpecification,\n  FilterSpecification,\n  GeoJSONSource,\n  IControl,\n  LayerSpecification,\n  LineLayerSpecification,\n  SourceSpecification,\n  StyleOptions,\n  StyleSetterOptions,\n  StyleSpecification,\n  StyleSwapOptions,\n} from \"maplibre-gl\";\nimport type { MapOptions } from \"./Map\";\nimport type { MapStyleVariant, ReferenceMapStyle } from \"@maptiler/client\";\n\nexport interface ParentRect {\n  lineLayout: LineLayerSpecification[\"layout\"];\n  linePaint: LineLayerSpecification[\"paint\"];\n  fillPaint: FillLayerSpecification[\"paint\"];\n}\n\nexport interface MinimapOptionsInput {\n  /**\n   * Style of the map. Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  style?: ReferenceMapStyle | MapStyleVariant | StyleSpecification | string;\n\n  /**\n   * Set the zoom difference between the parent and the minimap\n   * If the parent is zoomed to 10 and the minimap is zoomed to 8, the zoomAdjust should be 2\n   * Default: -4\n   */\n  zoomAdjust?: number;\n\n  /** Set a zoom of the minimap and don't allow any future changes */\n  lockZoom?: number;\n\n  /** Adjust the pitch only if the user requests */\n  pitchAdjust?: boolean;\n\n  /** Set CSS properties of the container using object key-values */\n  containerStyle?: Record<string, string>;\n\n  /** Set the position of the minimap at either \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\" */\n  position?: ControlPosition;\n\n  /** Set the parentRect fill and/or line options */\n  parentRect?: ParentRect;\n}\n\nexport interface MinimapOptions extends MapOptions {\n  zoomAdjust: number;\n  pitchAdjust: boolean;\n  containerStyle: Record<string, string>;\n  parentRect?: ParentRect;\n}\n\nexport default class Minimap implements IControl {\n  #options: MinimapOptions;\n  map!: Map;\n  #parentMap!: Map;\n  #container!: HTMLElement;\n  #canvasContainer!: HTMLElement;\n  #parentRect?: GeoJSON.Feature<GeoJSON.Polygon>;\n  #differentStyle = false;\n  #desync?: () => void;\n  constructor(options: MinimapOptionsInput, mapOptions: MapOptions) {\n    // check if the style is different\n    if (options.style !== undefined) this.#differentStyle = true;\n    // set options\n    this.#options = {\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\",\n      // inherit map options\n      ...mapOptions,\n      // override any lingering control options\n      forceNoAttributionControl: true,\n      attributionControl: false,\n      navigationControl: false,\n      geolocateControl: false,\n      maptilerLogo: false,\n      minimap: false,\n      hash: false,\n      pitchAdjust: false,\n      // override map options with new user defined minimap options\n      ...options,\n      containerStyle: {\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\",\n        ...(options.containerStyle ?? {}),\n      },\n    };\n    if (options.lockZoom !== undefined) {\n      this.#options.minZoom = options.lockZoom;\n      this.#options.maxZoom = options.lockZoom;\n    }\n  }\n\n  setStyle(\n    style:\n      | null\n      | ReferenceMapStyle\n      | MapStyleVariant\n      | StyleSpecification\n      | string,\n    options?: StyleSwapOptions & StyleOptions,\n  ): void {\n    if (!this.#differentStyle) this.map.setStyle(style, options);\n    this.#setParentBounds();\n  }\n\n  addLayer(\n    layer:\n      | (LayerSpecification & {\n          source?: string | SourceSpecification;\n        })\n      | CustomLayerInterface,\n    beforeId?: string,\n  ): Map {\n    if (!this.#differentStyle) this.map.addLayer(layer, beforeId);\n    this.#setParentBounds();\n    return this.map;\n  }\n\n  moveLayer(id: string, beforeId?: string): Map {\n    if (!this.#differentStyle) this.map.moveLayer(id, beforeId);\n    this.#setParentBounds();\n    return this.map;\n  }\n\n  removeLayer(id: string): this {\n    if (!this.#differentStyle) this.map.removeLayer(id);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this {\n    if (!this.#differentStyle)\n      this.map.setLayerZoomRange(layerId, minzoom, maxzoom);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setFilter(\n    layerId: string,\n    filter?: FilterSpecification | null,\n    options?: StyleSetterOptions,\n  ): this {\n    if (!this.#differentStyle) this.map.setFilter(layerId, filter, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setPaintProperty(\n    layerId: string,\n    name: string,\n    // maplibre controlled types\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value: any,\n    options?: StyleSetterOptions,\n  ): this {\n    if (!this.#differentStyle)\n      this.map.setPaintProperty(layerId, name, value, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setLayoutProperty(\n    layerId: string,\n    name: string,\n    // maplibre controlled types\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value: any,\n    options?: StyleSetterOptions,\n  ): this {\n    if (!this.#differentStyle)\n      this.map.setLayoutProperty(layerId, name, value, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setGlyphs(glyphsUrl: string | null, options?: StyleSetterOptions): this {\n    if (!this.#differentStyle) this.map.setGlyphs(glyphsUrl, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  onAdd(parentMap: Map): HTMLElement {\n    this.#parentMap = parentMap;\n    //prep the container\n    this.#container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    // adjust styling\n    for (const [key, value] of Object.entries(this.#options.containerStyle)) {\n      this.#container.style.setProperty(key, value);\n    }\n    this.#options.container = this.#container;\n    this.#options.zoom = parentMap.getZoom() + this.#options.zoomAdjust ?? -4;\n    this.map = new Map(this.#options);\n\n    // NOTE: For some reason the DOM doesn't properly update it's size in time\n    // for the minimap to convey it's size to the canvas.\n    this.map.once(\"style.load\", () => {\n      this.map.resize();\n    });\n\n    // set options\n    this.map.once(\"load\", () => {\n      this.#addParentRect(this.#options.parentRect);\n      this.#desync = this.#syncMaps();\n    });\n\n    return this.#container;\n  }\n\n  onRemove(): void {\n    this.#desync?.();\n    DOMremove(this.#container);\n  }\n\n  #addParentRect(rect?: ParentRect): void {\n    if (\n      rect === undefined ||\n      (rect.linePaint === undefined && rect.fillPaint === undefined)\n    ) {\n      return;\n    }\n    this.#parentRect = {\n      type: \"Feature\",\n      properties: {\n        name: \"parentRect\",\n      },\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [[[], [], [], [], []]],\n      },\n    };\n\n    this.map.addSource(\"parentRect\", {\n      type: \"geojson\",\n      data: this.#parentRect,\n    });\n    if (rect.lineLayout !== undefined || rect.linePaint !== undefined) {\n      this.map.addLayer({\n        id: \"parentRectOutline\",\n        type: \"line\",\n        source: \"parentRect\",\n        layout: {\n          ...rect.lineLayout,\n        },\n        paint: {\n          \"line-color\": \"#FFF\",\n          \"line-width\": 1,\n          \"line-opacity\": 0.85,\n          ...rect.linePaint,\n        },\n      });\n    }\n    if (rect.fillPaint !== undefined) {\n      this.map.addLayer({\n        id: \"parentRectFill\",\n        type: \"fill\",\n        source: \"parentRect\",\n        layout: {},\n        paint: {\n          \"fill-color\": \"#08F\",\n          \"fill-opacity\": 0.135,\n          ...rect.fillPaint,\n        },\n      });\n    }\n\n    this.#setParentBounds();\n  }\n\n  #setParentBounds() {\n    if (this.#parentRect === undefined) return;\n\n    const { devicePixelRatio } = window;\n    const canvas = this.#parentMap.getCanvas();\n    const width = canvas.width / devicePixelRatio;\n    const height = canvas.height / devicePixelRatio;\n\n    // Get coordinates for all four corners\n    const unproject = this.#parentMap.unproject.bind(this.#parentMap);\n    const northWest = unproject([0, 0]);\n    const northEast = unproject([width, 0]);\n    const southWest = unproject([0, height]);\n    const southEast = unproject([width, height]);\n\n    this.#parentRect.geometry.coordinates = [\n      [\n        southWest.toArray(),\n        southEast.toArray(),\n        northEast.toArray(),\n        northWest.toArray(),\n        southWest.toArray(),\n      ],\n    ];\n\n    const source = this.map.getSource(\"parentRect\") as GeoJSONSource;\n    source.setData(this.#parentRect);\n  }\n\n  #syncMaps(): () => void {\n    const { pitchAdjust } = this.#options;\n    // syncing callbacks\n    const parentCallback = () => {\n      sync(\"parent\");\n    };\n    const minimapCallback = () => {\n      sync(\"minimap\");\n    };\n\n    // on off functions\n    const on = () => {\n      this.#parentMap.on(\"move\", parentCallback);\n      this.map.on(\"move\", minimapCallback);\n    };\n    const off = () => {\n      this.#parentMap.off(\"move\", parentCallback);\n      this.map.off(\"move\", minimapCallback);\n    };\n\n    // When one map moves, we turn off the movement listeners\n    // on all the maps, move it, then turn the listeners on again\n    const sync = (which: \"parent\" | \"minimap\") => {\n      // OFF\n      off();\n\n      // MOVE\n      const from = which === \"parent\" ? this.#parentMap : this.map;\n      const to = which === \"parent\" ? this.map : this.#parentMap;\n      const center = from.getCenter();\n      const zoom =\n        from.getZoom() +\n        (this.#options.zoomAdjust ?? -4) * (which === \"parent\" ? 1 : -1);\n      const bearing = from.getBearing();\n      const pitch = from.getPitch();\n      to.jumpTo({\n        center,\n        zoom,\n        bearing,\n        pitch: pitchAdjust ? pitch : 0,\n      });\n      // update parent rect\n      this.#setParentBounds();\n\n      // ON\n      on();\n    };\n\n    on();\n    // return a desync function\n    return () => {\n      off();\n    };\n  }\n}\n","import maplibregl from \"maplibre-gl\";\nimport { Base64 } from \"js-base64\";\nimport type {\n  StyleSpecification,\n  MapOptions as MapOptionsML,\n  ControlPosition,\n  StyleSwapOptions,\n  StyleOptions,\n  MapDataEvent,\n  Tile,\n  RasterDEMSourceSpecification,\n  RequestTransformFunction,\n  Source,\n  LayerSpecification,\n  SourceSpecification,\n  CustomLayerInterface,\n  FilterSpecification,\n  StyleSetterOptions,\n  ExpressionSpecification,\n} from \"maplibre-gl\";\nimport { ReferenceMapStyle, MapStyleVariant } from \"@maptiler/client\";\nimport { config, MAPTILER_SESSION_ID, SdkConfig } from \"./config\";\nimport { defaults } from \"./defaults\";\nimport { MaptilerLogoControl } from \"./MaptilerLogoControl\";\nimport { combineTransformRequest, enableRTL } from \"./tools\";\nimport {\n  getBrowserLanguage,\n  isLanguageSupported,\n  Language,\n  LanguageString,\n} from \"./language\";\nimport { styleToStyle } from \"./mapstyle\";\nimport { MaptilerTerrainControl } from \"./MaptilerTerrainControl\";\nimport { MaptilerNavigationControl } from \"./MaptilerNavigationControl\";\nimport { geolocation } from \"@maptiler/client\";\nimport { MaptilerGeolocateControl } from \"./MaptilerGeolocateControl\";\nimport { AttributionControl } from \"./AttributionControl\";\nimport { ScaleControl } from \"./ScaleControl\";\nimport { FullscreenControl } from \"./FullscreenControl\";\n\nimport Minimap from \"./Minimap\";\nimport type { MinimapOptionsInput } from \"./Minimap\";\n\nexport type LoadWithTerrainEvent = {\n  type: \"loadWithTerrain\";\n  target: Map;\n  terrain: {\n    source: string;\n    exaggeration: number;\n  };\n};\n\nexport const GeolocationType: {\n  POINT: \"POINT\";\n  COUNTRY: \"COUNTRY\";\n} = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\",\n} as const;\n\ntype MapTerrainDataEvent = MapDataEvent & {\n  isSourceLoaded: boolean;\n  tile: Tile;\n  sourceId: string;\n  source: RasterDEMSourceSpecification;\n};\n\n/**\n * Options to provide to the `Map` constructor\n */\nexport type MapOptions = Omit<MapOptionsML, \"style\" | \"maplibreLogo\"> & {\n  /**\n   * Style of the map. Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  style?: ReferenceMapStyle | MapStyleVariant | StyleSpecification | string;\n\n  /**\n   * Define the language of the map. This can be done directly with a language ISO code (eg. \"en\")\n   * or with a built-in shorthand (eg. Language.ENGLISH).\n   * Note that this is equivalent to setting the `config.primaryLanguage` and will overwrite it.\n   */\n  language?: LanguageString;\n\n  /**\n   * Define the MapTiler Cloud API key to be used. This is strictly equivalent to setting\n   * `config.apiKey` and will overwrite it.\n   */\n  apiKey?: string;\n\n  /**\n   * Shows or hides the MapTiler logo in the bottom left corner.\n   *\n   * For paid plans:\n   * - `true` shows MapTiler logo\n   * - `false` hodes MapTiler logo\n   * - default: `false` (hide)\n   *\n   * For free plans: MapTiler logo always shows, regardless of the value.\n   */\n  maptilerLogo?: boolean;\n\n  /**\n   * Enables 3D terrain if `true`. (default: `false`)\n   */\n  terrain?: boolean;\n\n  /**\n   * Exaggeration factor of the terrain. (default: `1`, no exaggeration)\n   */\n  terrainExaggeration?: number;\n\n  /**\n   * Show the navigation control. (default: `true`, will hide if `false`)\n   */\n  navigationControl?: boolean | ControlPosition;\n\n  /**\n   * Show the terrain control. (default: `false`, will show if `true`)\n   */\n  terrainControl?: boolean | ControlPosition;\n\n  /**\n   * Show the geolocate control. (default: `true`, will hide if `false`)\n   */\n  geolocateControl?: boolean | ControlPosition;\n\n  /**\n   * Show the scale control. (default: `false`, will show if `true`)\n   */\n  scaleControl?: boolean | ControlPosition;\n\n  /**\n   * Show the full screen control. (default: `false`, will show if `true`)\n   */\n  fullscreenControl?: boolean | ControlPosition;\n\n  /**\n   * Display a minimap in a user defined corner of the map. (default: `bottom-left` corner)\n   * If set to true, the map will assume it is a minimap and forego the attribution control.\n   */\n  minimap?: boolean | ControlPosition | MinimapOptionsInput;\n\n  /**\n   * attributionControl\n   */\n  forceNoAttributionControl?: boolean;\n\n  /**\n   * Method to position the map at a given geolocation. Only if:\n   * - `hash` is `false`\n   * - `center` is not provided\n   *\n   * If the value is `true` of `\"POINT\"` (given by `GeolocationType.POINT`) then the positionning uses the MapTiler Cloud\n   * Geolocation to find the non-GPS location point.\n   * The zoom level can be provided in the `Map` constructor with the `zoom` option or will be `13` if not provided.\n   *\n   * If the value is `\"COUNTRY\"` (given by `GeolocationType.COUNTRY`) then the map is centered around the bounding box of the country.\n   * In this case, the `zoom` option will be ignored.\n   *\n   * If the value is `false`, no geolocation is performed and the map centering and zooming depends on other options or on\n   * the built-in defaults.\n   *\n   * If this option is non-false and the options `center` is also provided, then `center` prevails.\n   *\n   * Default: `false`\n   */\n  geolocate?: (typeof GeolocationType)[keyof typeof GeolocationType] | boolean;\n};\n\n/**\n * The Map class can be instanciated to display a map in a `<div>`\n */\nexport class Map extends maplibregl.Map {\n  private isTerrainEnabled = false;\n  private terrainExaggeration = 1;\n  private primaryLanguage: LanguageString;\n  private terrainGrowing = false;\n  private terrainFlattening = false;\n  private minimap?: Minimap;\n  private forceLanguageUpdate: boolean;\n  private languageAlwaysBeenStyle: boolean;\n  private isReady: boolean = false;\n\n  constructor(options: MapOptions) {\n    if (options.apiKey) {\n      config.apiKey = options.apiKey;\n    }\n\n    const style = styleToStyle(options.style);\n    const hashPreConstructor = location.hash;\n\n    if (!config.apiKey) {\n      console.warn(\n        \"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\",\n      );\n    }\n\n    // calling the map constructor with full length style\n    super({\n      ...options,\n      style,\n      maplibreLogo: false,\n      transformRequest: combineTransformRequest(options.transformRequest),\n    });\n\n    this.primaryLanguage = options.language ?? config.primaryLanguage;\n    this.forceLanguageUpdate =\n      this.primaryLanguage === Language.STYLE ||\n      this.primaryLanguage === Language.STYLE_LOCK\n        ? false\n        : true;\n    this.languageAlwaysBeenStyle = this.primaryLanguage === Language.STYLE;\n    this.terrainExaggeration =\n      options.terrainExaggeration ?? this.terrainExaggeration;\n\n    // Map centering and geolocation\n    this.once(\"styledata\", async () => {\n      // Not using geolocation centering if...\n\n      // the geolcoate option is not provided or is falsy\n      if (!options.geolocate) {\n        return;\n      }\n\n      // ... a center is provided in options\n      if (options.center) {\n        return;\n      }\n\n      // ... the hash option is enabled and a hash is present in the URL\n      if (options.hash && !!hashPreConstructor) {\n        return;\n      }\n\n      // If the geolocation is set to COUNTRY:\n      try {\n        if (options.geolocate === GeolocationType.COUNTRY) {\n          await this.fitToIpBounds();\n          return;\n        }\n      } catch (e) {\n        // not raising\n        console.warn((e as Error).message);\n      }\n\n      // As a fallback, we want to center the map on the visitor. First with IP geolocation...\n      let ipLocatedCameraHash: string;\n      try {\n        await this.centerOnIpPoint(options.zoom);\n        ipLocatedCameraHash = this.getCameraHash();\n      } catch (e) {\n        // not raising\n        console.warn((e as Error).message);\n      }\n\n      // A more precise localization\n\n      // This more advanced localization is commented out because the easeTo animation\n      // triggers an error if the terrain grow is enabled (due to being nable to project the center while moving)\n\n      // Then, the get a more precise location, we rely on the browser location, but only if it was already granted\n      // before (we don't want to ask wih a popup at launch time)\n      const locationResult = await navigator.permissions.query({\n        name: \"geolocation\",\n      });\n\n      if (locationResult.state === \"granted\") {\n        navigator.geolocation.getCurrentPosition(\n          // success callback\n          (data) => {\n            // If the user has already moved since the ip location, then we no longer want to move the center\n            if (ipLocatedCameraHash !== this.getCameraHash()) {\n              return;\n            }\n\n            if (this.terrain) {\n              this.easeTo({\n                center: [data.coords.longitude, data.coords.latitude],\n                zoom: options.zoom || 12,\n                duration: 2000,\n              });\n            } else {\n              this.once(\"terrain\", () => {\n                this.easeTo({\n                  center: [data.coords.longitude, data.coords.latitude],\n                  zoom: options.zoom || 12,\n                  duration: 2000,\n                });\n              });\n            }\n          },\n\n          // error callback\n          null,\n\n          // options\n          {\n            maximumAge: 24 * 3600 * 1000, // a day in millisec\n            timeout: 5000, // milliseconds\n            enableHighAccuracy: false,\n          },\n        );\n      }\n    });\n\n    // If the config includes language changing, we must update the map language\n    this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    });\n\n    // this even is in charge of reaplying the terrain elevation after the\n    // style has changed because depending on the src/tgt style,\n    // the style logic is not always able to resolve the application of terrain\n    this.on(\"styledata\", () => {\n      // the styling resolver did no manage to reaply the terrain,\n      // so let's reload it\n      if (this.getTerrain() === null && this.isTerrainEnabled) {\n        this.enableTerrain(this.terrainExaggeration);\n      }\n    });\n\n    // load the Right-to-Left text plugin (will happen only once)\n    this.once(\"load\", async () => {\n      enableRTL();\n    });\n\n    // Update logo and attibution\n    this.once(\"load\", async () => {\n      let tileJsonContent = { logo: null };\n\n      try {\n        const possibleSources = Object.keys(this.style.sourceCaches)\n          .map((sourceName) => this.getSource(sourceName))\n          .filter(\n            (s: Source | undefined) =>\n              s &&\n              \"url\" in s &&\n              typeof s.url === \"string\" &&\n              s?.url.includes(\"tiles.json\"),\n          );\n\n        const styleUrl = new URL(\n          (possibleSources[0] as maplibregl.VectorTileSource).url,\n        );\n\n        if (!styleUrl.searchParams.has(\"key\")) {\n          styleUrl.searchParams.append(\"key\", config.apiKey);\n        }\n\n        const tileJsonRes = await fetch(styleUrl.href);\n        tileJsonContent = await tileJsonRes.json();\n      } catch (e) {\n        // No tiles.json found (should not happen on maintained styles)\n      }\n\n      // The attribution and logo must show when required\n      if (options.forceNoAttributionControl !== true) {\n        if (\"logo\" in tileJsonContent && tileJsonContent.logo) {\n          const logoURL: string = tileJsonContent.logo;\n\n          this.addControl(\n            new MaptilerLogoControl({ logoURL }),\n            options.logoPosition,\n          );\n\n          // if attribution in option is `false` but the the logo shows up in the tileJson, then the attribution must show anyways\n          if (options.attributionControl === false) {\n            this.addControl(\n              new AttributionControl({\n                customAttribution: options.customAttribution,\n              }),\n            );\n          }\n        } else if (options.maptilerLogo) {\n          this.addControl(new MaptilerLogoControl(), options.logoPosition);\n        }\n      }\n\n      // the other controls at init time but be after\n      // (due to the async nature of logo control)\n\n      // By default, no scale control\n      if (options.scaleControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.scaleControl === true || options.scaleControl === undefined\n            ? \"bottom-right\"\n            : options.scaleControl\n        ) as ControlPosition;\n\n        const scaleControl = new ScaleControl({ unit: config.unit });\n        this.addControl(scaleControl, position);\n        config.on(\"unit\", (unit) => {\n          scaleControl.setUnit(unit);\n        });\n      }\n\n      if (options.navigationControl !== false) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.navigationControl === true ||\n          options.navigationControl === undefined\n            ? \"top-right\"\n            : options.navigationControl\n        ) as ControlPosition;\n        this.addControl(new MaptilerNavigationControl(), position);\n      }\n\n      if (options.geolocateControl !== false) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.geolocateControl === true ||\n          options.geolocateControl === undefined\n            ? \"top-right\"\n            : options.geolocateControl\n        ) as ControlPosition;\n\n        this.addControl(\n          // new maplibregl.GeolocateControl({\n          new MaptilerGeolocateControl({\n            positionOptions: {\n              enableHighAccuracy: true,\n              maximumAge: 0,\n              timeout: 6000 /* 6 sec */,\n            },\n            fitBoundsOptions: {\n              maxZoom: 15,\n            },\n            trackUserLocation: true,\n            showAccuracyCircle: true,\n            showUserLocation: true,\n          }),\n          position,\n        );\n      }\n\n      if (options.terrainControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.terrainControl === true ||\n          options.terrainControl === undefined\n            ? \"top-right\"\n            : options.terrainControl\n        ) as ControlPosition;\n        this.addControl(new MaptilerTerrainControl(), position);\n      }\n\n      // By default, no fullscreen control\n      if (options.fullscreenControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.fullscreenControl === true ||\n          options.fullscreenControl === undefined\n            ? \"top-right\"\n            : options.fullscreenControl\n        ) as ControlPosition;\n\n        this.addControl(new FullscreenControl({}), position);\n      }\n\n      this.isReady = true;\n      this.fire(\"ready\", { target: this });\n    });\n\n    // Creating a custom event: \"loadWithTerrain\"\n    // that fires only once when both:\n    // - the map has full ready (corresponds to the the \"ready\" event)\n    // - the terrain has loaded (corresponds to the \"terrain\" event with terrain beion non-null)\n    // This custom event is necessary to wait for when the map is instanciated with `terrain: true`\n    // and some animation (flyTo, easeTo) are running from the begining.\n    let loadEventTriggered = false;\n    let terrainEventTriggered = false;\n    let terrainEventData: LoadWithTerrainEvent;\n\n    this.once(\"ready\", () => {\n      loadEventTriggered = true;\n      if (terrainEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    });\n\n    this.once(\"style.load\", () => {\n      const { minimap } = options;\n      if (typeof minimap === \"object\") {\n        const {\n          zoom,\n          center,\n          style,\n          language,\n          apiKey,\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle,\n        } = options;\n        this.minimap = new Minimap(minimap, {\n          zoom,\n          center,\n          style,\n          language,\n          apiKey,\n          container: \"null\",\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle,\n        });\n        this.addControl(this.minimap, minimap.position ?? \"bottom-left\");\n      } else if (minimap === true) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, \"bottom-left\");\n      } else if (minimap !== undefined && minimap !== false) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, minimap);\n      }\n    });\n\n    const terrainCallback = (evt: LoadWithTerrainEvent) => {\n      if (!evt.terrain) return;\n      terrainEventTriggered = true;\n      terrainEventData = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: evt.terrain,\n      };\n      this.off(\"terrain\", terrainCallback);\n\n      if (loadEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData as LoadWithTerrainEvent);\n      }\n    };\n\n    this.on(\"terrain\", terrainCallback);\n\n    // enable 3D terrain if provided in options\n    if (options.terrain) {\n      this.enableTerrain(\n        options.terrainExaggeration ?? this.terrainExaggeration,\n      );\n    }\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  async onLoadAsync() {\n    return new Promise<Map>((resolve) => {\n      if (this.loaded()) {\n        return resolve(this);\n      }\n\n      this.once(\"load\", () => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  async onReadyAsync() {\n    return new Promise<Map>((resolve) => {\n      if (this.isReady) {\n        return resolve(this);\n      }\n\n      this.once(\"ready\", () => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  async onLoadWithTerrainAsync() {\n    return new Promise<Map>((resolve) => {\n      if (this.isReady && this.terrain) {\n        return resolve(this);\n      }\n\n      this.once(\"loadWithTerrain\", () => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  override setStyle(\n    style:\n      | null\n      | ReferenceMapStyle\n      | MapStyleVariant\n      | StyleSpecification\n      | string,\n    options?: StyleSwapOptions & StyleOptions,\n  ): this {\n    this.minimap?.setStyle(style);\n    this.forceLanguageUpdate = true;\n\n    this.once(\"idle\", () => {\n      this.forceLanguageUpdate = false;\n    });\n\n    return super.setStyle(styleToStyle(style), options);\n  }\n\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(\n    layer:\n      | (LayerSpecification & {\n          source?: string | SourceSpecification;\n        })\n      | CustomLayerInterface,\n    beforeId?: string,\n  ): this {\n    this.minimap?.addLayer(layer, beforeId);\n    return super.addLayer(layer, beforeId);\n  }\n\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(id: string, beforeId?: string): this {\n    this.minimap?.moveLayer(id, beforeId);\n    return super.moveLayer(id, beforeId);\n  }\n\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(id: string): this {\n    this.minimap?.removeLayer(id);\n    return super.removeLayer(id);\n  }\n\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this {\n    this.minimap?.setLayerZoomRange(layerId, minzoom, maxzoom);\n    return super.setLayerZoomRange(layerId, minzoom, maxzoom);\n  }\n\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(\n    layerId: string,\n    filter?: FilterSpecification | null,\n    options?: StyleSetterOptions,\n  ): this {\n    this.minimap?.setFilter(layerId, filter, options);\n    return super.setFilter(layerId, filter, options);\n  }\n\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(\n    layerId: string,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value: any,\n    options?: StyleSetterOptions,\n  ): this {\n    this.minimap?.setPaintProperty(layerId, name, value, options);\n    return super.setPaintProperty(layerId, name, value, options);\n  }\n\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(\n    layerId: string,\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value: any,\n    options?: StyleSetterOptions,\n  ): this {\n    this.minimap?.setLayoutProperty(layerId, name, value, options);\n    return super.setLayoutProperty(layerId, name, value, options);\n  }\n\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(glyphsUrl: string | null, options?: StyleSetterOptions): this {\n    this.minimap?.setGlyphs(glyphsUrl, options);\n    return super.setGlyphs(glyphsUrl, options);\n  }\n\n  private getStyleLanguage(): string | null {\n    if (!this.style.stylesheet.metadata) return null;\n    if (typeof this.style.stylesheet.metadata !== \"object\") return null;\n\n    if (\n      \"maptiler:language\" in this.style.stylesheet.metadata &&\n      typeof this.style.stylesheet.metadata[\"maptiler:language\"] === \"string\"\n    ) {\n      return this.style.stylesheet.metadata[\"maptiler:language\"];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(language: LanguageString | string): void {\n    this.minimap?.map?.setLanguage(language);\n    this.onStyleReady(() => {\n      this.setPrimaryLanguage(language);\n    });\n  }\n\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n\n  private setPrimaryLanguage(language: LanguageString | string) {\n    const styleLanguage = this.getStyleLanguage();\n\n    // If the language is set to `STYLE` (which is the SDK default), but the language defined in\n    // the style is `auto`, we need to bypass some verification and modify the languages anyway\n    if (\n      !(\n        language === Language.STYLE &&\n        (styleLanguage === Language.AUTO || styleLanguage === Language.VISITOR)\n      )\n    ) {\n      if (language !== Language.STYLE) {\n        this.languageAlwaysBeenStyle = false;\n      }\n\n      if (this.languageAlwaysBeenStyle) {\n        return;\n      }\n\n      // No need to change the language\n      if (this.primaryLanguage === language && !this.forceLanguageUpdate) {\n        return;\n      }\n    }\n\n    if (!isLanguageSupported(language as string)) {\n      console.warn(`The language \"${language}\" is not supported.`);\n      return;\n    }\n\n    if (this.primaryLanguage === Language.STYLE_LOCK) {\n      console.warn(\n        \"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\",\n      );\n      return;\n    }\n\n    this.primaryLanguage = language as LanguageString;\n    let languageNonStyle: LanguageString = language as LanguageString;\n\n    // STYLE needs to be translated into one of the other language,\n    // this is why it's addressed first\n    if (language === Language.STYLE) {\n      if (!styleLanguage) {\n        console.warn(\"The style has no default languages.\");\n        return;\n      }\n\n      if (!isLanguageSupported(styleLanguage)) {\n        console.warn(\"The language defined in the style is not valid.\");\n        return;\n      }\n\n      languageNonStyle = styleLanguage as LanguageString;\n    }\n\n    // may be overwritten below\n    let langStr: string | LanguageString = Language.LOCAL;\n\n    // will be overwritten below\n    let replacer: ExpressionSpecification | string = `{${langStr}}`;\n\n    if (languageNonStyle == Language.VISITOR) {\n      langStr = getBrowserLanguage();\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]],\n          [\"get\", Language.LOCAL],\n\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL],\n            { \"font-scale\": 1.1 },\n          ],\n        ],\n\n        [\"get\", Language.LOCAL],\n      ];\n    } else if (languageNonStyle == Language.VISITOR_ENGLISH) {\n      langStr = Language.ENGLISH;\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL]],\n          [\"get\", Language.LOCAL],\n\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL],\n            { \"font-scale\": 1.1 },\n          ],\n        ],\n        [\"get\", Language.LOCAL],\n      ];\n    } else if (languageNonStyle === Language.AUTO) {\n      langStr = getBrowserLanguage();\n      replacer = [\n        \"case\",\n        [\"has\", langStr],\n        [\"get\", langStr],\n        [\"get\", Language.LOCAL],\n      ];\n    }\n\n    // This is for using the regular names as {name}\n    else if (languageNonStyle === Language.LOCAL) {\n      langStr = Language.LOCAL;\n      replacer = `{${langStr}}`;\n    }\n\n    // This section is for the regular language ISO codes\n    else {\n      langStr = languageNonStyle;\n      replacer = [\n        \"case\",\n        [\"has\", langStr],\n        [\"get\", langStr],\n        [\"get\", Language.LOCAL],\n      ];\n    }\n\n    const { layers } = this.getStyle();\n\n    for (const { id, layout } of layers) {\n      if (!layout) {\n        continue;\n      }\n\n      if (!(\"text-field\" in layout)) {\n        continue;\n      }\n\n      const textFieldLayoutProp = this.getLayoutProperty(id, \"text-field\");\n\n      // If the label is not about a name, then we don't translate it\n      if (\n        typeof textFieldLayoutProp === \"string\" &&\n        (textFieldLayoutProp.toLowerCase().includes(\"ref\") ||\n          textFieldLayoutProp.toLowerCase().includes(\"housenumber\"))\n      ) {\n        continue;\n      }\n\n      this.setLayoutProperty(id, \"text-field\", replacer);\n    }\n  }\n\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage(): LanguageString {\n    return this.primaryLanguage;\n  }\n\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration(): number {\n    return this.terrainExaggeration;\n  }\n\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain(): boolean {\n    return this.isTerrainEnabled;\n  }\n\n  private growTerrain(exaggeration: number, durationMs = 1000) {\n    // This method assumes the terrain is already built\n    if (!this.terrain) {\n      return;\n    }\n\n    const startTime = performance.now();\n    // This is supposedly 0, but it could be something else (e.g. already in the middle of growing, or user defined other)\n    const currentExaggeration = this.terrain.exaggeration;\n    const deltaExaggeration = exaggeration - currentExaggeration;\n\n    // This is again called in a requestAnimationFrame ~loop, until the terrain has grown enough\n    // that it has reached the target\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n\n      // If the flattening animation is triggered while the growing animation\n      // is running, then the flattening animation is stopped\n      if (this.terrainFlattening) {\n        return;\n      }\n\n      // normalized value in interval [0, 1] of where we are currently in the animation loop\n      const positionInLoop = (performance.now() - startTime) / durationMs;\n\n      // The animation goes on until we reached 99% of the growing sequence duration\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = 1 - Math.pow(1 - positionInLoop, 4);\n        const newExaggeration =\n          currentExaggeration + exaggerationFactor * deltaExaggeration;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.terrain.exaggeration = exaggeration;\n      }\n\n      this.triggerRepaint();\n    };\n\n    this.terrainGrowing = true;\n    this.terrainFlattening = false;\n    requestAnimationFrame(updateExaggeration);\n  }\n\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(exaggeration = this.terrainExaggeration) {\n    if (exaggeration < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n\n    // This function is mapped to a map \"data\" event. It checks that the terrain\n    // tiles are loaded and when so, it starts an animation to make the terrain grow\n    const dataEventTerrainGrow = async (evt: MapTerrainDataEvent) => {\n      if (!this.terrain) {\n        return;\n      }\n\n      if (\n        evt.type !== \"data\" ||\n        evt.dataType !== \"source\" ||\n        !(\"source\" in evt)\n      ) {\n        return;\n      }\n\n      if (evt.sourceId !== \"maptiler-terrain\") {\n        return;\n      }\n\n      const source = evt.source;\n\n      if (source.type !== \"raster-dem\") {\n        return;\n      }\n\n      if (!evt.isSourceLoaded) {\n        return;\n      }\n\n      // We shut this event off because we want it to happen only once.\n      // Yet, we cannot use the \"once\" method because only the last event of the series\n      // has `isSourceLoaded` true\n      this.off(\"data\", dataEventTerrainGrow);\n\n      this.growTerrain(exaggeration);\n    };\n\n    // This is put into a function so that it can be called regardless\n    // of the loading state of _this_ the map instance\n    const addTerrain = () => {\n      // When style is changed,\n      this.isTerrainEnabled = true;\n      this.terrainExaggeration = exaggeration;\n\n      // Mapping it to the \"data\" event so that we can check that the terrain\n      // growing starts only when terrain tiles are loaded (to reduce glitching)\n      this.on(\"data\", dataEventTerrainGrow);\n\n      this.addSource(defaults.terrainSourceId, {\n        type: \"raster-dem\",\n        url: defaults.terrainSourceURL,\n      });\n\n      // Setting up the terrain with a 0 exaggeration factor\n      // so it loads ~seamlessly and then can grow from there\n      this.setTerrain({\n        source: defaults.terrainSourceId,\n        exaggeration: 0,\n      });\n    };\n\n    // The terrain has already been loaded,\n    // we just update the exaggeration.\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = true;\n      this.growTerrain(exaggeration);\n      return;\n    }\n\n    if (this.loaded() || this.isTerrainEnabled) {\n      addTerrain();\n    } else {\n      this.once(\"load\", () => {\n        if (this.getTerrain() && this.getSource(defaults.terrainSourceId)) {\n          return;\n        }\n        addTerrain();\n      });\n    }\n  }\n\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    // It could be disabled already\n    if (!this.terrain) {\n      return;\n    }\n\n    this.isTerrainEnabled = false;\n    // this.stopFlattening = false;\n\n    // Duration of the animation in millisec\n    const animationLoopDuration = 1 * 1000;\n    const startTime = performance.now();\n    // This is supposedly 0, but it could be something else (e.g. already in the middle of growing, or user defined other)\n    const currentExaggeration = this.terrain.exaggeration;\n\n    // This is again called in a requestAnimationFrame ~loop, until the terrain has grown enough\n    // that it has reached the target\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n\n      // If the growing animation is triggered while flattening,\n      // then we exist the flatening\n      if (this.terrainGrowing) {\n        return;\n      }\n\n      // normalized value in interval [0, 1] of where we are currently in the animation loop\n      const positionInLoop =\n        (performance.now() - startTime) / animationLoopDuration;\n\n      // The animation goes on until we reached 99% of the growing sequence duration\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = Math.pow(1 - positionInLoop, 4);\n        const newExaggeration = currentExaggeration * exaggerationFactor;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrain.exaggeration = 0;\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        // @ts-expect-error - https://github.com/maplibre/maplibre-gl-js/issues/2992\n        this.setTerrain();\n        if (this.getSource(defaults.terrainSourceId)) {\n          this.removeSource(defaults.terrainSourceId);\n        }\n      }\n\n      this.triggerRepaint();\n    };\n\n    this.terrainGrowing = false;\n    this.terrainFlattening = true;\n    requestAnimationFrame(updateExaggeration);\n  }\n\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(exaggeration: number, animate = true) {\n    if (!animate && this.terrain) {\n      this.terrainExaggeration = exaggeration;\n      this.terrain.exaggeration = exaggeration;\n      this.triggerRepaint();\n    } else {\n      this.enableTerrain(exaggeration);\n    }\n  }\n\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  private onStyleReady(cb: () => void) {\n    if (this.isStyleLoaded()) {\n      cb();\n    } else {\n      this.once(\"styledata\", () => {\n        cb();\n      });\n    }\n  }\n\n  async fitToIpBounds() {\n    const ipGeolocateResult = await geolocation.info();\n    this.fitBounds(\n      ipGeolocateResult.country_bounds as [number, number, number, number],\n      {\n        duration: 0,\n        padding: 100,\n      },\n    );\n  }\n\n  async centerOnIpPoint(zoom: number | undefined) {\n    const ipGeolocateResult = await geolocation.info();\n    this.jumpTo({\n      center: [\n        ipGeolocateResult?.longitude ?? 0,\n        ipGeolocateResult?.latitude ?? 0,\n      ],\n      zoom: zoom || 11,\n    });\n  }\n\n  getCameraHash() {\n    const hashBin = new Float32Array(5);\n    const center = this.getCenter();\n    hashBin[0] = center.lng;\n    hashBin[1] = center.lat;\n    hashBin[2] = this.getZoom();\n    hashBin[3] = this.getPitch();\n    hashBin[4] = this.getBearing();\n    return Base64.fromUint8Array(new Uint8Array(hashBin.buffer));\n  }\n\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig(): SdkConfig {\n    return config;\n  }\n\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId(): string {\n    return MAPTILER_SESSION_ID;\n  }\n\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  override setTransformRequest(\n    transformRequest: RequestTransformFunction,\n  ): this {\n    super.setTransformRequest(combineTransformRequest(transformRequest));\n    return this;\n  }\n\n  /**\n   * Loads an image. This is an async equivalent of `Map.loadImage`\n   */\n  async loadImageAsync(\n    url: string,\n  ): Promise<HTMLImageElement | ImageBitmap | null | undefined> {\n    return new Promise((resolve, reject) => {\n      this.loadImage(\n        url,\n        (\n          error: Error | null | undefined,\n          image: HTMLImageElement | ImageBitmap | null | undefined,\n        ) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(image);\n        },\n      );\n    });\n  }\n}\n","/**\n * This is an extension of MapLibre Marker to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class Marker extends maplibregl.Marker {\n  addTo(map: Map | MapMLGL): this {\n    return super.addTo(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre Popup to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class Popup extends maplibregl.Popup {\n  addTo(map: Map | MapMLGL): this {\n    return super.addTo(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre Style to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL, StyleOptions } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class Style extends maplibregl.Style {\n  constructor(map: Map, options: StyleOptions = {}) {\n    super(map as MapMLGL, options);\n  }\n}\n","/**\n * This is an extension of MapLibre CanvasSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class CanvasSource extends maplibregl.CanvasSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre GeoJSONSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class GeoJSONSource extends maplibregl.GeoJSONSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre ImageSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class ImageSource extends maplibregl.ImageSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre RasterTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class RasterTileSource extends maplibregl.RasterTileSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre RasterDEMTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class RasterDEMTileSource extends maplibregl.RasterDEMTileSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre VectorTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class VectorTileSource extends maplibregl.VectorTileSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre VideoSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class VideoSource extends maplibregl.VideoSource {\n  onAdd(map: Map | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre TerrainControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport { Map } from \"./Map\";\n\nexport class TerrainControl extends maplibregl.TerrainControl {\n  onAdd(map: Map | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is TypeScript rewrite of the Point class to use instead of the version imported in MapLibre.\n * It also uses a class instead of prototypes.\n */\n\n/**\n * Row major 2x2 matrix\n */\nexport type Matrix2 = [number, number, number, number];\n\n/**\n * a point\n */\nexport class Point {\n  public x: number;\n  public y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  private _matMult(m: Matrix2): Point {\n    const x = m[0] * this.x + m[1] * this.y;\n    const y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  private _add(p: Point): Point {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  private _sub(p: Point): Point {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  }\n\n  private _mult(k: number): Point {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n\n  private _div(k: number): Point {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  }\n\n  private _multByPoint(p: Point): Point {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  }\n\n  private _divByPoint(p: Point): Point {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  }\n\n  private _unit(): Point {\n    this._div(this.mag());\n    return this;\n  }\n\n  private _perp(): Point {\n    const y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  }\n\n  private _rotate(angle: number): Point {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * this.x - sin * this.y;\n    const y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  private _rotateAround(angle: number, p: Point): Point {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y);\n    const y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  private _round(): Point {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add(p: Point): Point {\n    return this.clone()._add(p);\n  }\n\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub(p: Point): Point {\n    return this.clone()._sub(p);\n  }\n\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint(p: Point): Point {\n    return this.clone()._multByPoint(p);\n  }\n\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint(p: Point): Point {\n    return this.clone()._divByPoint(p);\n  }\n\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Number} k factor\n   * @return {Point} output point\n   */\n  mult(k: number): Point {\n    return this.clone()._mult(k);\n  }\n\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div(k: number): Point {\n    return this.clone()._div(k);\n  }\n\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate(a: number): Point {\n    return this.clone()._rotate(a);\n  }\n\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround(a: number, p: Point): Point {\n    return this.clone()._rotateAround(a, p);\n  }\n\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult(m: Matrix2): Point {\n    return this.clone()._matMult(m);\n  }\n\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit(): Point {\n    return this.clone()._unit();\n  }\n\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp(): Point {\n    return this.clone()._perp();\n  }\n\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round(): Point {\n    return this.clone()._round();\n  }\n\n  /**\n   * Return the magnitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag(): number {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals(other: Point): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist(p: Point): number {\n    return Math.sqrt(this.distSqr(p));\n  }\n\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr(p: Point): number {\n    const dx = p.x - this.x;\n    const dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo(b: Point): number {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  }\n\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith(b: Point): number {\n    return this.angleWithSep(b.x, b.y);\n  }\n\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin() for .\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep(x: number, y: number): number {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  }\n\n  /**\n   * Construct a point from an array if necessary, otherwise if the input\n   * is already a Point, or an unknown type, return it unchanged\n   * @param {Array<number> | Point} a any kind of input value\n   * @return {Point} constructed point, or passed-through value.\n   * @example\n   * // this\n   * var point = Point.convert([0, 1]);\n   * // is equivalent to\n   * var point = new Point(0, 1);\n   */\n  static convert(a: Point | Array<number>) {\n    if (a instanceof Point) {\n      return a;\n    }\n    if (Array.isArray(a)) {\n      return new Point(a[0], a[1]);\n    }\n    return a;\n  }\n}\n","// Typescript port of https://github.com/mapbox/togeojson/\n// This includes KML and GPX parsing to GeoJSON\n\nexport interface Link {\n  href: string | null;\n}\n\nexport interface XMLProperties {\n  links?: Link[];\n}\n\nexport interface PlacemarkProperties {\n  name?: string;\n  address?: string;\n  styleUrl?: string;\n  description?: string;\n  styleHash?: string;\n  styleMapHash?: Record<string, string | null>;\n  timespan?: {\n    begin: string;\n    end: string;\n  };\n  timestamp?: string;\n  stroke?: string;\n  \"stroke-opacity\"?: number;\n  \"stroke-width\"?: number;\n  fill?: string;\n  \"fill-opacity\"?: number;\n  visibility?: string;\n  icon?: string;\n  coordTimes?: (string | null)[] | (string | null)[][];\n}\n\n/**\n * create a function that converts a string to XML\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n */\nexport function str2xml(str: string): Document {\n  if (typeof DOMParser !== \"undefined\") {\n    const doc = new DOMParser().parseFromString(str, \"application/xml\");\n\n    // If the input string was not valid XML\n    if (doc.querySelector(\"parsererror\")) {\n      throw new Error(\"The provided string is not valid XML\");\n    }\n\n    return doc;\n  } else {\n    throw new Error(\"No XML parser found\");\n  }\n}\n\n/**\n * Check one of the top level child node is of a given type (\"gpx\", \"kml\").\n * The check is not case sensitive.\n * @param doc\n * @param nodeName\n * @returns\n */\nexport function hasChildNodeWithName(doc: Document, nodeName: string): boolean {\n  if (!doc.hasChildNodes()) {\n    return false;\n  }\n\n  for (const childNode of Array.from(doc.childNodes)) {\n    const currentNodeName = childNode.nodeName;\n    if (\n      typeof currentNodeName === \"string\" &&\n      currentNodeName.trim().toLowerCase() === nodeName.toLowerCase()\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * create a function that converts a XML to a string\n * https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer\n */\nexport function xml2str(node: Node): string {\n  if (typeof XMLSerializer !== \"undefined\") {\n    return new XMLSerializer().serializeToString(node);\n  }\n  throw new Error(\"No XML serializer found\");\n}\n\n/**\n * Given a XML document using the GPX spec, return GeoJSON\n */\nexport function gpx(doc: string | Document): GeoJSON.FeatureCollection {\n  if (typeof doc === \"string\") doc = str2xml(doc);\n  // doc.firstChild\n  // The document is valid XML but not valid GPX (at leas the first node is not)\n  if (!hasChildNodeWithName(doc, \"gpx\")) {\n    throw new Error(\"The XML document is not valid GPX\");\n  }\n\n  const tracks = get(doc, \"trk\");\n  const routes = get(doc, \"rte\");\n  const waypoints = get(doc, \"wpt\");\n  // a feature collection\n  const gj: GeoJSON.FeatureCollection = {\n    type: \"FeatureCollection\",\n    features: [],\n  };\n  for (const track of Array.from(tracks)) {\n    const feature = getTrack(track);\n    if (feature) gj.features.push(feature);\n  }\n  for (const route of Array.from(routes)) {\n    const feature = getRoute(route);\n    if (feature) gj.features.push(feature);\n  }\n  for (const waypoint of Array.from(waypoints)) {\n    gj.features.push(getPoint(waypoint));\n  }\n  return gj;\n}\n\n/**\n * Given a XML document using the KML spec, return GeoJSON\n */\nexport function kml(\n  doc: string | Document,\n  xml2string?: (node: Node) => string,\n): GeoJSON.FeatureCollection {\n  if (typeof doc === \"string\") doc = str2xml(doc);\n\n  // The document is valid XML but not valid KML (at leas the first node is not)\n  if (!hasChildNodeWithName(doc, \"kml\")) {\n    throw new Error(\"The XML document is not valid KML\");\n  }\n\n  const gj: GeoJSON.FeatureCollection = {\n    type: \"FeatureCollection\",\n    features: [],\n  };\n  // styleindex keeps track of hashed styles in order to match features\n  const styleIndex: Record<string, string> = {};\n  const styleByHash: Record<string, Element> = {};\n  // stylemapindex keeps track of style maps to expose in properties\n  const styleMapIndex: Record<string, Record<string, string | null>> = {};\n  // all root placemarks in the file\n  const placemarks = get(doc, \"Placemark\");\n  const styles = get(doc, \"Style\");\n  const styleMaps = get(doc, \"StyleMap\");\n\n  for (const style of Array.from(styles)) {\n    const hash = okhash(\n      xml2string !== undefined ? xml2string(style) : xml2str(style),\n    ).toString(16);\n    styleIndex[\"#\" + attr(style, \"id\")] = hash;\n    styleByHash[hash] = style;\n  }\n  for (const styleMap of Array.from(styleMaps)) {\n    styleIndex[\"#\" + attr(styleMap, \"id\")] = okhash(\n      xml2string !== undefined ? xml2string(styleMap) : xml2str(styleMap),\n    ).toString(16);\n    const pairs = get(styleMap, \"Pair\");\n    const pairsMap: Record<string, string | null> = {};\n    for (const pair of Array.from(pairs)) {\n      pairsMap[nodeVal(get1(pair, \"key\")) ?? \"\"] = nodeVal(\n        get1(pair, \"styleUrl\"),\n      );\n    }\n    styleMapIndex[\"#\" + attr(styleMap, \"id\")] = pairsMap;\n  }\n  for (const placemark of Array.from(placemarks)) {\n    gj.features = gj.features.concat(\n      getPlacemark(placemark, styleIndex, styleByHash, styleMapIndex),\n    );\n  }\n  return gj;\n}\n\n// parse color string to hex string with opacity. black with 100% opacity will be returned if no data found\nfunction kmlColor(v: string | null): [string, number] {\n  if (v === null) return [\"#000000\", 1];\n  let color = \"\";\n  let opacity = 1;\n  if (v.substring(0, 1) === \"#\") v = v.substring(1);\n  if (v.length === 6 || v.length === 3) color = v;\n  if (v.length === 8) {\n    opacity = parseInt(v.substring(0, 2), 16) / 255;\n    color = \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return [color ?? \"#000000\", opacity ?? 1];\n}\n\nfunction gxCoord(v: string): number[] {\n  return numarray(v.split(\" \"));\n}\n\n// grab coordinates and timestamps (when available) from the gx:Track extension\nfunction gxCoords(root: Document | Element): {\n  coords: number[][];\n  times: (string | null)[];\n} {\n  let elems = get(root, \"coord\");\n  const coords: number[][] = [];\n  const times: (string | null)[] = [];\n  if (elems.length === 0) elems = get(root, \"gx:coord\");\n  for (const elem of Array.from(elems)) {\n    coords.push(gxCoord(nodeVal(elem) ?? \"\"));\n  }\n  const timeElems = get(root, \"when\");\n  for (const timeElem of Array.from(timeElems)) times.push(nodeVal(timeElem));\n  return {\n    coords: coords,\n    times,\n  };\n}\n\n// get the geometry data and coordinate timestamps if available\nfunction getGeometry(root: Element): {\n  geoms: GeoJSON.Geometry[];\n  coordTimes: (string | null)[][];\n} {\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  const geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  // setup variables\n  let geomNode, geomNodes, i, j, k;\n  const geoms: GeoJSON.Geometry[] = [];\n  const coordTimes: (string | null)[][] = [];\n  // simple cases\n  if (get1(root, \"MultiGeometry\") !== null) {\n    return getGeometry(get1(root, \"MultiGeometry\") as Element);\n  }\n  if (get1(root, \"MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"MultiTrack\") as Element);\n  }\n  if (get1(root, \"gx:MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"gx:MultiTrack\") as Element);\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = get(root, geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1(nodeVal(get1(geomNode, \"coordinates\")) ?? \"\"),\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord(nodeVal(get1(geomNode, \"coordinates\")) ?? \"\"),\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = get(geomNode, \"LinearRing\");\n          const coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord(nodeVal(get1(rings[k], \"coordinates\")) ?? \"\"));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords,\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords,\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return { geoms, coordTimes };\n}\n\n// build geojson feature sets with all their attributes and property data\nfunction getPlacemark(\n  root: Element,\n  styleIndex: Record<string, string>,\n  styleByHash: Record<string, Element>,\n  styleMapIndex: Record<string, Record<string, string | null>>,\n) {\n  const geomsAndTimes = getGeometry(root);\n  const properties: PlacemarkProperties & Record<string, string> = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  const visibility = get1(root, \"visibility\");\n\n  let i: number;\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n\n  if (!geomsAndTimes.geoms.length) return [];\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") styleUrl = \"#\" + styleUrl;\n\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal ?? \"\"];\n    }\n    // Try to populate the lineStyle or polyStyle since we got the style hash\n    const style = styleByHash[properties.styleHash ?? \"\"];\n    if (style) {\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n      const iconStyle = get1(style, \"IconStyle\");\n      if (iconStyle) {\n        const icon = get1(iconStyle, \"Icon\");\n        if (icon) {\n          const href = nodeVal(get1(icon, \"href\"));\n          if (href) properties.icon = href;\n        }\n      }\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    if (begin && end) properties.timespan = { begin, end };\n  }\n  if (timeStamp !== null) {\n    properties.timestamp =\n      nodeVal(get1(timeStamp, \"when\")) ?? new Date().toISOString();\n  }\n  if (lineStyle !== null) {\n    const linestyles = kmlColor(nodeVal(get1(lineStyle, \"color\")));\n    const color = linestyles[0];\n    const opacity = linestyles[1];\n    const width = parseFloat(nodeVal(get1(lineStyle, \"width\")) ?? \"\");\n    if (color) properties.stroke = color;\n    if (!isNaN(opacity)) properties[\"stroke-opacity\"] = opacity;\n    if (!isNaN(width)) properties[\"stroke-width\"] = width;\n  }\n  if (polyStyle) {\n    const polystyles = kmlColor(nodeVal(get1(polyStyle, \"color\")));\n    const pcolor = polystyles[0];\n    const popacity = polystyles[1];\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (pcolor) properties.fill = pcolor;\n    if (!isNaN(popacity)) properties[\"fill-opacity\"] = popacity;\n    if (fill)\n      properties[\"fill-opacity\"] =\n        fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] =\n        outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = get(extendedData, \"Data\"),\n      simpleDatas = get(extendedData, \"SimpleData\");\n\n    for (i = 0; i < datas.length; i++) {\n      properties[datas[i].getAttribute(\"name\") ?? \"\"] =\n        nodeVal(get1(datas[i], \"value\")) ?? \"\";\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[simpleDatas[i].getAttribute(\"name\") ?? \"\"] =\n        nodeVal(simpleDatas[i]) ?? \"\";\n    }\n  }\n  if (visibility !== null) {\n    properties.visibility = nodeVal(visibility) ?? \"\";\n  }\n  if (geomsAndTimes.coordTimes.length !== 0) {\n    properties.coordTimes =\n      geomsAndTimes.coordTimes.length === 1\n        ? geomsAndTimes.coordTimes[0]\n        : geomsAndTimes.coordTimes;\n  }\n  const feature: GeoJSON.Feature = {\n    type: \"Feature\",\n    geometry:\n      geomsAndTimes.geoms.length === 1\n        ? geomsAndTimes.geoms[0]\n        : {\n            type: \"GeometryCollection\",\n            geometries: geomsAndTimes.geoms,\n          },\n    properties: properties,\n  };\n  if (attr(root, \"id\")) feature.id = attr(root, \"id\") ?? undefined;\n  return [feature];\n}\n\nfunction getPoints(\n  node: Element,\n  pointname: string,\n):\n  | undefined\n  | {\n      line: number[][];\n      times: string[];\n      heartRates: (number | null)[];\n    } {\n  const pts = get(node, pointname);\n  const line: number[][] = [];\n  const times: string[] = [];\n  let heartRates: (number | null)[] = [];\n  const ptsLength = pts.length;\n  if (ptsLength < 2) return; // Invalid line in GeoJSON\n  for (let i = 0; i < ptsLength; i++) {\n    const cPair = coordPair(pts[i]);\n    line.push(cPair.coordinates);\n    if (cPair.time) times.push(cPair.time);\n    if (cPair.heartRate || heartRates.length) {\n      if (heartRates.length === 0) heartRates = new Array(i).fill(null);\n      heartRates.push(cPair.heartRate);\n    }\n  }\n  return {\n    line: line,\n    times: times,\n    heartRates,\n  };\n}\n\nfunction getTrack(node: Element): undefined | GeoJSON.Feature {\n  const segments = get(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const heartRates: (number | null)[][] = [];\n  let line;\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"trkpt\");\n    if (line !== undefined) {\n      if (line.line) track.push(line.line);\n      if (line.times && line.times.length) times.push(line.times);\n      if (heartRates.length || (line.heartRates && line.heartRates.length)) {\n        if (!heartRates.length) {\n          for (let s = 0; s < i; s++) {\n            heartRates.push(new Array(track[s].length).fill(null));\n          }\n        }\n        if (line.heartRates && line.heartRates.length) {\n          heartRates.push(line.heartRates);\n        } else {\n          heartRates.push(new Array(line.line.length).fill(null));\n        }\n      }\n    }\n  }\n  if (track.length === 0) return;\n  const properties: {\n    coordTimes?: string[] | string[][];\n    heartRates?: (number | null)[] | (number | null)[][];\n  } & XMLProperties &\n    Record<string, string | number> = {\n    ...getProperties(node),\n    ...getLineStyle(get1(node, \"extensions\")),\n  };\n  if (times.length !== 0)\n    properties.coordTimes = track.length === 1 ? times[0] : times;\n  if (heartRates.length !== 0) {\n    properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n  }\n  if (track.length === 1) {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"LineString\",\n        coordinates: track[0],\n      },\n    };\n  } else {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"MultiLineString\",\n        coordinates: track,\n      },\n    };\n  }\n}\n\nfunction getRoute(node: Element): GeoJSON.Feature | undefined {\n  const line = getPoints(node, \"rtept\");\n  if (line === undefined) return;\n  const prop = {\n    ...getProperties(node),\n    ...getLineStyle(get1(node, \"extensions\")),\n  };\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getPoint(node: Element): GeoJSON.Feature {\n  const prop = { ...getProperties(node), ...getMulti(node, [\"sym\"]) };\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates,\n    },\n  };\n}\n\nfunction getLineStyle(\n  extensions: Element | null,\n): Record<string, string | number> {\n  const style: Record<string, string | number> = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\"));\n      const opacity = parseFloat(nodeVal(get1(lineStyle, \"opacity\")) ?? \"0\");\n      const width = parseFloat(nodeVal(get1(lineStyle, \"width\")) ?? \"0\");\n      if (color) style.stroke = color;\n      if (!isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      // GPX width is in mm, convert to px with 96 px per inch\n      if (!isNaN(width)) style[\"stroke-width\"] = (width * 96) / 25.4;\n    }\n  }\n  return style;\n}\n\nfunction getProperties(node: Element): XMLProperties & Record<string, string> {\n  const prop: XMLProperties & Record<string, string> = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n  const links = get(node, \"link\");\n  if (links.length !== 0) {\n    prop.links = [];\n    for (const l of Array.from(links)) {\n      const link = {\n        href: attr(l, \"href\"),\n        ...getMulti(l, [\"text\", \"type\"]),\n      };\n      prop.links.push(link);\n    }\n  }\n  return prop;\n}\n\nfunction okhash(x: string): number {\n  let h = 0;\n  if (!x || !x.length) return h;\n  for (let i = 0; i < x.length; i++) {\n    h = ((h << 5) - h + x.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\nfunction get(x: Document | Element, y: string): HTMLCollectionOf<Element> {\n  return x.getElementsByTagName(y);\n}\n\nfunction attr(x: Element, y: string): string | null {\n  return x.getAttribute(y);\n}\n\nfunction attrf(x: Element, y: string): number {\n  return parseFloat(attr(x, y) ?? \"0\");\n}\n\nfunction get1(x: Element, y: string): Element | null {\n  const n = get(x, y);\n  return n.length ? n[0] : null;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\nfunction norm(el: Element): Element {\n  if (el.normalize) el.normalize();\n  return el;\n}\n\n// cast array x into numbers\nfunction numarray(x: string[]): number[] {\n  return x.map(parseFloat).map((n) => (isNaN(n) ? null : n)) as number[];\n}\n\n// get the content of a text node, if any\nfunction nodeVal(x: Element | null): string | null {\n  if (x) norm(x);\n  return x && x.textContent;\n}\n\n// get the contents of multiple text nodes, if present\nfunction getMulti(x: Element, ys: string[]): Record<string, string> {\n  const o: Record<string, string> = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = nodeVal(n) ?? \"\";\n  }\n  return o;\n}\n\n// get one coordinate from a coordinate array, if any\nfunction coord1(v: string): number[] {\n  return numarray(v.replace(/\\s*/g, \"\").split(\",\"));\n}\n\n// get all coordinates from a coordinate array as [[],[]]\nfunction coord(v: string): number[][] {\n  const coords = v.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/);\n  const out = [];\n  for (const coord of coords) out.push(coord1(coord));\n  return out;\n}\n\n// build a set of coordinates, timestamps, and heartrate\nfunction coordPair(x: Element): {\n  coordinates: number[];\n  time: string | null;\n  heartRate: number | null;\n} {\n  const ll = [attrf(x, \"lon\"), attrf(x, \"lat\")];\n  const ele = get1(x, \"ele\");\n  // handle namespaced attribute in browser\n  const heartRate = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e: number;\n  if (ele) {\n    e = parseFloat(nodeVal(ele) ?? \"0\");\n    if (!isNaN(e)) ll.push(e);\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate:\n      heartRate !== null ? parseFloat(nodeVal(heartRate) ?? \"0\") : null,\n  };\n}\n\nexport function gpxOrKml(\n  doc: string | Document,\n): GeoJSON.FeatureCollection | null {\n  try {\n    // Converting only once rather than in each converter\n    if (typeof doc === \"string\") doc = str2xml(doc);\n  } catch (e) {\n    // The doc is a string but not valid XML\n    return null;\n  }\n\n  try {\n    const result = gpx(doc);\n    return result;\n  } catch (e) {\n    // The doc is valid XML but not valid GPX\n  }\n\n  try {\n    const result = kml(doc);\n    return result;\n  } catch (e) {\n    // The doc is valid XML but not valid KML\n  }\n\n  // At this point, the doc is not of a compatible vector format\n  return null;\n}\n","export type RgbaColor =\n  | [number, number, number]\n  | [number, number, number, number];\n\nexport type ColorStop = {\n  /**\n   * The \"value\" at which this ColorStop should be applied.\n   */\n  value: number;\n  /**\n   * RGB[A] - Array of 3-4 numbers. 0-255 per channel.\n   */\n  color: RgbaColor;\n};\n\n/**\n * A RGBA color as per the array definition\n */\nexport type ArrayColor = [number, number, number, number];\n\n/**\n * A color ramp stop as per array definition\n */\nexport type ArrayColorRampStop = [\n  /**\n   * Real world value in a real world unit\n   */\n  number,\n\n  /**\n   * Color RGBA\n   */\n  ArrayColor,\n];\n\n/**\n * A color ramp as per array definition\n */\nexport type ArrayColorRamp = Array<ArrayColorRampStop>;\n\nexport type ColorRampOptions = {\n  /**\n   * The value the colorramp starts\n   */\n  min?: number;\n\n  /**\n   * The value the colorramp ends\n   */\n  max?: number;\n\n  /**\n   * Some color stops to copy from\n   */\n  stops?: Array<ColorStop>;\n};\n\nfunction componentToHex(c: number): string {\n  const hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\n\nfunction rgbToHex(rgb: RgbaColor): string {\n  return (\n    \"#\" +\n    componentToHex(rgb[0]) +\n    componentToHex(rgb[1]) +\n    componentToHex(rgb[2]) +\n    (rgb.length === 4 ? componentToHex(rgb[3]) : \"\")\n  );\n}\n\nexport class ColorRamp extends Array<ColorStop> {\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(cr: ArrayColorRamp): ColorRamp {\n    return new ColorRamp({\n      stops: cr.map((cs: ArrayColorRampStop) => ({\n        value: cs[0],\n        color: cs[1],\n      })),\n    });\n  }\n\n  private min = 0;\n  private max = 1;\n\n  constructor(options: ColorRampOptions = {}) {\n    super();\n\n    if (\"min\" in options) {\n      this.min = options.min as number;\n    }\n\n    if (\"max\" in options) {\n      this.max = options.max as number;\n    }\n\n    if (\"stops\" in options) {\n      this.setStops(options.stops as ColorStop[], { clone: false });\n    }\n  }\n\n  setStops(\n    stops: Array<ColorStop>,\n    options: { clone?: boolean } = { clone: true },\n  ): ColorRamp {\n    const colorRamp = options.clone ? this.clone() : this;\n\n    colorRamp.length = 0;\n\n    let min = +Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < stops.length; i += 1) {\n      min = Math.min(min, stops[i].value);\n      max = Math.max(max, stops[i].value);\n\n      colorRamp.push({\n        value: stops[i].value,\n        color: stops[i].color.slice(), // we want to make sure we do a deep copy and not a reference\n      } as ColorStop);\n    }\n\n    colorRamp.sort((a: ColorStop, b: ColorStop) =>\n      a.value < b.value ? -1 : 1,\n    );\n\n    this.min = min;\n    this.max = max;\n\n    return colorRamp;\n  }\n\n  scale(\n    min: number,\n    max: number,\n    options: { clone?: boolean } = { clone: true },\n  ): ColorRamp {\n    const clone = options.clone;\n\n    const currentMin = this[0].value;\n    const currentMax = this.at(-1).value;\n    const currentSpan = currentMax - currentMin;\n    const newSpan = max - min;\n    const stops = [];\n\n    for (let i = 0; i < this.length; i += 1) {\n      const currentValue = this[i].value;\n      const normalizedValue = (currentValue - currentMin) / currentSpan; // putting the value in the interval [0, 1]\n      const newValue = normalizedValue * newSpan + min; // putting the value in the new interval\n\n      if (clone) {\n        stops.push({\n          value: newValue,\n          color: this[i].color.slice(),\n        } as ColorStop);\n      } else {\n        this[i].value = newValue;\n      }\n    }\n\n    return clone ? new ColorRamp({ stops }) : this;\n  }\n\n  // for some reason, I had to reimplement this\n  at(pos: number) {\n    if (pos < 0) {\n      return this[this.length + pos];\n    } else {\n      return this[pos];\n    }\n  }\n\n  clone(): ColorRamp {\n    return new ColorRamp({ stops: this.getRawColorStops() });\n  }\n\n  getRawColorStops(): Array<ColorStop> {\n    const stops = [];\n\n    for (let i = 0; i < this.length; i += 1) {\n      stops.push({ value: this[i].value, color: this[i].color });\n    }\n\n    return stops;\n  }\n\n  reverse(options: { clone?: boolean } = { clone: true }): ColorRamp {\n    const colorRamp = options.clone ? this.clone() : this;\n\n    for (let i = 0; i < ~~(colorRamp.length / 2); i += 1) {\n      const c = colorRamp[i].color;\n      colorRamp[i].color = colorRamp.at(-(i + 1)).color;\n      colorRamp.at(-(i + 1)).color = c;\n    }\n    return colorRamp;\n  }\n\n  getBounds(): { min: number; max: number } {\n    return { min: this.min, max: this.max };\n  }\n\n  getColor(\n    value: number,\n    options: { smooth?: boolean } = { smooth: true },\n  ): RgbaColor {\n    if (value <= this[0].value) {\n      return this[0].color;\n    }\n\n    if (value >= this.at(-1).value) {\n      return this.at(-1).color;\n    }\n\n    for (let i = 0; i < this.length - 1; i += 1) {\n      if (value > this[i + 1].value) {\n        continue;\n      }\n\n      const colorBefore = this[i].color;\n\n      if (!options.smooth) {\n        return colorBefore.slice() as RgbaColor;\n      }\n\n      const valueBefore = this[i].value;\n      const valueAfter = this[i + 1].value;\n      const colorAfter = this[i + 1].color;\n\n      const beforeRatio = (valueAfter - value) / (valueAfter - valueBefore);\n      return colorBefore.map((chan, i) =>\n        Math.round(chan * beforeRatio + colorAfter[i] * (1 - beforeRatio)),\n      ) as RgbaColor;\n    }\n\n    return [0, 0, 0] as RgbaColor;\n  }\n\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(\n    value: number,\n    options: { smooth?: boolean; withAlpha?: boolean } = {\n      smooth: true,\n      withAlpha: false,\n    },\n  ): string {\n    return rgbToHex(this.getColor(value, options));\n  }\n\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(\n    value: number,\n    options: { smooth?: boolean } = { smooth: true },\n  ): RgbaColor {\n    const bounds = this.getBounds();\n    return this.getColor(\n      bounds.min + value * (bounds.max - bounds.min),\n      options,\n    );\n  }\n\n  getCanvasStrip(\n    options: { horizontal?: boolean; size?: number; smooth?: boolean } = {\n      horizontal: true,\n      size: 512,\n      smooth: true,\n    },\n  ) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = options.horizontal ? (options.size as number) : 1;\n    canvas.height = options.horizontal ? 1 : (options.size as number);\n\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) throw new Error(\"Canvs context is missing\");\n\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const imageDataArray = imageData.data;\n\n    const size = options.size as number;\n    const startValue = this[0].value;\n    const endValue = this.at(-1).value;\n    const valueSpan = endValue - startValue;\n    const valueStep = valueSpan / size;\n\n    for (let i = 0; i < size; i += 1) {\n      const color = this.getColor(startValue + i * valueStep, {\n        smooth: options.smooth,\n      });\n      imageDataArray[i * 4] = color[0];\n      imageDataArray[i * 4 + 1] = color[1];\n      imageDataArray[i * 4 + 2] = color[2];\n      imageDataArray[i * 4 + 3] = color.length > 3 ? (color[3] as number) : 255;\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(\n    method:\n      | \"ease-in-square\"\n      | \"ease-out-square\"\n      | \"ease-in-sqrt\"\n      | \"ease-out-sqrt\"\n      | \"ease-in-exp\"\n      | \"ease-out-exp\",\n    samples = 15,\n  ): ColorRamp {\n    const inputBounds = this.getBounds();\n    const inputNormalized = this.scale(0, 1);\n    const step = 1 / (samples - 1);\n\n    let stops;\n\n    if (method === \"ease-in-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 2);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 2);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(1 - x, 0.5);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - Math.pow(2, -10 * x);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = Math.pow(2, 10 * x - 10);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else {\n      throw new Error(\"Invalid ressampling method.\");\n    }\n\n    const outputNormalized = new ColorRamp({ stops });\n    const output = outputNormalized.scale(inputBounds.min, inputBounds.max);\n    return output;\n  }\n\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart(): ColorRamp {\n    const stops = this.getRawColorStops();\n    stops.unshift({\n      value: stops[0].value,\n      color: stops[0].color.slice() as RgbaColor,\n    });\n    stops[1].value += 0.001;\n\n    stops.forEach((s) => {\n      if (s.color.length === 3) {\n        s.color.push(255);\n      }\n    });\n\n    stops[0].color[3] = 0;\n\n    return new ColorRamp({ stops });\n  }\n\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart(): boolean {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\n\n/**\n * This is a collection of built-in color ramps. They are all defined in the range [0, 1]\n * but can be scaled or reversed to fit specific usages.\n */\nexport const ColorRampCollection = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0, 0] },\n      { value: 1, color: [0, 0, 0, 0] },\n    ],\n  }),\n\n  GRAY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 131] },\n      { value: 0.125, color: [0, 60, 170] },\n      { value: 0.375, color: [5, 255, 255] },\n      { value: 0.625, color: [255, 255, 0] },\n      { value: 0.875, color: [250, 0, 0] },\n      { value: 1, color: [128, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 0.169, color: [253, 255, 2] },\n      { value: 0.173, color: [247, 255, 2] },\n      { value: 0.337, color: [0, 252, 4] },\n      { value: 0.341, color: [0, 252, 10] },\n      { value: 0.506, color: [1, 249, 255] },\n      { value: 0.671, color: [2, 0, 253] },\n      { value: 0.675, color: [8, 0, 253] },\n      { value: 0.839, color: [255, 0, 251] },\n      { value: 0.843, color: [255, 0, 245] },\n      { value: 1, color: [255, 0, 6] },\n    ],\n  }),\n\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.3, color: [230, 0, 0] },\n      { value: 0.6, color: [255, 210, 0] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 255] },\n      { value: 1, color: [255, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 128, 102] },\n      { value: 1, color: [255, 255, 102] },\n    ],\n  }),\n\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 1, color: [255, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [0, 255, 128] },\n    ],\n  }),\n\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.376, color: [84, 84, 116] },\n      { value: 0.753, color: [169, 200, 200] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.804, color: [255, 160, 102] },\n      { value: 1, color: [255, 199, 127] },\n    ],\n  }),\n\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [8, 29, 88] },\n      { value: 0.125, color: [37, 52, 148] },\n      { value: 0.25, color: [34, 94, 168] },\n      { value: 0.375, color: [29, 145, 192] },\n      { value: 0.5, color: [65, 182, 196] },\n      { value: 0.625, color: [127, 205, 187] },\n      { value: 0.75, color: [199, 233, 180] },\n      { value: 0.875, color: [237, 248, 217] },\n      { value: 1, color: [255, 255, 217] },\n    ],\n  }),\n\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 68, 27] },\n      { value: 0.125, color: [0, 109, 44] },\n      { value: 0.25, color: [35, 139, 69] },\n      { value: 0.375, color: [65, 171, 93] },\n      { value: 0.5, color: [116, 196, 118] },\n      { value: 0.625, color: [161, 217, 155] },\n      { value: 0.75, color: [199, 233, 192] },\n      { value: 0.875, color: [229, 245, 224] },\n      { value: 1, color: [247, 252, 245] },\n    ],\n  }),\n\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new ColorRamp({\n    stops: [\n      { value: 0, color: [128, 0, 38] },\n      { value: 0.125, color: [189, 0, 38] },\n      { value: 0.25, color: [227, 26, 28] },\n      { value: 0.375, color: [252, 78, 42] },\n      { value: 0.5, color: [253, 141, 60] },\n      { value: 0.625, color: [254, 178, 76] },\n      { value: 0.75, color: [254, 217, 118] },\n      { value: 0.875, color: [255, 237, 160] },\n      { value: 1, color: [255, 255, 204] },\n    ],\n  }),\n\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [255, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [5, 10, 172] },\n      { value: 0.35, color: [106, 137, 247] },\n      { value: 0.5, color: [190, 190, 190] },\n      { value: 0.6, color: [220, 170, 132] },\n      { value: 0.7, color: [230, 145, 90] },\n      { value: 1, color: [178, 10, 28] },\n    ],\n  }),\n\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 0.1, color: [51, 153, 255] },\n      { value: 0.2, color: [102, 204, 255] },\n      { value: 0.3, color: [153, 204, 255] },\n      { value: 0.4, color: [204, 204, 255] },\n      { value: 0.5, color: [255, 255, 255] },\n      { value: 0.6, color: [255, 204, 255] },\n      { value: 0.7, color: [255, 153, 255] },\n      { value: 0.8, color: [255, 102, 204] },\n      { value: 0.9, color: [255, 102, 102] },\n      { value: 1, color: [255, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new ColorRamp({\n    stops: [\n      { value: 0, color: [150, 0, 90] },\n      { value: 0.125, color: [0, 0, 200] },\n      { value: 0.25, color: [0, 25, 255] },\n      { value: 0.375, color: [0, 152, 255] },\n      { value: 0.5, color: [44, 255, 150] },\n      { value: 0.625, color: [151, 255, 0] },\n      { value: 0.75, color: [255, 234, 0] },\n      { value: 0.875, color: [255, 111, 0] },\n      { value: 1, color: [255, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new ColorRamp({\n    stops: [\n      { value: 0, color: [12, 51, 131] },\n      { value: 0.25, color: [10, 136, 186] },\n      { value: 0.5, color: [242, 211, 56] },\n      { value: 0.75, color: [242, 143, 56] },\n      { value: 1, color: [217, 30, 30] },\n    ],\n  }),\n\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.2, color: [230, 0, 0] },\n      { value: 0.4, color: [230, 210, 0] },\n      { value: 0.7, color: [255, 255, 255] },\n      { value: 1, color: [160, 200, 255] },\n    ],\n  }),\n\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 130] },\n      { value: 0.1, color: [0, 180, 180] },\n      { value: 0.2, color: [40, 210, 40] },\n      { value: 0.4, color: [230, 230, 50] },\n      { value: 0.6, color: [120, 70, 20] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.15, color: [30, 0, 100] },\n      { value: 0.4, color: [120, 0, 100] },\n      { value: 0.6, color: [160, 90, 0] },\n      { value: 0.8, color: [230, 200, 0] },\n      { value: 1, color: [255, 250, 220] },\n    ],\n  }),\n\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [68, 1, 84] },\n      { value: 0.13, color: [71, 44, 122] },\n      { value: 0.25, color: [59, 81, 139] },\n      { value: 0.38, color: [44, 113, 142] },\n      { value: 0.5, color: [33, 144, 141] },\n      { value: 0.63, color: [39, 173, 129] },\n      { value: 0.75, color: [92, 200, 99] },\n      { value: 0.88, color: [170, 220, 50] },\n      { value: 1, color: [253, 231, 37] },\n    ],\n  }),\n\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [31, 12, 72] },\n      { value: 0.25, color: [85, 15, 109] },\n      { value: 0.38, color: [136, 34, 106] },\n      { value: 0.5, color: [186, 54, 85] },\n      { value: 0.63, color: [227, 89, 51] },\n      { value: 0.75, color: [249, 140, 10] },\n      { value: 0.88, color: [249, 201, 50] },\n      { value: 1, color: [252, 255, 164] },\n    ],\n  }),\n\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [28, 16, 68] },\n      { value: 0.25, color: [79, 18, 123] },\n      { value: 0.38, color: [129, 37, 129] },\n      { value: 0.5, color: [181, 54, 122] },\n      { value: 0.63, color: [229, 80, 100] },\n      { value: 0.75, color: [251, 135, 97] },\n      { value: 0.88, color: [254, 194, 135] },\n      { value: 1, color: [252, 253, 191] },\n    ],\n  }),\n\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [13, 8, 135] },\n      { value: 0.13, color: [75, 3, 161] },\n      { value: 0.25, color: [125, 3, 168] },\n      { value: 0.38, color: [168, 34, 150] },\n      { value: 0.5, color: [203, 70, 121] },\n      { value: 0.63, color: [229, 107, 93] },\n      { value: 0.75, color: [248, 148, 65] },\n      { value: 0.88, color: [253, 195, 40] },\n      { value: 1, color: [240, 249, 33] },\n    ],\n  }),\n\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [172, 0, 187] },\n      { value: 0.25, color: [219, 0, 170] },\n      { value: 0.38, color: [255, 0, 130] },\n      { value: 0.5, color: [255, 63, 74] },\n      { value: 0.63, color: [255, 123, 0] },\n      { value: 0.75, color: [234, 176, 0] },\n      { value: 0.88, color: [190, 228, 0] },\n      { value: 1, color: [147, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [116, 0, 218] },\n      { value: 0.25, color: [98, 74, 237] },\n      { value: 0.38, color: [68, 146, 231] },\n      { value: 0.5, color: [0, 204, 197] },\n      { value: 0.63, color: [0, 247, 146] },\n      { value: 0.75, color: [0, 255, 88] },\n      { value: 0.88, color: [40, 255, 8] },\n      { value: 1, color: [147, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.1, color: [199, 0, 180] },\n      { value: 0.2, color: [255, 0, 121] },\n      { value: 0.3, color: [255, 108, 0] },\n      { value: 0.4, color: [222, 194, 0] },\n      { value: 0.5, color: [150, 255, 0] },\n      { value: 0.6, color: [0, 255, 55] },\n      { value: 0.7, color: [0, 246, 150] },\n      { value: 0.8, color: [50, 167, 222] },\n      { value: 0.9, color: [103, 51, 235] },\n      { value: 1, color: [124, 0, 186] },\n    ],\n  }),\n\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new ColorRamp({\n    stops: [\n      { value: 0, color: [40, 26, 44] },\n      { value: 0.13, color: [59, 49, 90] },\n      { value: 0.25, color: [64, 76, 139] },\n      { value: 0.38, color: [63, 110, 151] },\n      { value: 0.5, color: [72, 142, 158] },\n      { value: 0.63, color: [85, 174, 163] },\n      { value: 0.75, color: [120, 206, 163] },\n      { value: 0.88, color: [187, 230, 172] },\n      { value: 1, color: [253, 254, 204] },\n    ],\n  }),\n\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new ColorRamp({\n    stops: [\n      { value: 0, color: [47, 15, 62] },\n      { value: 0.13, color: [87, 23, 86] },\n      { value: 0.25, color: [130, 28, 99] },\n      { value: 0.38, color: [171, 41, 96] },\n      { value: 0.5, color: [206, 67, 86] },\n      { value: 0.63, color: [230, 106, 84] },\n      { value: 0.75, color: [242, 149, 103] },\n      { value: 0.88, color: [249, 193, 135] },\n      { value: 1, color: [254, 237, 176] },\n    ],\n  }),\n\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new ColorRamp({\n    stops: [\n      { value: 0, color: [18, 36, 20] },\n      { value: 0.13, color: [25, 63, 41] },\n      { value: 0.25, color: [24, 91, 59] },\n      { value: 0.38, color: [13, 119, 72] },\n      { value: 0.5, color: [18, 148, 80] },\n      { value: 0.63, color: [80, 173, 89] },\n      { value: 0.75, color: [132, 196, 122] },\n      { value: 0.88, color: [175, 221, 162] },\n      { value: 1, color: [215, 249, 208] },\n    ],\n  }),\n\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [54, 14, 36] },\n      { value: 0.13, color: [89, 23, 80] },\n      { value: 0.25, color: [110, 45, 132] },\n      { value: 0.38, color: [120, 77, 178] },\n      { value: 0.5, color: [120, 113, 213] },\n      { value: 0.63, color: [115, 151, 228] },\n      { value: 0.75, color: [134, 185, 227] },\n      { value: 0.88, color: [177, 214, 227] },\n      { value: 1, color: [230, 241, 241] },\n    ],\n  }),\n\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [30, 4, 110] },\n      { value: 0.13, color: [47, 14, 176] },\n      { value: 0.25, color: [41, 45, 236] },\n      { value: 0.38, color: [25, 99, 212] },\n      { value: 0.5, color: [68, 131, 200] },\n      { value: 0.63, color: [114, 156, 197] },\n      { value: 0.75, color: [157, 181, 203] },\n      { value: 0.88, color: [200, 208, 216] },\n      { value: 1, color: [241, 237, 236] },\n    ],\n  }),\n\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new ColorRamp({\n    stops: [\n      { value: 0, color: [60, 9, 18] },\n      { value: 0.13, color: [100, 17, 27] },\n      { value: 0.25, color: [142, 20, 29] },\n      { value: 0.38, color: [177, 43, 27] },\n      { value: 0.5, color: [192, 87, 63] },\n      { value: 0.63, color: [205, 125, 105] },\n      { value: 0.75, color: [216, 162, 148] },\n      { value: 0.88, color: [227, 199, 193] },\n      { value: 1, color: [241, 237, 236] },\n    ],\n  }),\n\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [64, 5, 5] },\n      { value: 0.13, color: [106, 6, 15] },\n      { value: 0.25, color: [144, 26, 7] },\n      { value: 0.38, color: [168, 64, 3] },\n      { value: 0.5, color: [188, 100, 4] },\n      { value: 0.63, color: [206, 136, 11] },\n      { value: 0.75, color: [220, 174, 25] },\n      { value: 0.88, color: [231, 215, 44] },\n      { value: 1, color: [248, 254, 105] },\n    ],\n  }),\n\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new ColorRamp({\n    stops: [\n      { value: 0, color: [51, 20, 24] },\n      { value: 0.13, color: [90, 32, 35] },\n      { value: 0.25, color: [129, 44, 34] },\n      { value: 0.38, color: [159, 68, 25] },\n      { value: 0.5, color: [182, 99, 19] },\n      { value: 0.63, color: [199, 134, 22] },\n      { value: 0.75, color: [212, 171, 35] },\n      { value: 0.88, color: [221, 210, 54] },\n      { value: 1, color: [225, 253, 75] },\n    ],\n  }),\n\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new ColorRamp({\n    stops: [\n      { value: 0, color: [145, 105, 18] },\n      { value: 0.13, color: [184, 71, 38] },\n      { value: 0.25, color: [186, 58, 115] },\n      { value: 0.38, color: [160, 71, 185] },\n      { value: 0.5, color: [110, 97, 218] },\n      { value: 0.63, color: [50, 123, 164] },\n      { value: 0.75, color: [31, 131, 110] },\n      { value: 0.88, color: [77, 129, 34] },\n      { value: 1, color: [145, 105, 18] },\n    ],\n  }),\n\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [42, 24, 108] },\n      { value: 0.13, color: [33, 50, 162] },\n      { value: 0.25, color: [15, 90, 145] },\n      { value: 0.38, color: [40, 118, 137] },\n      { value: 0.5, color: [59, 146, 135] },\n      { value: 0.63, color: [79, 175, 126] },\n      { value: 0.75, color: [120, 203, 104] },\n      { value: 0.88, color: [193, 221, 100] },\n      { value: 1, color: [253, 239, 154] },\n    ],\n  }),\n\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new ColorRamp({\n    stops: [\n      { value: 0, color: [4, 35, 51] },\n      { value: 0.13, color: [23, 51, 122] },\n      { value: 0.25, color: [85, 59, 157] },\n      { value: 0.38, color: [129, 79, 143] },\n      { value: 0.5, color: [175, 95, 130] },\n      { value: 0.63, color: [222, 112, 101] },\n      { value: 0.75, color: [249, 146, 66] },\n      { value: 0.88, color: [249, 196, 65] },\n      { value: 1, color: [232, 250, 91] },\n    ],\n  }),\n\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [34, 31, 27] },\n      { value: 0.13, color: [65, 50, 41] },\n      { value: 0.25, color: [98, 69, 52] },\n      { value: 0.38, color: [131, 89, 57] },\n      { value: 0.5, color: [161, 112, 59] },\n      { value: 0.63, color: [185, 140, 66] },\n      { value: 0.75, color: [202, 174, 88] },\n      { value: 0.88, color: [216, 209, 126] },\n      { value: 1, color: [233, 246, 171] },\n    ],\n  }),\n\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [17, 32, 64] },\n      { value: 0.13, color: [35, 52, 116] },\n      { value: 0.25, color: [29, 81, 156] },\n      { value: 0.38, color: [31, 113, 162] },\n      { value: 0.5, color: [50, 144, 169] },\n      { value: 0.63, color: [87, 173, 176] },\n      { value: 0.75, color: [149, 196, 189] },\n      { value: 0.88, color: [203, 221, 211] },\n      { value: 1, color: [254, 251, 230] },\n    ],\n  }),\n\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [23, 35, 19] },\n      { value: 0.13, color: [24, 64, 38] },\n      { value: 0.25, color: [11, 95, 45] },\n      { value: 0.38, color: [39, 123, 35] },\n      { value: 0.5, color: [95, 146, 12] },\n      { value: 0.63, color: [152, 165, 18] },\n      { value: 0.75, color: [201, 186, 69] },\n      { value: 0.88, color: [233, 216, 137] },\n      { value: 1, color: [255, 253, 205] },\n    ],\n  }),\n\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.07, color: [22, 5, 59] },\n      { value: 0.13, color: [60, 4, 105] },\n      { value: 0.2, color: [109, 1, 135] },\n      { value: 0.27, color: [161, 0, 147] },\n      { value: 0.33, color: [210, 2, 142] },\n      { value: 0.4, color: [251, 11, 123] },\n      { value: 0.47, color: [255, 29, 97] },\n      { value: 0.53, color: [255, 54, 69] },\n      { value: 0.6, color: [255, 85, 46] },\n      { value: 0.67, color: [255, 120, 34] },\n      { value: 0.73, color: [255, 157, 37] },\n      { value: 0.8, color: [241, 191, 57] },\n      { value: 0.87, color: [224, 220, 93] },\n      { value: 0.93, color: [218, 241, 142] },\n      { value: 1, color: [227, 253, 198] },\n    ],\n  }),\n\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 32, 77, 255] },\n      { value: 0.125, color: [5, 54, 110, 255] },\n      { value: 0.25, color: [65, 77, 108, 255] },\n      { value: 0.375, color: [97, 100, 111, 255] },\n      { value: 0.5, color: [125, 124, 121, 255] },\n      { value: 0.625, color: [156, 149, 120, 255] },\n      { value: 0.75, color: [190, 175, 111, 255] },\n      { value: 0.875, color: [225, 204, 94, 255] },\n      { value: 1, color: [255, 235, 70, 255] },\n    ],\n  }),\n\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new ColorRamp({\n    stops: [\n      { value: 0, color: [48, 18, 59, 255] },\n      { value: 0.125, color: [70, 107, 227, 255] },\n      { value: 0.25, color: [40, 187, 236, 255] },\n      { value: 0.375, color: [49, 242, 153, 255] },\n      { value: 0.5, color: [162, 252, 60, 255] },\n      { value: 0.625, color: [237, 208, 58, 255] },\n      { value: 0.75, color: [251, 128, 34, 255] },\n      { value: 0.875, color: [210, 49, 5, 255] },\n      { value: 1, color: [122, 4, 3, 255] },\n    ],\n  }),\n\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new ColorRamp({\n    stops: [\n      { value: 0, color: [250, 235, 221, 0] },\n      { value: 0.133, color: [250, 235, 221, 255] },\n      { value: 0.266, color: [246, 170, 130, 255] },\n      { value: 0.4, color: [240, 96, 67, 255] },\n      { value: 0.533, color: [203, 27, 79, 255] },\n      { value: 0.666, color: [132, 30, 90, 255] },\n      { value: 0.8, color: [63, 27, 68, 255] },\n      { value: 1, color: [3, 5, 26, 255] },\n    ],\n  }),\n\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new ColorRamp({\n    stops: [\n      { value: 0, color: [11, 4, 5, 255] },\n      { value: 0.125, color: [43, 28, 53, 255] },\n      { value: 0.25, color: [62, 53, 107, 255] },\n      { value: 0.375, color: [59, 86, 152, 255] },\n      { value: 0.5, color: [53, 123, 162, 255] },\n      { value: 0.625, color: [53, 158, 170, 255] },\n      { value: 0.75, color: [73, 193, 173, 255] },\n      { value: 0.875, color: [150, 221, 181, 255] },\n      { value: 1, color: [222, 245, 229, 255] },\n    ],\n  }),\n};\n","import {\n  DataDrivenPropertyValueSpecification,\n  ExpressionSpecification,\n} from \"maplibre-gl\";\nimport { generateRandomString } from \"../tools\";\nimport { ColorRamp, RgbaColor } from \"../colorramp\";\nimport {\n  DataDrivenStyle,\n  PropertyValues,\n  ZoomNumberValues,\n  ZoomStringValues,\n} from \"./vectorlayerhelpers\";\n\nexport type ColorPalette = [string, string, string, string];\n\nexport const colorPalettes: Array<ColorPalette> = [\n  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n  [\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n\n  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n  [\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n\n  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n  [\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n\n  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n  [\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n\n  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n  [\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n\n  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n  [\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n\n  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n  [\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n\n  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n  [\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n\n  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n  [\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"],\n];\n\nexport function getRandomColor(): string {\n  return colorPalettes[~~(Math.random() * colorPalettes.length)][\n    ~~(Math.random() * 4)\n  ];\n}\n\nexport function generateRandomSourceName(): string {\n  return `maptiler_source_${generateRandomString()}`;\n}\n\nexport function generateRandomLayerName(): string {\n  return `maptiler_layer_${generateRandomString()}`;\n}\n\n/**\n * Linera interpolation to find a value at an arbitrary zoom level, given a list of tuple zoom-value\n */\nexport function lerpZoomNumberValues(znv: ZoomNumberValues, z: number): number {\n  // before the range\n  if (z <= znv[0].zoom) {\n    return znv[0].value;\n  }\n\n  // after the range\n  if (z >= znv[znv.length - 1].zoom) {\n    return znv[znv.length - 1].value;\n  }\n\n  // somewhere within the range\n  for (let i = 0; i < znv.length - 1; i += 1) {\n    if (z >= znv[i].zoom && z < znv[i + 1].zoom) {\n      const zoomRange = znv[i + 1].zoom - znv[i].zoom;\n      const normalizedDistanceFromLowerBound = (z - znv[i].zoom) / zoomRange;\n      return (\n        normalizedDistanceFromLowerBound * znv[i + 1].value +\n        (1 - normalizedDistanceFromLowerBound) * znv[i].value\n      );\n    }\n  }\n\n  return 0;\n}\n\nexport function paintColorOptionsToPaintSpec(\n  color: ZoomStringValues,\n): DataDrivenPropertyValueSpecification<string> {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    ...color.map((el) => [el.zoom, el.value]).flat(),\n  ];\n}\n\nexport function rampedOptionsToLayerPaintSpec(\n  ramp: ZoomNumberValues,\n): DataDrivenPropertyValueSpecification<number> {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    ...ramp.map((el) => [el.zoom, el.value]).flat(),\n  ];\n}\n\nexport function computeRampedOutlineWidth(\n  lineWidth: number | ZoomNumberValues,\n  outlineWidth: number | ZoomNumberValues,\n): number | DataDrivenPropertyValueSpecification<number> {\n  // case 1: the line is fixed-width and the outline is fixed-width\n  if (typeof outlineWidth === \"number\" && typeof lineWidth === \"number\") {\n    return 2 * outlineWidth + lineWidth;\n  }\n\n  // case 2: the line is ramped-width, the outline is fixed-width\n  else if (typeof outlineWidth === \"number\" && Array.isArray(lineWidth)) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...lineWidth.map((el) => [el.zoom, 2 * outlineWidth + el.value]).flat(),\n    ];\n  }\n\n  // case 3: the line is fixed-width, the outline is ramped-width\n  else if (typeof lineWidth === \"number\" && Array.isArray(outlineWidth)) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...outlineWidth.map((el) => [el.zoom, 2 * el.value + lineWidth]).flat(),\n    ];\n  }\n\n  // case 4: the line is ramped-width, the outline is ramped-width\n  if (Array.isArray(lineWidth) && Array.isArray(outlineWidth)) {\n    // We must create an artificial set of zoom stops that includes all the zoom stops from both lists\n    // const allStops = [...lineWidth.map(el => el.zoom), ...outlineWidth.map(el => el.zoom)].sort((a: number, b: number) => a < b ? -1 : 1);\n    const allStops = Array.from(\n      new Set([\n        ...lineWidth.map((el) => el.zoom),\n        ...outlineWidth.map((el) => el.zoom),\n      ]),\n    ).sort((a: number, b: number) => (a < b ? -1 : 1));\n\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...allStops\n        .map((z) => [\n          z,\n          2 * lerpZoomNumberValues(outlineWidth, z) +\n            lerpZoomNumberValues(lineWidth, z),\n        ])\n        .flat(),\n    ];\n  }\n\n  return 0;\n}\n\nexport function rampedPropertyValueWeight(\n  ramp: PropertyValues,\n  property: string,\n): DataDrivenPropertyValueSpecification<number> {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...ramp.map((el) => [el.propertyValue, el.value]).flat(),\n  ];\n}\n\n/**\n * Create a dash array from a string pattern that uses underscore and whitespace characters\n */\nexport function dashArrayMaker(pattern: string): Array<number> {\n  // if the pattern starts with whitespaces, then move them towards the end\n  const startTrimmedPattern = pattern.trimStart();\n  const fixedPattern = `${startTrimmedPattern}${\" \".repeat(\n    pattern.length - startTrimmedPattern.length,\n  )}`;\n  const patternArr = Array.from(fixedPattern);\n\n  const isOnlyDashesAndSpaces = patternArr.every((c) => c === \" \" || c === \"_\");\n  if (!isOnlyDashesAndSpaces) {\n    throw new Error(\n      \"A dash pattern must be composed only of whitespace and underscore characters.\",\n    );\n  }\n\n  const hasBothDashesAndWhitespaces =\n    patternArr.some((c) => c === \"_\") && patternArr.some((c) => c === \" \");\n  if (!hasBothDashesAndWhitespaces) {\n    throw new Error(\n      \"A dash pattern must contain at least one underscore and one whitespace character\",\n    );\n  }\n\n  const dashArray = [1];\n\n  for (let i = 1; i < patternArr.length; i += 1) {\n    const previous = patternArr[i - 1];\n    const current = patternArr[i];\n\n    if (previous === current) {\n      dashArray[dashArray.length - 1] += 1;\n    } else {\n      dashArray.push(1);\n    }\n  }\n\n  return dashArray;\n}\n\nexport function colorDrivenByProperty(\n  style: DataDrivenStyle,\n  property: string,\n): DataDrivenPropertyValueSpecification<string> {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...style.map((el) => [el.value, el.color]).flat(),\n  ];\n}\n\nexport function radiusDrivenByProperty(\n  style: DataDrivenStyle,\n  property: string,\n  zoomCompensation = true,\n): DataDrivenPropertyValueSpecification<number> {\n  if (!zoomCompensation) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius]).flat(),\n    ];\n  }\n\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n\n    0,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.025]).flat(),\n    ],\n\n    2,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.05]).flat(),\n    ],\n\n    4,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.1]).flat(),\n    ],\n\n    8,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius * 0.25]).flat(),\n    ],\n\n    16,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.value, el.pointRadius]).flat(),\n    ],\n  ];\n}\n\nexport function radiusDrivenByPropertyHeatmap(\n  style: PropertyValues,\n  property: string,\n  zoomCompensation = true,\n): DataDrivenPropertyValueSpecification<number> {\n  if (!zoomCompensation) {\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value]).flat(),\n    ];\n  }\n\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n\n    0,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.025]).flat(),\n    ],\n\n    2,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.05]).flat(),\n    ],\n\n    4,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.1]).flat(),\n    ],\n\n    8,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value * 0.25]).flat(),\n    ],\n\n    16,\n    [\n      \"interpolate\",\n      [\"linear\"],\n      [\"get\", property],\n      ...style.map((el) => [el.propertyValue, el.value]).flat(),\n    ],\n  ];\n}\n\n/**\n * Turns a ColorRamp instance into a MapLibre style for ramping the opacity, driven by a property\n */\nexport function opacityDrivenByProperty(\n  colorramp: ColorRamp,\n  property: string,\n): DataDrivenPropertyValueSpecification<number> {\n  // If all opacities are the same, just return the number without any ramping logic\n  if (colorramp.every((el) => el.color[3] === colorramp[0].color[3])) {\n    return colorramp[0].color[3] ? colorramp[0].color[3] / 255 : 1;\n  }\n\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...colorramp\n      .getRawColorStops()\n      .map((el) => {\n        const value = el.value;\n        const color: RgbaColor = el.color;\n        return [value, color.length === 4 ? color[3] / 255 : 1];\n      })\n      .flat(),\n  ];\n}\n\nexport function heatmapIntensityFromColorRamp(\n  colorRamp: ColorRamp,\n  steps = 10,\n): ExpressionSpecification {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"heatmap-density\"],\n    ...Array.from({ length: steps + 1 }, (_, i) => {\n      const unitStep = i / steps;\n      return [unitStep, colorRamp.getColorHex(unitStep)];\n    }).flat(),\n  ];\n}\n","import type { Geometry, FeatureCollection, GeoJsonProperties } from \"geojson\";\nimport type {\n  DataDrivenPropertyValueSpecification,\n  PropertyValueSpecification,\n} from \"maplibre-gl\";\nimport type { Map } from \"../Map\";\nimport { config } from \"../config\";\nimport { isUUID, jsonParseNoThrow } from \"../tools\";\nimport {\n  computeRampedOutlineWidth,\n  generateRandomLayerName,\n  generateRandomSourceName,\n  getRandomColor,\n  paintColorOptionsToPaintSpec,\n  rampedOptionsToLayerPaintSpec,\n  dashArrayMaker,\n  colorDrivenByProperty,\n  radiusDrivenByProperty,\n  opacityDrivenByProperty,\n  heatmapIntensityFromColorRamp,\n  rampedPropertyValueWeight,\n  radiusDrivenByPropertyHeatmap,\n} from \"./stylehelper\";\n\nimport { gpx, gpxOrKml, kml } from \"../converters\";\nimport { ColorRampCollection, ColorRamp } from \"../colorramp\";\n\n/**\n * Array of string values that depend on zoom level\n */\nexport type ZoomStringValues = Array<{\n  /**\n   * Zoom level\n   */\n  zoom: number;\n\n  /**\n   * Value for the given zoom level\n   */\n  value: string;\n}>;\n\n/**\n *\n * Array of number values that depend on zoom level\n */\nexport type ZoomNumberValues = Array<{\n  /**\n   * Zoom level\n   */\n  zoom: number;\n\n  /**\n   * Value for the given zoom level\n   */\n  value: number;\n}>;\n\nexport type PropertyValues = Array<{\n  /**\n   * Value of the property (input)\n   */\n  propertyValue: number;\n\n  /**\n   * Value to associate it with (output)\n   */\n  value: number;\n}>;\n\n/**\n * Describes how to render a cluster of points\n */\nexport type DataDrivenStyle = Array<{\n  /**\n   * Numerical value to observe and apply the style upon.\n   * In case of clusters, the value to observe is automatically the number of elements in a cluster.\n   * In other cases, it can be a provided value.\n   */\n  value: number;\n\n  /**\n   * Radius of the cluster circle\n   */\n  pointRadius: number;\n\n  /**\n   * Color of the cluster\n   */\n  color: string;\n}>;\n\nexport type CommonShapeLayerOptions = {\n  /**\n   * ID to give to the layer.\n   * If not provided, an auto-generated ID of the for \"maptiler-layer-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  layerId?: string;\n\n  /**\n   * ID to give to the geojson source.\n   * If not provided, an auto-generated ID of the for \"maptiler-source-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  sourceId?: string;\n\n  /**\n   * A geojson Feature collection or a URL to a geojson or the UUID of a MapTiler Cloud dataset.\n   */\n  data: FeatureCollection | string;\n\n  /**\n   * The ID of an existing layer to insert the new layer before, resulting in the new layer appearing\n   * visually beneath the existing layer. If this argument is not specified, the layer will be appended\n   * to the end of the layers array and appear visually above all other layers.\n   */\n  beforeId?: string;\n\n  /**\n   * Zoom level at which it starts to show.\n   * Default: `0`\n   */\n  minzoom?: number;\n\n  /**\n   * Zoom level after which it no longer show.\n   * Default: `22`\n   */\n  maxzoom?: number;\n\n  /**\n   * Whether or not to add an outline.\n   * Default: `false`\n   */\n  outline?: boolean;\n\n  /**\n   * Color of the outline. This is can be a constant color string or a definition based on zoom levels.\n   * Applies only if `.outline` is `true`.\n   * Default: `white`\n   */\n  outlineColor?: string | ZoomStringValues;\n\n  /**\n   * Width of the outline (relative to screen-space). This is can be a constant width or a definition based on zoom levels.\n   * Applies only if `.outline` is `true`.\n   * Default: `1`\n   */\n  outlineWidth?: number | ZoomNumberValues;\n\n  /**\n   * Opacity of the outline. This is can be a constant opacity in [0, 1] or a definition based on zoom levels\n   * Applies only if `.outline` is `true`.\n   * Default: `1`\n   */\n  outlineOpacity?: number | ZoomNumberValues;\n};\n\nexport type PolylineLayerOptions = CommonShapeLayerOptions & {\n  /**\n   * Color of the line (or polyline). This is can be a constant color string or a definition based on zoom levels.\n   * Default: a color randomly pick from a list\n   */\n  lineColor?: string | ZoomStringValues;\n\n  /**\n   * Width of the line (relative to screen-space). This is can be a constant width or a definition based on zoom levels\n   * Default: `3`\n   */\n  lineWidth?: number | ZoomNumberValues;\n\n  /**\n   * Opacity of the line. This is can be a constant opacity in [0, 1] or a definition based on zoom levels.\n   * Default: `1`\n   */\n  lineOpacity?: number | ZoomNumberValues;\n\n  /**\n   * How blury the line is, with `0` being no blur and `10` and beyond being quite blurry.\n   * Default: `0`\n   */\n  lineBlur?: number | ZoomNumberValues;\n\n  /**\n   * Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.\n   * Default: `0`\n   */\n  lineGapWidth?: number | ZoomNumberValues;\n\n  /**\n   * Sequence of line and void to create a dash pattern. The unit is the line width so that\n   * a dash array value of `[3, 1]` will create a segment worth 3 times the width of the line,\n   * followed by a spacing worth 1 time the line width, and then repeat.\n   *\n   * Alternatively, this property can be a string made of underscore and whitespace characters\n   * such as `\"___ _ \"` and internaly this will be translated into [3, 1, 1, 1]. Note that\n   * this way of describing dash arrays with a string only works for integer values.\n   *\n   * Dash arrays can contain more than 2 element to create more complex patters. For instance\n   * a dash array value of [3, 2, 1, 2] will create the following sequence:\n   * - a segment worth 3 times the width\n   * - a spacing worth 2 times the width\n   * - a segment worth 1 times the width\n   * - a spacing worth 2 times the width\n   * - repeat\n   *\n   * Default: no dash pattern\n   */\n  lineDashArray?: Array<number> | string;\n\n  /**\n   * The display of line endings for both the line and the outline (if `.outline` is `true`)\n   * - \"butt\": A cap with a squared-off end which is drawn to the exact endpoint of the line.\n   * - \"round\": A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"square\": A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * Default: \"round\"\n   */\n  lineCap?: \"butt\" | \"round\" | \"square\";\n\n  /**\n   * The display of lines when joining for both the line and the outline (if `.outline` is `true`)\n   * - \"bevel\": A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * - \"round\": A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"miter\": A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.\n   * Default: \"round\"\n   */\n  lineJoin?: \"bevel\" | \"round\" | \"miter\";\n\n  /**\n   * How blury the outline is, with `0` being no blur and `10` and beyond being quite blurry.\n   * Applies only if `.outline` is `true`.\n   * Default: `0`\n   */\n  outlineBlur?: number | ZoomNumberValues;\n};\n\nexport type PolygonLayerOptions = CommonShapeLayerOptions & {\n  /**\n   * Color of the polygon. This is can be a constant color string or a definition based on zoom levels.\n   * Default: a color randomly pick from a list\n   */\n  fillColor?: string | ZoomStringValues;\n\n  /**\n   * Opacity of the polygon. This is can be a constant opacity in [0, 1] or a definition based on zoom levels\n   * Default: `1`\n   */\n  fillOpacity?: ZoomNumberValues;\n\n  /**\n   * Position of the outline with regard to the polygon edge (when `.outline` is `true`)\n   * Default: `\"center\"`\n   */\n  outlinePosition: \"center\" | \"inside\" | \"outside\";\n\n  /**\n   * Sequence of line and void to create a dash pattern. The unit is the line width so that\n   * a dash array value of `[3, 1]` will create a segment worth 3 times the width of the line,\n   * followed by a spacing worth 1 time the line width, and then repeat.\n   *\n   * Alternatively, this property can be a string made of underscore and whitespace characters\n   * such as `\"___ _ \"` and internaly this will be translated into [3, 1, 1, 1]. Note that\n   * this way of describing dash arrays with a string only works for integer values.\n   *\n   * Dash arrays can contain more than 2 element to create more complex patters. For instance\n   * a dash array value of [3, 2, 1, 2] will create the following sequence:\n   * - a segment worth 3 times the width\n   * - a spacing worth 2 times the width\n   * - a segment worth 1 times the width\n   * - a spacing worth 2 times the width\n   * - repeat\n   *\n   * Default: no dash pattern\n   */\n  outlineDashArray?: Array<number> | string;\n\n  /**\n   * The display of line endings for both the line and the outline (if `.outline` is `true`)\n   * - \"butt\": A cap with a squared-off end which is drawn to the exact endpoint of the line.\n   * - \"round\": A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"square\": A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * Default: \"round\"\n   */\n  outlineCap?: \"butt\" | \"round\" | \"square\";\n\n  /**\n   * The display of lines when joining for both the line and the outline (if `.outline` is `true`)\n   * - \"bevel\": A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * - \"round\": A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"miter\": A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.\n   * Default: \"round\"\n   */\n  outlineJoin?: \"bevel\" | \"round\" | \"miter\";\n\n  /**\n   * The pattern is an image URL to be put as a repeated background pattern of the polygon.\n   * Default: `null` (no pattern, `fillColor` will be used)\n   */\n  pattern?: string | null;\n\n  /**\n   * How blury the outline is, with `0` being no blur and `10` and beyond being quite blurry.\n   * Applies only if `.outline` is `true`.\n   * Default: `0`\n   */\n  outlineBlur?: number | ZoomNumberValues;\n};\n\nexport type PointLayerOptions = CommonShapeLayerOptions & {\n  /**\n   * Can be a unique point color as a string (CSS color such as \"#FF0000\" or \"red\").\n   * Alternatively, the color can be a ColorRamp with a range.\n   * In case of `.cluster` being `true`, the range of the ColorRamp will be addressed with the number of elements in\n   * the cluster. If `.cluster` is `false`, the color will be addressed using the value of the `.property`.\n   * If no `.property` is given but `.pointColor` is a ColorRamp, the chosen color is the one at the lower bound of the ColorRamp.\n   * Default: a color randomly pick from a list\n   */\n  pointColor?: string | ColorRamp;\n\n  /**\n   * Radius of the points. Can be a fixed size or a value dependant on the zoom.\n   * If `.pointRadius` is not provided, the radius will depend on the size of each cluster (if `.cluster` is `true`)\n   * or on the value of each point (if `.property` is provided and `.pointColor` is a ColorRamp).\n   * The radius will be between `.minPointRadius` and `.maxPointRadius`\n   */\n  pointRadius?: number | ZoomNumberValues;\n\n  /**\n   * The minimum point radius posible.\n   * Default: `10`\n   */\n  minPointRadius?: number;\n\n  /**\n   * The maximum point radius posible.\n   * Default: `40`\n   */\n  maxPointRadius?: number;\n\n  /**\n   * The point property to observe and apply the radius and color upon.\n   * This is ignored if `.cluster` is `true` as the observed value will be fiorced to being the number\n   * of elements in each cluster.\n   *\n   * Default: none\n   */\n  property?: string;\n\n  /**\n   * Opacity of the point or icon. This is can be a constant opacity in [0, 1] or a definition based on zoom levels.\n   * Alternatively, if not provided but the `.pointColor` is a ColorRamp, the opacity will be extracted from tha alpha\n   * component if present.\n   * Default: `1`\n   */\n  pointOpacity?: number | ZoomNumberValues;\n\n  /**\n   * If `true`, the points will keep their circular shape align with the wiewport.\n   * If `false`, the points will be like flatten on the map. This difference shows\n   * when the map is tilted.\n   * Default: `true`\n   */\n  alignOnViewport?: boolean;\n\n  /**\n   * Whether the points should cluster\n   */\n  cluster?: boolean;\n\n  /**\n   * Shows a label with the numerical value id `true`.\n   * If `.cluster` is `true`, the value will be the numebr of elements in the cluster.\n   *\n   *\n   * Default: `true` if `cluster` or `dataDrivenStyleProperty` are used, `false` otherwise.\n   */\n  showLabel?: boolean;\n\n  /**\n   * text color used for the number elements in each cluster.\n   * Applicable only when `cluster` is `true`.\n   * Default: `#000000` (black)\n   */\n  labelColor?: string;\n\n  /**\n   * text size used for the number elements in each cluster.\n   * Applicable only when `cluster` is `true`.\n   * Default: `12`\n   */\n  labelSize?: number;\n\n  /**\n   * Only if `.cluster` is `false`.\n   * If the radius is driven by a property, then it will also scale by zoomming if `.zoomCompensation` is `true`.\n   * If `false`, the radius will not adapt according to the zoom level.\n   * Default: `true`\n   */\n  zoomCompensation?: boolean;\n};\n\nexport type HeatmapLayerOptions = {\n  /**\n   * ID to give to the layer.\n   * If not provided, an auto-generated ID of the for \"maptiler-layer-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  layerId?: string;\n\n  /**\n   * ID to give to the geojson source.\n   * If not provided, an auto-generated ID of the for \"maptiler-source-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  sourceId?: string;\n\n  /**\n   * A geojson Feature collection or a URL to a geojson or the UUID of a MapTiler Cloud dataset.\n   */\n  data: FeatureCollection | string;\n\n  /**\n   * The ID of an existing layer to insert the new layer before, resulting in the new layer appearing\n   * visually beneath the existing layer. If this argument is not specified, the layer will be appended\n   * to the end of the layers array and appear visually above all other layers.\n   */\n  beforeId?: string;\n\n  /**\n   * Zoom level at which it starts to show.\n   * Default: `0`\n   */\n  minzoom?: number;\n\n  /**\n   * Zoom level after which it no longer show.\n   * Default: `22`\n   */\n  maxzoom?: number;\n\n  /**\n   * The ColorRamp instance to use for visualization. The color ramp is expected to be defined in the\n   * range `[0, 1]` or else will be forced to this range.\n   * Default: `ColorRampCollection.TURBO`\n   */\n  colorRamp?: ColorRamp;\n\n  /**\n   * Use a property to apply a weight to each data point. Using a property requires also using\n   * the options `.propertyValueWeight` or otherwise will be ignored.\n   * Default: none, the points will all have a weight of `1`.\n   */\n  property?: string;\n\n  /**\n   * The weight to give to each data point. If of type `PropertyValueWeights`, then the options `.property`\n   * must also be provided. If used a number, all data points will be weighted by the same number (which is of little interest)\n   */\n  weight?: PropertyValues | number;\n\n  /**\n   * The radius (in screenspace) can be:\n   * - a fixed number that will be constant across zoom level\n   * - of type `ZoomNumberValues` to be ramped accoding to zoom level (`.zoomCompensation` will then be ignored)\n   * - of type `PropertyValues` to be driven by the value of a property.\n   *   If so, the option `.property` must be provided and will still be resized according to zoom level,\n   *   unless the option `.zoomCompensation` is set to `false`.\n   *\n   * Default:\n   */\n  radius?: number | ZoomNumberValues | PropertyValues;\n\n  /**\n   * The opacity can be a fixed value or zoom-driven.\n   * Default: fades-in 0.25z after minzoom and fade-out 0.25z before maxzoom\n   */\n  opacity?: number | ZoomNumberValues;\n\n  /**\n   * The intensity is zoom-dependent. By default, the intensity is going to be scaled by zoom to preserve\n   * a natural aspect or the data distribution.\n   */\n  intensity?: number | ZoomNumberValues;\n\n  /**\n   * If the radius is driven by a property, then it will also scale by zoomming if `.zoomCompensation` is `true`.\n   * If `false`, the radius will not adapt according to the zoom level.\n   * Default: `true`\n   */\n  zoomCompensation?: boolean;\n};\n\n/**\n * Add a polyline to the map from various sources and with builtin styling.\n * Compatible sources:\n * - gpx content as string\n * - gpx file from URL\n * - kml content from string\n * - kml from url\n * - geojson from url\n * - geojson content as string\n * - geojson content as JS object\n * - uuid of a MapTiler Cloud dataset\n *\n * The method also gives the possibility to add an outline layer (if `options.outline` is `true`)\n * and if so , the returned property `polylineOutlineLayerId` will be a string. As a result, two layers\n * would be added.\n *\n * The default styling creates a line layer of constant width of 3px, the color will be randomly picked\n * from a curated list of colors and the opacity will be 1.\n * If the outline is enabled, the outline width is of 1px at all zoom levels, the color is white and\n * the opacity is 1.\n *\n * Those style properties can be changed and ramped according to zoom level using an easier syntax.\n *\n */\nexport async function addPolyline(\n  /**\n   * Map instance to add a polyline layer to\n   */\n  map: Map,\n  /**\n   * Options related to adding a polyline layer\n   */\n  options: PolylineLayerOptions,\n  /**\n   * When the polyline data is loaded from a distant source, these options are propagated to the call of `fetch`\n   */\n  fetchOptions: RequestInit = {},\n): Promise<{\n  polylineLayerId: string;\n  polylineOutlineLayerId: string;\n  polylineSourceId: string;\n}> {\n  // We need to have the sourceId of the sourceData\n  if (!options.sourceId && !options.data) {\n    throw new Error(\n      \"Creating a polyline layer requires an existing .sourceId or a valid .data property\",\n    );\n  }\n\n  // We are going to evaluate the content of .data, if provided\n  let data = options.data;\n\n  if (typeof data === \"string\") {\n    // if options.data exists and is a uuid string, we consider that it points to a MapTiler Dataset\n    if (isUUID(data)) {\n      data = `https://api.maptiler.com/data/${options.data}/features.json?key=${config.apiKey}`;\n    }\n\n    // options.data could be a url to a .gpx file\n    else if (data.split(\".\").pop()?.toLowerCase().trim() === \"gpx\") {\n      // fetch the file\n      const res = await fetch(data, fetchOptions);\n      const gpxStr = await res.text();\n      // Convert it to geojson. Will throw is invalid GPX content\n      data = gpx(gpxStr);\n    }\n\n    // options.data could be a url to a .kml file\n    else if (data.split(\".\").pop()?.toLowerCase().trim() === \"kml\") {\n      // fetch the file\n      const res = await fetch(data, fetchOptions);\n      const kmlStr = await res.text();\n      // Convert it to geojson. Will throw is invalid GPX content\n      data = kml(kmlStr);\n    } else {\n      // From this point, we consider that the string content provided could\n      // be the string content of one of the compatible format (GeoJSON, KML, GPX)\n      const tmpData =\n        jsonParseNoThrow<FeatureCollection<Geometry, GeoJsonProperties>>(\n          data,\n        ) ?? gpxOrKml(data);\n      if (tmpData) data = tmpData;\n    }\n\n    if (!data) {\n      throw new Error(\n        \"Polyline data was provided as string but is incompatible with valid formats.\",\n      );\n    }\n  }\n\n  return addGeoJSONPolyline(map, {\n    ...options,\n    data,\n  });\n}\n\n/**\n * Add a polyline from a GeoJSON object\n */\nfunction addGeoJSONPolyline(\n  map: Map,\n  // The data or data source is expected to contain LineStrings or MultiLineStrings\n  options: PolylineLayerOptions,\n): {\n  /**\n   * ID of the main line layer\n   */\n  polylineLayerId: string;\n\n  /**\n   * ID of the outline layer (will be `\"\"` if no outline)\n   */\n  polylineOutlineLayerId: string;\n\n  /**\n   * ID of the data source\n   */\n  polylineSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`,\n    );\n  }\n\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n\n  const returnedInfo = {\n    polylineLayerId: layerId,\n    polylineOutlineLayerId: \"\",\n    polylineSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: options.data,\n    });\n  }\n\n  const lineWidth = options.lineWidth ?? 3;\n  const lineColor = options.lineColor ?? getRandomColor();\n  const lineOpacity = options.lineOpacity ?? 1;\n  const lineBlur = options.lineBlur ?? 0;\n  const lineGapWidth = options.lineGapWidth ?? 0;\n  let lineDashArray = options.lineDashArray ?? null;\n  const outlineWidth = options.outlineWidth ?? 1;\n  const outlineColor = options.outlineColor ?? \"#FFFFFF\";\n  const outlineOpacity = options.outlineOpacity ?? 1;\n  const outlineBlur = options.outlineBlur ?? 0;\n\n  if (typeof lineDashArray === \"string\") {\n    lineDashArray = dashArrayMaker(lineDashArray);\n  }\n\n  // We want to create an outline for this line layer\n  if (options.outline === true) {\n    const outlineLayerId = `${layerId}_outline`;\n    returnedInfo.polylineOutlineLayerId = outlineLayerId;\n\n    map.addLayer(\n      {\n        id: outlineLayerId,\n        type: \"line\",\n        source: sourceId,\n        layout: {\n          \"line-join\": options.lineJoin ?? \"round\",\n          \"line-cap\": options.lineCap ?? \"round\",\n        },\n        minzoom: options.minzoom ?? 0,\n        maxzoom: options.maxzoom ?? 23,\n        paint: {\n          \"line-opacity\":\n            typeof outlineOpacity === \"number\"\n              ? outlineOpacity\n              : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"line-color\":\n            typeof outlineColor === \"string\"\n              ? outlineColor\n              : paintColorOptionsToPaintSpec(outlineColor),\n          \"line-width\": computeRampedOutlineWidth(lineWidth, outlineWidth),\n          \"line-blur\":\n            typeof outlineBlur === \"number\"\n              ? outlineBlur\n              : rampedOptionsToLayerPaintSpec(outlineBlur),\n        },\n      },\n      options.beforeId,\n    );\n  }\n\n  map.addLayer(\n    {\n      id: layerId,\n      type: \"line\",\n      source: sourceId,\n      layout: {\n        \"line-join\": options.lineJoin ?? \"round\",\n        \"line-cap\": options.lineCap ?? \"round\",\n      },\n      minzoom: options.minzoom ?? 0,\n      maxzoom: options.maxzoom ?? 23,\n      paint: {\n        \"line-opacity\":\n          typeof lineOpacity === \"number\"\n            ? lineOpacity\n            : rampedOptionsToLayerPaintSpec(lineOpacity),\n        \"line-color\":\n          typeof lineColor === \"string\"\n            ? lineColor\n            : paintColorOptionsToPaintSpec(lineColor),\n        \"line-width\":\n          typeof lineWidth === \"number\"\n            ? lineWidth\n            : rampedOptionsToLayerPaintSpec(lineWidth),\n\n        \"line-blur\":\n          typeof lineBlur === \"number\"\n            ? lineBlur\n            : rampedOptionsToLayerPaintSpec(lineBlur),\n\n        \"line-gap-width\":\n          typeof lineGapWidth === \"number\"\n            ? lineGapWidth\n            : rampedOptionsToLayerPaintSpec(lineGapWidth),\n\n        // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n        // results in no showing the line while it should have the same behavior\n        // of not adding the property \"line-dasharray\" as all.\n        // As a workaround, we are inlining the addition of the prop with a conditional\n        // which is less readable.\n        ...(lineDashArray && { \"line-dasharray\": lineDashArray }),\n      },\n    },\n    options.beforeId,\n  );\n\n  return returnedInfo;\n}\n\n/**\n * Add a polygon with styling options.\n */\nexport function addPolygon(\n  map: Map,\n  // this Feature collection is expected to contain on LineStrings and MultiLinestrings\n  options: PolygonLayerOptions,\n): {\n  /**\n   * ID of the fill layer\n   */\n  polygonLayerId: string;\n\n  /**\n   * ID of the outline layer (will be `\"\"` if no outline)\n   */\n  polygonOutlineLayerId: string;\n\n  /**\n   * ID of the source that contains the data\n   */\n  polygonSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`,\n    );\n  }\n\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n\n  const returnedInfo = {\n    polygonLayerId: layerId,\n    polygonOutlineLayerId: options.outline ? `${layerId}_outline` : \"\",\n    polygonSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    let data: string | FeatureCollection = options.data;\n\n    // If is a UUID, we extend it to be the URL to a MapTiler Cloud hosted dataset\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: data,\n    });\n  }\n\n  let outlineDashArray = options.outlineDashArray ?? null;\n  const outlineWidth = options.outlineWidth ?? 1;\n  const outlineColor = options.outlineColor ?? \"#FFFFFF\";\n  const outlineOpacity = options.outlineOpacity ?? 1;\n  const outlineBlur = options.outlineBlur ?? 0;\n  const fillColor = options.fillColor ?? getRandomColor();\n  const fillOpacity = options.fillOpacity ?? 1;\n  const outlinePosition = options.outlinePosition ?? \"center\";\n  const pattern = options.pattern ?? null;\n\n  if (typeof outlineDashArray === \"string\") {\n    outlineDashArray = dashArrayMaker(outlineDashArray);\n  }\n\n  const addLayers = (patternImageId: string | null = null) => {\n    map.addLayer(\n      {\n        id: layerId,\n        type: \"fill\",\n        source: sourceId,\n        minzoom: options.minzoom ?? 0,\n        maxzoom: options.maxzoom ?? 23,\n        paint: {\n          \"fill-color\":\n            typeof fillColor === \"string\"\n              ? fillColor\n              : paintColorOptionsToPaintSpec(fillColor),\n\n          \"fill-opacity\":\n            typeof fillOpacity === \"number\"\n              ? fillOpacity\n              : rampedOptionsToLayerPaintSpec(fillOpacity),\n\n          // Adding a pattern if provided\n          ...(patternImageId && { \"fill-pattern\": patternImageId }),\n        },\n      },\n      options.beforeId,\n    );\n\n    // We want to create an outline for this line layer\n    if (options.outline === true) {\n      let computedOutlineOffset:\n        | DataDrivenPropertyValueSpecification<number>\n        | number;\n\n      if (outlinePosition === \"inside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = 0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map(({ zoom, value }) => ({\n              zoom,\n              value: 0.5 * value,\n            })),\n          );\n        }\n      } else if (outlinePosition === \"outside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = -0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map((el) => ({\n              zoom: el.zoom,\n              value: -0.5 * el.value,\n            })),\n          );\n        }\n      } else {\n        computedOutlineOffset = 0;\n      }\n\n      map.addLayer(\n        {\n          id: returnedInfo.polygonOutlineLayerId,\n          type: \"line\",\n          source: sourceId,\n          layout: {\n            \"line-join\": options.outlineJoin ?? \"round\",\n            \"line-cap\": options.outlineCap ?? \"butt\",\n          },\n          minzoom: options.minzoom ?? 0,\n          maxzoom: options.maxzoom ?? 23,\n          paint: {\n            \"line-opacity\":\n              typeof outlineOpacity === \"number\"\n                ? outlineOpacity\n                : rampedOptionsToLayerPaintSpec(outlineOpacity),\n            \"line-color\":\n              typeof outlineColor === \"string\"\n                ? outlineColor\n                : paintColorOptionsToPaintSpec(outlineColor),\n            \"line-width\":\n              typeof outlineWidth === \"number\"\n                ? outlineWidth\n                : rampedOptionsToLayerPaintSpec(outlineWidth),\n            \"line-blur\":\n              typeof outlineBlur === \"number\"\n                ? outlineBlur\n                : rampedOptionsToLayerPaintSpec(outlineBlur),\n\n            \"line-offset\": computedOutlineOffset,\n\n            // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n            // results in no showing the line while it should have the same behavior\n            // of not adding the property \"line-dasharray\" as all.\n            // As a workaround, we are inlining the addition of the prop with a conditional\n            // which is less readable.\n            ...(outlineDashArray && {\n              \"line-dasharray\": outlineDashArray as PropertyValueSpecification<\n                number[]\n              >,\n            }),\n          },\n        },\n        options.beforeId,\n      );\n    }\n  };\n\n  if (pattern) {\n    if (map.hasImage(pattern)) {\n      addLayers(pattern);\n    } else {\n      map.loadImage(\n        pattern,\n\n        // (error?: Error | null, image?: HTMLImageElement | ImageBitmap | null, expiry?: ExpiryData | null)\n        (\n          error: Error | null | undefined,\n          image: HTMLImageElement | ImageBitmap | null | undefined,\n        ) => {\n          // Throw an error if something goes wrong.\n          if (error) {\n            console.error(\"Could not load the pattern image.\", error.message);\n            return addLayers();\n          }\n\n          if (!image) {\n            console.error(\n              `An image cannot be created from the pattern URL ${pattern}.`,\n            );\n            return addLayers();\n          }\n\n          // Add the image to the map style, using the image URL as an ID\n          map.addImage(pattern, image);\n\n          addLayers(pattern);\n        },\n      );\n    }\n  } else {\n    addLayers();\n  }\n\n  return returnedInfo;\n}\n\n/**\n * Add a point layer from a GeoJSON source (or an existing sourceId) with many styling options\n */\nexport function addPoint(\n  /**\n   * The Map instance to add a point layer to\n   */\n  map: Map,\n  // The data or data source is expected to contain LineStrings or MultiLineStrings\n  options: PointLayerOptions,\n): {\n  /**\n   * ID of the unclustered point layer\n   */\n  pointLayerId: string;\n\n  /**\n   * ID of the clustered point layer (empty if `cluster` options id `false`)\n   */\n  clusterLayerId: string;\n\n  /**\n   * ID of the layer that shows the count of elements in each cluster (empty if `cluster` options id `false`)\n   */\n  labelLayerId: string;\n\n  /**\n   * ID of the data source\n   */\n  pointSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`,\n    );\n  }\n\n  const minPointRadius = options.minPointRadius ?? 10;\n  const maxPointRadius = options.maxPointRadius ?? 50;\n  const cluster = options.cluster ?? false;\n  const nbDefaultDataDrivenStyleSteps = 20;\n  const colorramp = Array.isArray(options.pointColor)\n    ? options.pointColor\n    : ColorRampCollection.TURBO.scale(\n        10,\n        options.cluster ? 10000 : 1000,\n      ).resample(\"ease-out-square\");\n  const colorRampBounds = colorramp.getBounds();\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n  const showLabel = options.showLabel ?? cluster;\n  const alignOnViewport = options.alignOnViewport ?? true;\n  const outline = options.outline ?? false;\n  const outlineOpacity = options.outlineOpacity ?? 1;\n  const outlineWidth = options.outlineWidth ?? 1;\n  const outlineColor = options.outlineColor ?? \"#FFFFFF\";\n  let pointOpacity;\n  const zoomCompensation = options.zoomCompensation ?? true;\n  const minzoom = options.minzoom ?? 0;\n  const maxzoom = options.maxzoom ?? 23;\n\n  if (typeof options.pointOpacity === \"number\") {\n    pointOpacity = options.pointOpacity;\n  } else if (Array.isArray(options.pointOpacity)) {\n    pointOpacity = rampedOptionsToLayerPaintSpec(options.pointOpacity);\n  } else if (options.cluster) {\n    pointOpacity = opacityDrivenByProperty(colorramp, \"point_count\");\n  } else if (options.property) {\n    pointOpacity = opacityDrivenByProperty(colorramp, options.property);\n  } else {\n    pointOpacity = rampedOptionsToLayerPaintSpec([\n      { zoom: minzoom, value: 0 },\n      { zoom: minzoom + 0.25, value: 1 },\n      { zoom: maxzoom - 0.25, value: 1 },\n      { zoom: maxzoom, value: 0 },\n    ]);\n  }\n\n  const returnedInfo = {\n    pointLayerId: layerId,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    let data: string | FeatureCollection = options.data;\n\n    // If is a UUID, we extend it to be the URL to a MapTiler Cloud hosted dataset\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: data,\n      cluster,\n    });\n  }\n\n  if (cluster) {\n    // If using clusters, the size and color of the circles (clusters) are driven by the\n    // numbner of elements they contain and cannot be driven by the zoom level or a property\n\n    returnedInfo.clusterLayerId = `${layerId}_cluster`;\n\n    const clusterStyle: DataDrivenStyle = Array.from(\n      { length: nbDefaultDataDrivenStyleSteps },\n      (_, i) => {\n        const value =\n          colorRampBounds.min +\n          (i * (colorRampBounds.max - colorRampBounds.min)) /\n            (nbDefaultDataDrivenStyleSteps - 1);\n        return {\n          value,\n          pointRadius:\n            minPointRadius +\n            (maxPointRadius - minPointRadius) *\n              Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n          color: colorramp.getColorHex(value),\n        };\n      },\n    );\n\n    map.addLayer(\n      {\n        id: returnedInfo.clusterLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"has\", \"point_count\"],\n        paint: {\n          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-color\":\n            typeof options.pointColor === \"string\"\n              ? options.pointColor\n              : colorDrivenByProperty(clusterStyle, \"point_count\"),\n\n          \"circle-radius\":\n            typeof options.pointRadius === \"number\"\n              ? options.pointRadius\n              : Array.isArray(options.pointRadius)\n              ? rampedOptionsToLayerPaintSpec(options.pointRadius)\n              : radiusDrivenByProperty(clusterStyle, \"point_count\", false),\n\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\", // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-opacity\": pointOpacity,\n          ...(outline && {\n            \"circle-stroke-opacity\":\n              typeof outlineOpacity === \"number\"\n                ? outlineOpacity\n                : rampedOptionsToLayerPaintSpec(outlineOpacity),\n\n            \"circle-stroke-width\":\n              typeof outlineWidth === \"number\"\n                ? outlineWidth\n                : rampedOptionsToLayerPaintSpec(outlineWidth),\n\n            \"circle-stroke-color\":\n              typeof outlineColor === \"string\"\n                ? outlineColor\n                : paintColorOptionsToPaintSpec(outlineColor),\n          }),\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n\n    // Adding the layer of unclustered point (visible only when ungrouped)\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"!\", [\"has\", \"point_count\"]],\n        paint: {\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\", // scale with camera distance regardless of viewport/biewport alignement\n          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n          \"circle-color\":\n            typeof options.pointColor === \"string\"\n              ? options.pointColor\n              : colorramp.getColorHex(colorramp.getBounds().min),\n          \"circle-radius\":\n            typeof options.pointRadius === \"number\"\n              ? options.pointRadius\n              : Array.isArray(options.pointRadius)\n              ? rampedOptionsToLayerPaintSpec(options.pointRadius)\n              : clusterStyle[0].pointRadius * 0.75,\n          \"circle-opacity\": pointOpacity,\n          ...(outline && {\n            \"circle-stroke-opacity\":\n              typeof outlineOpacity === \"number\"\n                ? outlineOpacity\n                : rampedOptionsToLayerPaintSpec(outlineOpacity),\n\n            \"circle-stroke-width\":\n              typeof outlineWidth === \"number\"\n                ? outlineWidth\n                : rampedOptionsToLayerPaintSpec(outlineWidth),\n\n            \"circle-stroke-color\":\n              typeof outlineColor === \"string\"\n                ? outlineColor\n                : paintColorOptionsToPaintSpec(outlineColor),\n          }),\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n  }\n\n  // Not displaying clusters\n  else {\n    let pointColor: DataDrivenPropertyValueSpecification<string> =\n      typeof options.pointColor === \"string\"\n        ? options.pointColor\n        : Array.isArray(options.pointColor)\n        ? options.pointColor.getColorHex(options.pointColor.getBounds().min) // if color ramp is given, we choose the first color of it, even if the property may not be provided\n        : getRandomColor();\n\n    let pointRadius: DataDrivenPropertyValueSpecification<number> =\n      typeof options.pointRadius === \"number\"\n        ? zoomCompensation\n          ? rampedOptionsToLayerPaintSpec([\n              { zoom: 0, value: options.pointRadius * 0.025 },\n              { zoom: 2, value: options.pointRadius * 0.05 },\n              { zoom: 4, value: options.pointRadius * 0.1 },\n              { zoom: 8, value: options.pointRadius * 0.25 },\n              { zoom: 16, value: options.pointRadius * 1 },\n            ])\n          : options.pointRadius\n        : Array.isArray(options.pointRadius)\n        ? rampedOptionsToLayerPaintSpec(options.pointRadius)\n        : zoomCompensation\n        ? rampedOptionsToLayerPaintSpec([\n            { zoom: 0, value: minPointRadius * 0.05 },\n            { zoom: 2, value: minPointRadius * 0.1 },\n            { zoom: 4, value: minPointRadius * 0.2 },\n            { zoom: 8, value: minPointRadius * 0.5 },\n            { zoom: 16, value: minPointRadius * 1 },\n          ])\n        : minPointRadius;\n\n    // If the styling depends on a property, then we build a custom style\n    if (options.property && Array.isArray(options.pointColor)) {\n      const dataDrivenStyle: DataDrivenStyle = Array.from(\n        { length: nbDefaultDataDrivenStyleSteps },\n        (_, i) => {\n          const value =\n            colorRampBounds.min +\n            (i * (colorRampBounds.max - colorRampBounds.min)) /\n              (nbDefaultDataDrivenStyleSteps - 1);\n          return {\n            value,\n            pointRadius:\n              typeof options.pointRadius === \"number\"\n                ? options.pointRadius\n                : minPointRadius +\n                  (maxPointRadius - minPointRadius) *\n                    Math.pow(i / (nbDefaultDataDrivenStyleSteps - 1), 0.5),\n            color:\n              typeof options.pointColor === \"string\"\n                ? options.pointColor\n                : colorramp.getColorHex(value),\n          };\n        },\n      );\n      pointColor = colorDrivenByProperty(dataDrivenStyle, options.property);\n      pointRadius = radiusDrivenByProperty(\n        dataDrivenStyle,\n        options.property,\n        zoomCompensation,\n      );\n    }\n\n    // Adding the layer of unclustered point\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        layout: {\n          // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n          \"circle-sort-key\": options.property\n            ? [\"/\", 1, [\"get\", options.property]]\n            : 0,\n        },\n        paint: {\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\", // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-color\": pointColor,\n          \"circle-opacity\": pointOpacity,\n          \"circle-radius\": pointRadius,\n\n          ...(outline && {\n            \"circle-stroke-opacity\":\n              typeof outlineOpacity === \"number\"\n                ? outlineOpacity\n                : rampedOptionsToLayerPaintSpec(outlineOpacity),\n\n            \"circle-stroke-width\":\n              typeof outlineWidth === \"number\"\n                ? outlineWidth\n                : rampedOptionsToLayerPaintSpec(outlineWidth),\n\n            \"circle-stroke-color\":\n              typeof outlineColor === \"string\"\n                ? outlineColor\n                : paintColorOptionsToPaintSpec(outlineColor),\n          }),\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n  }\n\n  if (showLabel !== false && (options.cluster || options.property)) {\n    returnedInfo.labelLayerId = `${layerId}_label`;\n    const labelColor = options.labelColor ?? \"#fff\";\n    const labelSize = options.labelSize ?? 12;\n\n    // With clusters, a layer with clouster count is also added\n    map.addLayer(\n      {\n        id: returnedInfo.labelLayerId,\n        type: \"symbol\",\n        source: sourceId,\n        filter: [\n          \"has\",\n          options.cluster ? \"point_count\" : (options.property as string),\n        ],\n        layout: {\n          \"text-field\": options.cluster\n            ? \"{point_count_abbreviated}\"\n            : `{${options.property as string}}`,\n          \"text-font\": [\"Noto Sans Regular\"],\n          \"text-size\": labelSize,\n          \"text-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"symbol-sort-key\": [\n            \"/\",\n            1,\n            [\n              \"get\",\n              options.cluster ? \"point_count\" : (options.property as string),\n            ],\n          ], // so that the largest value goes on top\n        },\n        paint: {\n          \"text-color\": labelColor,\n          \"text-opacity\": pointOpacity,\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n  }\n  return returnedInfo;\n}\n\n/**\n * Add a polyline witgh optional outline from a GeoJSON object\n */\nexport function addHeatmap(\n  /**\n   * Map instance to add a heatmap layer to\n   */\n  map: Map,\n  // The data or data source is expected to contain LineStrings or MultiLineStrings\n  options: HeatmapLayerOptions,\n): {\n  /**\n   * ID of the heatmap layer\n   */\n  heatmapLayerId: string;\n\n  /**\n   * ID of the data source\n   */\n  heatmapSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(\n      `A layer already exists with the layer id: ${options.layerId}`,\n    );\n  }\n\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n  const minzoom = options.minzoom ?? 0;\n  const maxzoom = options.maxzoom ?? 23;\n  const zoomCompensation = options.zoomCompensation ?? true;\n\n  const opacity = options.opacity ?? [\n    { zoom: minzoom, value: 0 },\n    { zoom: minzoom + 0.25, value: 1 },\n    { zoom: maxzoom - 0.25, value: 1 },\n    { zoom: maxzoom, value: 0 },\n  ];\n\n  // const colorRamp = \"colorRamp\" in options\n  let colorRamp = Array.isArray(options.colorRamp)\n    ? options.colorRamp\n    : ColorRampCollection.TURBO.transparentStart();\n\n  // making sure the color ramp has [0, 1] bounds\n  const crBounds = colorRamp.getBounds();\n  if (crBounds.min !== 0 || crBounds.max !== 1) {\n    colorRamp = colorRamp.scale(0, 1);\n  }\n\n  // making sure the color ramp has is transparent in 0\n  if (!colorRamp.hasTransparentStart()) {\n    colorRamp = colorRamp.transparentStart();\n  }\n\n  const intensity = options.intensity ?? [\n    { zoom: 0, value: 0.01 },\n    { zoom: 4, value: 0.2 },\n    { zoom: 16, value: 1 },\n  ];\n\n  const property = options.property ?? null;\n  const propertyValueWeight = options.weight ?? 1;\n\n  let heatmapWeight: DataDrivenPropertyValueSpecification<number> = 1; // = typeof propertyValueWeights === \"number\" ? propertyValueWeights : 1;\n\n  if (property) {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n\n      // In case this numerical weight was provided by the user and not be the default value:\n      if (typeof options.weight === \"number\") {\n        console.warn(\n          \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\",\n        );\n      }\n    } else if (Array.isArray(propertyValueWeight)) {\n      heatmapWeight = rampedPropertyValueWeight(propertyValueWeight, property);\n    } else {\n      console.warn(\n        \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\",\n      );\n    }\n  } else {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n    } else if (Array.isArray(propertyValueWeight)) {\n      console.warn(\n        \"The options `.propertyValueWeights` can only be used when `.property` is provided.\",\n      );\n    }\n  }\n\n  const defaultRadiusZoomRamping = [\n    { zoom: 0, value: 50 * 0.025 },\n    { zoom: 2, value: 50 * 0.05 },\n    { zoom: 4, value: 50 * 0.1 },\n    { zoom: 8, value: 50 * 0.25 },\n    { zoom: 16, value: 50 },\n  ];\n\n  const radius =\n    options.radius ?? (zoomCompensation ? defaultRadiusZoomRamping : 10);\n\n  let radiusHeatmap: DataDrivenPropertyValueSpecification<number> = 1;\n\n  if (typeof radius === \"number\") {\n    radiusHeatmap = radius;\n  }\n\n  // Radius is provided as a zoom-ramping array\n  else if (Array.isArray(radius) && \"zoom\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(radius as ZoomNumberValues);\n  }\n\n  // Radius is provided as data driven\n  else if (property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = radiusDrivenByPropertyHeatmap(\n      radius as unknown as PropertyValues,\n      property,\n      zoomCompensation,\n    );\n  } else if (\n    !property &&\n    Array.isArray(radius) &&\n    \"propertyValue\" in radius[0]\n  ) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(\n      defaultRadiusZoomRamping as ZoomNumberValues,\n    );\n    console.warn(\n      \"The option `.radius` can only be property-driven if the option `.property` is provided.\",\n    );\n  } else {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(\n      defaultRadiusZoomRamping as ZoomNumberValues,\n    );\n  }\n\n  const returnedInfo = {\n    heatmapLayerId: layerId,\n    heatmapSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    let data: string | FeatureCollection = options.data;\n\n    // If is a UUID, we extend it to be the URL to a MapTiler Cloud hosted dataset\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: data,\n    });\n  }\n\n  map.addLayer({\n    id: layerId,\n    type: \"heatmap\",\n    source: sourceId,\n    minzoom,\n    maxzoom,\n    paint: {\n      \"heatmap-weight\": heatmapWeight,\n\n      \"heatmap-intensity\":\n        typeof intensity === \"number\"\n          ? intensity\n          : (rampedOptionsToLayerPaintSpec(\n              intensity,\n            ) as PropertyValueSpecification<number>),\n\n      \"heatmap-color\": heatmapIntensityFromColorRamp(colorRamp),\n\n      \"heatmap-radius\": radiusHeatmap,\n\n      \"heatmap-opacity\":\n        typeof opacity === \"number\"\n          ? opacity\n          : (rampedOptionsToLayerPaintSpec(\n              opacity,\n            ) as PropertyValueSpecification<number>),\n    },\n  });\n\n  return returnedInfo;\n}\n","import {\n  addPolyline,\n  addPolygon,\n  addPoint,\n  addHeatmap,\n} from \"./vectorlayerhelpers\";\n\nexport type {\n  ZoomStringValues,\n  ZoomNumberValues,\n  PropertyValues,\n  CommonShapeLayerOptions,\n  PolylineLayerOptions,\n  PolygonLayerOptions,\n  PointLayerOptions,\n  HeatmapLayerOptions,\n} from \"./vectorlayerhelpers\";\n\n/**\n * Helpers are a set of functions to facilitate the creation of sources and layers\n */\nexport const helpers = {\n  addPolyline,\n  addPolygon,\n  addPoint,\n  addHeatmap,\n};\n","/**\n * Maplibre export first, then extensions can overload the exports.\n */\nexport * from \"maplibre-gl\";\n/**\n * To perform explicit named export so that they are included in the UMD bundle\n */\n// import * as ML from \"maplibre-gl\";\nimport maplibregl from \"maplibre-gl\";\nconst {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol,\n} = maplibregl;\n// We still want to export maplibregl.Map, but as a different name\nconst MapMLGL = maplibregl.Map;\nconst MarkerMLGL = maplibregl.Marker;\nconst PopupMLGL = maplibregl.Popup;\nconst StyleMLGL = maplibregl.Style;\nconst CanvasSourceMLGL = maplibregl.CanvasSource;\nconst GeoJSONSourceMLGL = maplibregl.GeoJSONSource;\nconst ImageSourceMLGL = maplibregl.ImageSource;\nconst RasterTileSourceMLGL = maplibregl.RasterTileSource;\nconst RasterDEMTileSourceMLGL = maplibregl.RasterDEMTileSource;\nconst VectorTileSourceMLGL = maplibregl.VectorTileSource;\nconst VideoSourceMLGL = maplibregl.VideoSource;\nconst NavigationControlMLGL = maplibregl.NavigationControl;\nconst GeolocateControlMLGL = maplibregl.GeolocateControl;\nconst AttributionControlMLGL = maplibregl.AttributionControl;\nconst LogoControlMLGL = maplibregl.LogoControl;\nconst ScaleControlMLGL = maplibregl.ScaleControl;\nconst FullscreenControlMLGL = maplibregl.FullscreenControl;\nconst TerrainControlMLGL = maplibregl.TerrainControl;\nexport {\n  // supported,\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  PopupMLGL,\n  MarkerMLGL,\n  StyleMLGL,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  CanvasSourceMLGL,\n  GeoJSONSourceMLGL,\n  ImageSourceMLGL,\n  RasterDEMTileSourceMLGL,\n  RasterTileSourceMLGL,\n  VectorTileSourceMLGL,\n  VideoSourceMLGL,\n  prewarm,\n  clearPrewarmedResources,\n  version,\n  workerCount,\n  maxParallelImageRequests,\n  workerUrl,\n  addProtocol,\n  removeProtocol,\n  MapMLGL,\n};\n// Exporting types of class instances from MapLibre:\nexport type NavigationControlMLGL = InstanceType<typeof NavigationControlMLGL>;\nexport type GeolocateControlMLGL = InstanceType<typeof GeolocateControlMLGL>;\nexport type AttributionControlMLGL = InstanceType<\n  typeof AttributionControlMLGL\n>;\nexport type LogoControlMLGL = InstanceType<typeof LogoControlMLGL>;\nexport type ScaleControlMLGL = InstanceType<typeof ScaleControlMLGL>;\nexport type FullscreenControlMLGL = InstanceType<typeof FullscreenControlMLGL>;\nexport type TerrainControlMLGL = InstanceType<typeof TerrainControlMLGL>;\nexport type MarkerMLGL = InstanceType<typeof MarkerMLGL>;\nexport type PopupMLGL = InstanceType<typeof PopupMLGL>;\nexport type StyleMLGL = InstanceType<typeof StyleMLGL>;\nexport type LngLat = InstanceType<typeof LngLat>;\nexport type LngLatBounds = InstanceType<typeof LngLatBounds>;\nexport type MercatorCoordinate = InstanceType<typeof MercatorCoordinate>;\nexport type Evented = InstanceType<typeof Evented>;\nexport type AJAXError = InstanceType<typeof AJAXError>;\nexport type CanvasSourceMLGL = InstanceType<typeof CanvasSourceMLGL>;\nexport type GeoJSONSourceMLGL = InstanceType<typeof GeoJSONSourceMLGL>;\nexport type ImageSourceMLGL = InstanceType<typeof ImageSourceMLGL>;\nexport type RasterDEMTileSourceMLGL = InstanceType<\n  typeof RasterDEMTileSourceMLGL\n>;\nexport type RasterTileSourceMLGL = InstanceType<typeof RasterTileSourceMLGL>;\nexport type VectorTileSourceMLGL = InstanceType<typeof VectorTileSourceMLGL>;\nexport type VideoSourceMLGL = InstanceType<typeof VideoSourceMLGL>;\nexport type MapMLGL = InstanceType<typeof MapMLGL>;\n// SDK specific\nexport {\n  Map,\n  GeolocationType,\n  type MapOptions,\n  type LoadWithTerrainEvent,\n} from \"./Map\";\nexport { Marker } from \"./Marker\";\nexport { Popup } from \"./Popup\";\nexport { Style } from \"./Style\";\nexport { CanvasSource } from \"./CanvasSource\";\nexport { GeoJSONSource } from \"./GeoJSONSource\";\nexport { ImageSource } from \"./ImageSource\";\nexport { RasterTileSource } from \"./RasterTileSource\";\nexport { RasterDEMTileSource } from \"./RasterDEMTileSource\";\nexport { VectorTileSource } from \"./VectorTileSource\";\nexport { VideoSource } from \"./VideoSource\";\nexport { NavigationControl } from \"./NavigationControl\";\nexport { GeolocateControl } from \"./GeolocateControl\";\nexport { AttributionControl } from \"./AttributionControl\";\nexport { LogoControl } from \"./LogoControl\";\nexport { ScaleControl } from \"./ScaleControl\";\nexport { FullscreenControl } from \"./FullscreenControl\";\nexport { TerrainControl } from \"./TerrainControl\";\n// Export of modified versions of the controls\nexport * from \"./MaptilerGeolocateControl\";\nexport * from \"./MaptilerLogoControl\";\nexport * from \"./MaptilerTerrainControl\";\nexport * from \"./MaptilerNavigationControl\";\nexport {\n  type AutomaticStaticMapOptions,\n  type BoundedStaticMapOptions,\n  type BufferToPixelDataFunction,\n  type ByIdGeocodingOptions,\n  type CenteredStaticMapOptions,\n  type CommonForwardAndReverseGeocodingOptions,\n  type CoordinateExport,\n  type CoordinateGrid,\n  type CoordinateId,\n  type CoordinateSearch,\n  type CoordinateSearchResult,\n  type CoordinateTransformResult,\n  type CoordinateTransformation,\n  type Coordinates,\n  type CoordinatesSearchOptions,\n  type CoordinatesTransformOptions,\n  type DefaultTransformation,\n  type ElevationAtOptions,\n  type ElevationBatchOptions,\n  type FeatureHierarchy,\n  type FetchFunction,\n  type GeocodingFeature,\n  type GeocodingOptions,\n  type GeocodingSearchResult,\n  type GeolocationInfoOptions,\n  type GeolocationResult,\n  type GetDataOptions,\n  LanguageGeocoding,\n  type LanguageGeocodingOptions,\n  type LanguageGeocodingString,\n  MapStyle,\n  type MapStylePreset,\n  type MapStyleType,\n  MapStyleVariant,\n  type PixelData,\n  ReferenceMapStyle,\n  type ReverseGeocodingOptions,\n  ServiceError,\n  type StaticMapBaseOptions,\n  type StaticMapMarker,\n  type TileJSON,\n  type XYZ,\n  bufferToPixelDataBrowser,\n  circumferenceAtLatitude,\n  coordinates,\n  data,\n  elevation,\n  expandMapStyle,\n  geocoding,\n  geolocation,\n  getAutoLanguageGeocoding,\n  getBufferToPixelDataParser,\n  getTileCache,\n  mapStylePresetList,\n  math,\n  misc,\n  staticMaps,\n  styleToStyle,\n} from \"@maptiler/client\";\n\nexport * from \"./Point\";\nexport { config, SdkConfig } from \"./config\";\nexport * from \"./language\";\nexport { type Unit } from \"./unit\";\nexport * from \"./Minimap\";\nexport * from \"./converters\";\nexport * from \"./colorramp\";\nexport * from \"./helpers\";\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}